!function(){"use strict";var n="undefined"==typeof window?global:window;if("function"!=typeof n.require){var e={},t={},a={},o={}.hasOwnProperty,r=/^\.\.?(\/|$)/,i=function(n,e){for(var t,a=[],o=(r.test(e)?n+"/"+e:e).split("/"),i=0,s=o.length;i<s;i++)t=o[i],".."===t?a.pop():"."!==t&&""!==t&&a.push(t);return a.join("/")},s=function(n){return n.split("/").slice(0,-1).join("/")},l=function(e){return function(t){var a=i(s(e),t);return n.require(a,e)}},c=function(n,e){var a=null;a=_&&_.createHot(n);var o={id:n,exports:{},hot:a};return t[n]=o,e(o.exports,l(n),o),o.exports},d=function(n){return a[n]?d(a[n]):n},u=function(n,e){return d(i(s(n),e))},f=function(n,a){null==a&&(a="/");var r=d(n);if(o.call(t,r))return t[r].exports;if(o.call(e,r))return c(r,e[r]);throw new Error("Cannot find module '"+n+"' from '"+a+"'")};f.alias=function(n,e){a[e]=n};var m=/\.[^.\/]+$/,v=/\/index(\.[^\/]+)?$/,h=function(n){if(m.test(n)){var e=n.replace(m,"");o.call(a,e)&&a[e].replace(m,"")!==e+"/index"||(a[e]=n)}if(v.test(n)){var t=n.replace(v,"");o.call(a,t)||(a[t]=n)}};f.register=f.define=function(n,a){if("object"==typeof n)for(var r in n)o.call(n,r)&&f.register(r,n[r]);else e[n]=a,delete t[n],h(n)},f.list=function(){var n=[];for(var t in e)o.call(e,t)&&n.push(t);return n};var _=n._hmr&&new n._hmr(u,f,e,t);f._cache=t,f.hmr=_&&_.wrap,f.brunch=!0,n.require=f}}(),function(){var n;window;require.register("initialize.js",function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{"default":n}}var o=e("twgl.js"),r=a(o),i=e("js/controller"),s=a(i);document.addEventListener("DOMContentLoaded",function(){var n=r["default"].getWebGLContext(document.querySelector(".map-canvas canvas"));new s["default"](n)})}),require.register("js/camera.js",function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{"default":n}}function o(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(n,"__esModule",{value:!0});var r=function(){function n(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}return function(e,t,a){return t&&n(e.prototype,t),a&&n(e,a),e}}(),i=e("lodash"),s=a(i),l=e("hammerjs"),c=(a(l),e("twgl.js")),d=a(c),u=e("./controlRange"),f=a(u),m=e("./utils"),v=d["default"].m4,h=function(){function n(e){var t=this;o(this,n),this.gl=e,this.fov=50,this.longitude=new f["default"](0,(-180),180,(!0)),this.latitude=new f["default"](0,(-90),90),this.zoom=new f["default"](.5,0,1),this.dragging=!1,this.dragStart=void 0,this.mousePosition=void 0,this.hammer=new Hammer(e.canvas),this.hammer.get("pinch").set({enable:!0}),document.addEventListener("mousemove",function(n){t.handleMouseMove(n)}),e.canvas.addEventListener("mousedown",function(){t.dragging=!0}),document.addEventListener("selectstart",function(n){t.dragging===!0&&n.preventDefault()}),document.addEventListener("mouseup",function(){t.dragging=!1}),e.canvas.addEventListener("scroll",function(){return!1}),this.hammer.on("pan",function(n){return"mouse"!=n.pointerType&&t.handlePan(8*n.velocityX,8*n.velocityY),!1}),this.hammer.on("pinchstart",function(n){t.lastZoom=t.zoom.value,t.pinching=!0}),this.hammer.on("pinchend",function(n){t.pinching=!1}),this.hammer.on("pinch",function(n){t.pinching&&t.zoom.changeTo(t.lastZoom+.5*(n.scale-1))}),window.addEventListener("wheel",function(n){var a=.001*-n.deltaY;1===n.mozInputSource&&1===n.deltaMode&&(a*=50),n.target==e.canvas&&(t.zoom.changeBy(a),n.preventDefault())})}return r(n,[{key:"handleMouseMove",value:function(n){var e={x:n.screenX,y:n.screenY};if(void 0!==this.mousePosition&&this.dragging){var t=e.x-this.mousePosition.x,a=e.y-this.mousePosition.y;this.handlePan(.3*t,.3*a),n.stopPropagation()}this.mousePosition=e}},{key:"handlePan",value:function(n,e){var t=1-.8*this.zoom.value;this.longitude.changeBy(-n*t),this.latitude.changeBy(e*t)}},{key:"getRenderValues",value:function(n){var e=n.canvas.clientWidth/n.canvas.clientHeight,t=(0,m.toRadians)(30)/s["default"].clamp(e,0,1),a=v.perspective(t,e,.01,10),o=[0,0,-(4.5-3*this.zoom.value)],r=v.identity();v.rotateY(r,(0,m.toRadians)(this.longitude.value+180),r),v.rotateX(r,(0,m.toRadians)(this.latitude.value),r),o=v.transformPoint(r,o);var i=v.transformPoint(r,[0,1,0]),l=[0,0,0],c=v.inverse(v.lookAt(o,l,i));return{view:c,projection:a,eye:o}}}]),n}();n["default"]=h}),require.register("js/components/checkboxOption.js",function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{"default":n}}function o(n,e){i["default"].component("checkbox-option",i["default"].extend({data:function(){return e[this.property].data},props:["label","property"],template:'\n      <label class="checkbox-option">\n        <input type="checkbox" v-model="enabled">\n        {{label}}\n      </label>\n    ',watch:{enabled:{handler:function(){n.updated(!0)}}}}))}Object.defineProperty(n,"__esModule",{value:!0}),n["default"]=o;var r=e("vue"),i=a(r),s=e("lodash");a(s)}),require.register("js/components/debugPanel.js",function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{"default":n}}function o(n){i["default"].component("debug-panel",i["default"].extend({data:function(){return n},computed:{formattedFps:function(){return numeral(this.fps).format("0.00")}},template:'\n      <div class="debug-panel">\n        <div class="top-row">\n          <label>FPS</label>\n          <span>{{formattedFps}}</span>\n        </div>\n      </div>\n    '}))}Object.defineProperty(n,"__esModule",{value:!0}),n["default"]=o;var r=e("vue"),i=a(r)}),require.register("js/components/rangeSlider.js",function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{"default":n}}function o(n,e){i["default"].component("range-slider",i["default"].extend({init:function(){this.updateFormatted=function(n){n.formatted=e[n.property].formatted(n)},this.throttleFormatted=l["default"].throttle(this.updateFormatted,50)},ready:function(){this.updateFormatted(this)},data:function(){return e[this.property].data},props:["label","property","formatted"],template:'\n      <div class="range-slider range-control">\n        <div class="top-row">\n          <label>{{label}}</label>\n          <span>{{formatted}}</span>\n        </div>\n        <div class="slider">\n          <input type=\'range\'\n            min=\'{{min}}\'\n            max=\'{{max}}\'\n            step="any"\n            v-model="value">\n        </div>\n      </div>\n    ',watch:{value:{handler:function(){this.throttleFormatted(this),n.updated()}}}}))}Object.defineProperty(n,"__esModule",{value:!0}),n["default"]=o;var r=e("vue"),i=a(r),s=e("lodash"),l=a(s)}),require.register("js/components/renderModes.js",function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{"default":n}}function o(n,e){i["default"].component("render-modes",i["default"].extend({data:function(){return e},computed:{},props:[],template:'\n      <div class="render-modes">\n        <div class="top-row">\n          <label>Mode</label>\n        </div>\n        <div class="radio-buttons">\n          <div class="radio-button"\n            v-bind:class="{ active: renderMode == \'dayAndNight\' }">\n            <label>\n              <input type="radio" name="render-mode"\n                value="dayAndNight" v-model="renderMode"\n                checked>\n              Day and Night\n            </label>\n            <div v-show="renderMode == \'dayAndNight\'" class="sub-group">\n              <range-slider\n                label="Hour of Day"\n                property="hourOfDay">\n              </range-slider>\n              <range-slider\n                label="Day of Year"\n                property="dayOfYear">\n              </range-slider>\n            </div>\n          </div>\n          <div class="radio-button"\n            v-bind:class="{ active: renderMode == \'day\' }">\n            <label>\n              <input type="radio" name="render-mode"\n                value="day" v-model="renderMode">\n              Day\n            </label>\n          </div>\n          <div class="radio-button"\n            v-bind:class="{ active: renderMode == \'night\' }">\n            <label>\n              <input type="radio" name="render-mode"\n                value="night" v-model="renderMode">\n              Night\n            </label>\n          </div>\n          <div class="radio-button"\n            v-bind:class="{ active: renderMode == \'elevation\' }">\n            <label>\n              <input type="radio" name="render-mode"\n                value="elevation" v-model="renderMode">\n              Elevation\n            </label>\n            <div v-show="renderMode == \'elevation\'" class="sub-group">\n              <range-slider\n                label="Elevation Scale"\n                property="elevationScale">\n              </range-slider>\n            </div>\n          </div>\n        </div>\n      </div>\n    ',watch:{renderMode:{handler:function(){n.updated()}}}}))}Object.defineProperty(n,"__esModule",{value:!0}),n["default"]=o;var r=e("vue"),i=a(r)}),require.register("js/controlRange.js",function(n,e,t){"use strict";function a(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(n,"__esModule",{value:!0});var o=function(){function n(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}return function(e,t,a){return t&&n(e.prototype,t),a&&n(e,a),e}}(),r=function(){function n(e,t,o){var r=!(arguments.length<=3||void 0===arguments[3])&&arguments[3];a(this,n),this.value=e,this.min=t,this.max=o,this.wrap=r}return o(n,[{key:"changeBy",value:function(n){this.changeTo(this.value+n)}},{key:"changeTo",value:function(n){this.wrap?this.setWrap(n):this.setClamp(n)}},{key:"setClamp",value:function(n){this.value=_.clamp(n,this.min,this.max)}},{key:"setWrap",value:function(n){if(n>this.max){var e=n%this.max;n=this.min+e}else n<this.min&&(n=this.max-(this.min-n));this.value=n}}]),n}();n["default"]=r}),require.register("js/controller.js",function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{"default":n}}function o(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(n,"__esModule",{value:!0});var r=function(){function n(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}return function(e,t,a){return t&&n(e.prototype,t),a&&n(e,a),e}}(),i=e("vue"),s=a(i),l=e("moment"),c=(a(l),e("numeral")),d=a(c),u=e("lodash"),f=a(u),m=e("./scene"),v=a(m),h=e("./renderer"),_=a(h),p=e("./camera"),g=a(p),b=e("./vectorLayer"),x=a(b),y=e("./performanceStats"),w=a(y),L=e("./components/rangeSlider"),N=a(L),F=e("./components/checkboxOption"),S=a(F),T=e("./components/renderModes"),G=a(T),C=e("./components/debugPanel"),H=a(C),D=function(){function n(e){var t=this;o(this,n),this.vectorLayer=new x["default"](e),this.scene=new v["default"](e,this.vectorLayer),this.renderer=new _["default"](e,this.scene),this.camera=new g["default"](e),this.performanceStats=new w["default"];var a=function(){return""},r=function(n){return(0,d["default"])(n.value).format("0.00")+"°"},i=function(){return t.scene.calculatedMoment().format("h:mm a")+" UTC"},l=function(){return t.scene.calculatedMoment().format("YYYY-MM-DD")},c=function(n){return 1===n.value?"(Realistic) 1x":(0,d["default"])(n.value).format("0.00")+"X"},u={latitude:{data:this.camera.latitude,formatted:r},longitude:{data:this.camera.longitude,formatted:r},zoom:{data:this.camera.zoom,formatted:a},hourOfDay:{data:this.scene.hourOfDay,formatted:i},dayOfYear:{data:this.scene.dayOfYear,formatted:l},elevationScale:{data:this.scene.elevationScale,formatted:c},rivers:{data:this.vectorLayer.options.rivers},countries:{data:this.vectorLayer.options.countries}};(0,N["default"])(this,u),(0,S["default"])(this,u),(0,G["default"])(this,this.scene),(0,H["default"])(this.performanceStats),this.vue=new s["default"]({el:".map-container"}),this.updateQueued=!1,this.updated(),window.addEventListener("resize",function(){t.updated()}),window.addEventListener("texture-loaded",function(){t.updated()})}return r(n,[{key:"updated",value:function(n){var e=this;n?f["default"].defer(function(){e.vectorLayer.draw()}):this.updateQueued||(this.updateQueued=!0,window.requestAnimationFrame(function(){e.renderFrame(),e.updateQueued=!1}))}},{key:"renderFrame",value:function(){this.renderer.render(window.performance.now(),this.scene,this.camera,this.renderer),this.performanceStats.countFrame()}}]),n}();n["default"]=D}),require.register("js/coordinates.js",function(n,e,t){"use strict";function a(n){return n/1e3/86400+2440587.5}function o(n){var e=a(n)-2451545,t=357.529+.98560028*e,o=280.459+.98564736*e,i=o+1.915*Math.sin((0,r.toRadians)(t))+.02*Math.sin((0,r.toRadians)(2*t)),s=23.439-3.6e-7*e,l=Math.cos((0,r.toRadians)(s))*Math.sin((0,r.toRadians)(i)),c=Math.cos((0,r.toRadians)(i)),d=Math.atan2(l,c),u=Math.asin(Math.sin((0,r.toRadians)(s))*Math.sin((0,r.toRadians)(i))),f=18.697374558+24.06570982441908*e,m=f/24*Math.PI*2-d;return{hourAngle:m,declination:u}}Object.defineProperty(n,"__esModule",{value:!0}),n["default"]=o;var r=e("./utils")}),require.register("js/octahedronSphere.js",function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{"default":n}}function o(n){for(var e=new Float32Array(u["default"].flatten([[0,1,0],[0,0,-1],[-1,0,0],[0,1,0],[-1,0,0],[0,0,1],[0,1,0],[0,0,1],[1,0,0],[0,1,0],[1,0,0],[0,0,-1],[0,-1,0],[-1,0,0],[0,0,-1],[0,-1,0],[0,0,1],[-1,0,0],[0,-1,0],[1,0,0],[0,0,1],[0,-1,0],[0,0,-1],[1,0,0]])),t=[new f.Vec3Array(e)],a=0;a<n;a++){for(var o=t[a],s=new f.Vec3Array(new Float32Array(4*o.data.length)),l=0;l<o.length;l+=3)r(o,s,l);t.push(s)}for(var c=t[t.length-1],d=new f.Vec2Array(new Float32Array(2*c.length)),m=0;m<c.length;m+=3)i(d,c,m);var v=0,h=new Int16Array(c.length),_=new f.Vec3Array(new Float32Array(c.data.length)),p=new f.Vec2Array(new Float32Array(d.data.length)),g={},b=0;for(b;b<c.length;b++){var x=c.get(b),y=d.get(b),w=[x[0],x[1],x[2],y[0],y[1]].join(","),L=g[w];void 0===L?(g[w]=v,_.set(v,x),p.set(v,y),h[b]=v,v+=1):h[b]=L}return{indices:h.subarray(0,b),position:_.data.subarray(0,3*v),texcoord:p.data.subarray(0,2*v),elevation:new Float32Array(v)}}function r(n,e,t){var a=n.get(t),o=n.get(t+1),r=n.get(t+2),i=Array.prototype.slice.call(m.normalize(m.add(a,o))),s=Array.prototype.slice.call(m.normalize(m.add(o,r))),l=Array.prototype.slice.call(m.normalize(m.add(r,a)));e.setRange(4*t,[a,i,l,i,s,l,i,o,s,l,s,r])}function i(n,e,t){var a=s(e.get(t)),o=s(e.get(t+1)),r=s(e.get(t+2)),i=Math.min(a[0],o[0],r[0]),l=Math.max(a[0],o[0],r[0]);l-i>.5&&(a[0]=1==a[0]?0:a[0],o[0]=1==o[0]?0:o[0],r[0]=1==r[0]?0:r[0]),n.setRange(t,[a,o,r])}function s(n){return[Math.atan2(n[0],n[2])/(2*Math.PI)+.5,1-(Math.asin(n[1])/Math.PI+.5)]}Object.defineProperty(n,"__esModule",{value:!0}),n["default"]=o;var l=e("twgl.js"),c=a(l),d=e("lodash"),u=a(d),f=e("./vectorArray"),m=c["default"].v3}),require.register("js/performanceStats.js",function(n,e,t){"use strict";function a(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(n,"__esModule",{value:!0});var o=function(){function n(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}return function(e,t,a){return t&&n(e.prototype,t),a&&n(e,a),e}}(),r=function(){function n(){a(this,n),this.fps=0,this.frames=0,this.totalFrames=0,this.updated=0}return o(n,[{key:"countFrame",value:function(){var n=window.performance.now();this.frames+=1,this.totalFrames+=1,n-this.updated>200&&(this.fps=this.frames/(n-this.updated)*1e3,this.updated=n,this.frames=0)}}]),n}();n["default"]=r}),require.register("js/renderer.js",function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{"default":n}}function o(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(n,"__esModule",{value:!0});var r=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(n[a]=t[a])}return n},i=function(){function n(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}return function(e,t,a){return t&&n(e.prototype,t),a&&n(e,a),e}}(),s=e("twgl.js"),l=a(s),c=e("../shaders/globe.vert.glsl"),d=a(c),u=e("../shaders/dayAndNight.frag.glsl"),f=a(u),m=e("../shaders/day.frag.glsl"),v=a(m),h=e("../shaders/night.frag.glsl"),_=a(h),p=e("../shaders/elevation.frag.glsl"),g=a(p),b=l["default"].m4,x=function(){function n(e,t){o(this,n),this.gl=e,e.clearColor(0,0,0,0),this.derivatives=e.getExtension("OES_standard_derivatives"),this.anisotropic=e.getExtension("EXT_texture_filter_anisotropic"),this.uniforms={};for(name in t.textures){var a=t.textures[name];this.setupGlobeTexture(e,a),this.uniforms[name]=a}this.programs={dayAndNight:l["default"].createProgramInfo(e,[d["default"],f["default"]]),day:l["default"].createProgramInfo(e,[d["default"],v["default"]]),night:l["default"].createProgramInfo(e,[d["default"],_["default"]]),elevation:l["default"].createProgramInfo(e,[d["default"],g["default"]])},e.enable(e.DEPTH_TEST),e.enable(e.CULL_FACE)}return i(n,[{key:"setupGlobeTexture",value:function(n,e){n.bindTexture(n.TEXTURE_2D,e),this.anisotropic&&n.texParameterf(n.TEXTURE_2D,this.anisotropic.TEXTURE_MAX_ANISOTROPY_EXT,16),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.REPEAT),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.LINEAR_MIPMAP_LINEAR)}},{key:"render",value:function(n,e,t){var a=this.gl;this.updateCanvasSize(a),a.clear(a.COLOR_BUFFER_BIT|a.DEPTH_BUFFER_BIT);var o=b.identity(),i=e.getSunVector();r(this.uniforms,t.getRenderValues(a),e.getElevationScales(),{model:o,time:n,lightDirection:b.transformPoint(i,[-1,0,0])});var s=this.programs[e.renderMode];a.useProgram(s.program),l["default"].setBuffersAndAttributes(a,s,e.globeBuffer),l["default"].setUniforms(s,this.uniforms),a.drawElements(a.TRIANGLES,e.globeBuffer.numElements,a.UNSIGNED_SHORT,0)}},{key:"updateCanvasSize",value:function(n){var e=n.canvas.parentNode.offsetWidth,t=n.canvas.parentNode.offsetHeight;if(e+"px"!=n.canvas.style.width||t+"px"!=n.canvas.style.height){n.canvas.style.width=e+"px",n.canvas.style.height=t+"px";var a=window.devicePixelRatio||1;n.canvas.width=Math.floor(e*a),n.canvas.height=Math.floor(t*a),n.viewport(0,0,n.canvas.width,n.canvas.height)}}}]),n}();n["default"]=x}),require.register("js/scene.js",function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{"default":n}}function o(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(n,"__esModule",{value:!0});var r=function(){function n(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}return function(e,t,a){return t&&n(e.prototype,t),a&&n(e,a),e}}(),i=e("twgl.js"),s=a(i),l=e("moment"),c=a(l),d=e("lodash"),u=a(d),f=e("./utils"),m=e("./controlRange"),v=a(m),h=e("./octahedronSphere"),_=a(h),p=e("./coordinates.js"),g=a(p),b=s["default"].m4,x=function(){function n(e,t){var a=this;o(this,n),this.gl=e,this.vectorLayer=t,this.hourOfDay=new v["default"](12,.001,23.999),this.dayOfYear=new v["default"](182,1,365),this.elevationScale=new v["default"](10,1,30),this.sphere=(0,_["default"])(6),this.globeBuffer=s["default"].createBufferInfoFromArrays(e,{indices:{numComponents:3,data:this.sphere.indices},position:{numComponents:3,data:this.sphere.position},texcoord:{numComponents:2,data:this.sphere.texcoord},elevation:{numComponents:1,data:this.sphere.elevation}}),this.renderMode="dayAndNight",this.fillInElevations(),this.initTextures(),window.addEventListener("vector-layer-updated",function(){s["default"].setTextureFromElement(a.gl,a.textures.landmaskMap,a.vectorLayer.layer.node()),(0,f.dispatchEvent)("texture-loaded")})}return r(n,[{key:"initTextures",value:function(){this.textures=s["default"].createTextures(this.gl,{diffuseMap:{format:this.gl.RGB,internalFormat:this.gl.RGB,src:"data/color-4096.jpg"},topographyMap:{format:this.gl.LUMINANCE,internalFormat:this.gl.LUMINANCE,src:"data/topo-bathy-4096.jpg"},landmaskMap:{src:this.vectorLayer.layer.node(),format:this.gl.RGB,internalFormat:this.gl.RGB},lightsMap:{src:"data/lights-4096.png",format:this.gl.LUMINANCE,internalFormat:this.gl.LUMINANCE}},function(){(0,f.dispatchEvent)("texture-loaded")})}},{key:"calculatedMoment",value:function(){return(0,c["default"])("2016-01-01T00:00:00.000Z").utcOffset(0).dayOfYear(this.dayOfYear.value).add(60*this.hourOfDay.value*60,"seconds")}},{key:"getSunVector",value:function(){var n=this.calculatedMoment(),e=(0,g["default"])(u["default"].toInteger(n.format("x"))),t=b.identity();return t=b.rotateY(t,Math.PI/2-e.hourAngle),t=b.rotateZ(t,-e.declination)}},{key:"getElevationScales",value:function(){var n=20068/6371e3,e=n,t=0;return"elevation"===this.renderMode&&(e=this.elevationScale.value*n,t=this.elevationScale.value*n),{oceanElevationScale:t,landElevationScale:e}}},{key:"fillInElevations",value:function(){var n=this,e=new Image;e.onload=function(){var t=document.createElement("canvas");t.width=e.width,t.height=e.height;var a=t.getContext("2d");a.drawImage(e,0,0,e.width,e.height);for(var o=a.getImageData(0,0,e.width,e.height).data,r=e.width-1,i=e.height-1,l=0;l<n.sphere.elevation.length;l++){var c=n.sphere.texcoord[2*l],d=n.sphere.texcoord[2*l+1],f=u["default"].clamp(u["default"].floor((1==c?0:c)*r),0,r),m=u["default"].clamp(u["default"].floor((1==d?0:d)*i),0,i),v=o[4*[f+m*e.width]];n.sphere.elevation[l]=v/255-.5}s["default"].setAttribInfoBufferFromArray(n.gl,n.globeBuffer.attribs.elevation,n.sphere.elevation)},e.src="data/topo-bathy-128.jpg"}}]),n}();n["default"]=x}),require.register("js/utils.js",function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{"default":n}}function o(n){return n/180*Math.PI}function r(n){var e=document.createEvent("CustomEvent");e.initCustomEvent(n,!1,!1,{}),window.dispatchEvent(e)}function i(n,e){d["default"].includes(["IE","Microsoft Edge","Chrome Mobile"],l["default"].name)||(n.globalCompositeOperation=e)}Object.defineProperty(n,"__esModule",{value:!0}),n.toRadians=o,n.dispatchEvent=r,n.compositeOperation=i;var s=e("platform"),l=a(s),c=e("lodash"),d=a(c)}),require.register("js/vectorArray.js",function(n,e,t){"use strict";function a(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(n,"__esModule",{value:!0});var o=function(){function n(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}return function(e,t,a){return t&&n(e.prototype,t),a&&n(e,a),e}}();n.Vec2Array=function(){function n(e){a(this,n),this.data=e,this.length=e.length/2}return o(n,[{key:"get",value:function(n){var e=2*n;return[this.data[e],this.data[e+1]]}},{key:"setRange",value:function(n,e){for(var t=0;t<e.length;t++)this.set(n+t,e[t])}},{key:"set",value:function(n,e){this.data[2*n]=e[0],this.data[2*n+1]=e[1]}}]),n}(),n.Vec3Array=function(){function n(e){a(this,n),this.data=e,this.length=e.length/3}return o(n,[{key:"get",value:function(n){var e=3*n;return[this.data[e],this.data[e+1],this.data[e+2]]}},{key:"setRange",value:function(n,e){for(var t=0;t<e.length;t++)this.set(n+t,e[t])}},{key:"set",value:function(n,e){this.data[3*n]=e[0],this.data[3*n+1]=e[1],this.data[3*n+2]=e[2]}}]),n}()}),require.register("js/vectorLayer.js",function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{"default":n}}function o(n){if(n&&n.__esModule)return n;var e={};if(null!=n)for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(e[t]=n[t]);return e["default"]=n,e}function r(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(n,"__esModule",{value:!0});var i=function(){function n(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}return function(e,t,a){return t&&n(e.prototype,t),a&&n(e,a),e}}(),s=e("d3"),l=o(s),c=e("topojson"),d=o(c),u=e("lodash"),f=a(u),m=e("./utils"),v=function(){function n(e){var t=this;r(this,n),this.options={rivers:{enabled:!1},countries:{enabled:!0}},e.getParameter(e.MAX_TEXTURE_SIZE)>=8192?(this.width=8192,this.height=4096,this.scale=1):(this.width=4096,this.height=2048,this.scale=.5);var a=l.geoEquirectangular().scale(this.height/Math.PI).translate([this.width/2,this.height/2]);this.layer=l.select(document.createElement("canvas")).attr("width",this.width).attr("height",this.height),this.ctx=this.layer.node().getContext("2d"),this.path=l.geoPath().projection(a).context(this.ctx),l.json("data/vectors.json",function(n,e){t.world=e,t.land=d.feature(t.world,t.world.objects.land),t.lakes=d.feature(t.world,t.world.objects.lakes),t.rivers=d.feature(t.world,t.world.objects.rivers),t.countries=d.feature(t.world,t.world.objects.countries),t.draw()})}return i(n,[{key:"draw",value:function(){(0,m.compositeOperation)(this.ctx,"source-over"),this.ctx.fillStyle="#000",this.ctx.fillRect(0,0,this.width,this.height),this.ctx.beginPath(),this.path(this.land),this.ctx.fillStyle="#f00",this.ctx.fill(),this.ctx.beginPath(),this.path(this.lakes),this.ctx.fillStyle="#000",this.ctx.fill(),this.options.rivers.enabled&&(this.ctx.beginPath(),this.path(this.rivers),this.ctx.lineWidth=1*this.scale,this.ctx.strokeStyle="rgba(0, 0, 0, 0.75)",this.ctx.stroke()),this.options.countries.enabled&&((0,m.compositeOperation)(this.ctx,"lighter"),this.ctx.beginPath(),this.path(this.countries),this.ctx.lineWidth=3*this.scale,this.ctx.strokeStyle="rgba(0, 0, 255, 0.4)",this.ctx.stroke()),f["default"].defer(function(){(0,m.dispatchEvent)("vector-layer-updated")})}}]),n}();n["default"]=v}),require.register("shaders/day.frag.glsl",function(n,e,t){t.exports='#extension GL_OES_standard_derivatives : enable\nprecision highp float;\n#define GLSLIFY 1\n\nconst float gamma_4_0 = 2.2;\n\nfloat toLinear_4_1(float v) {\n  return pow(v, gamma_4_0);\n}\n\nvec2 toLinear_4_1(vec2 v) {\n  return pow(v, vec2(gamma_4_0));\n}\n\nvec3 toLinear_4_1(vec3 v) {\n  return pow(v, vec3(gamma_4_0));\n}\n\nvec4 toLinear_4_1(vec4 v) {\n  return vec4(toLinear_4_1(v.rgb), v.a);\n}\n\n\n\nconst float gamma_5_2 = 2.2;\n\nfloat toGamma_5_3(float v) {\n  return pow(v, 1.0 / gamma_5_2);\n}\n\nvec2 toGamma_5_3(vec2 v) {\n  return pow(v, vec2(1.0 / gamma_5_2));\n}\n\nvec3 toGamma_5_3(vec3 v) {\n  return pow(v, vec3(1.0 / gamma_5_2));\n}\n\nvec4 toGamma_5_3(vec4 v) {\n  return vec4(toGamma_5_3(v.rgb), v.a);\n}\n\n\n\n// Based on https://github.com/vorg/pragmatic-pbr/blob/master/local_modules/glsl-tonemap-uncharted2/index.glsl\nfloat A_1_4 = 0.15;\nfloat B_1_5 = 0.50;\nfloat C_1_6 = 0.10;\nfloat D_1_7 = 0.20;\nfloat E_1_8 = 0.02;\nfloat F_1_9 = 0.30;\nfloat W_1_10 = 11.2;\n\nvec3 Uncharted2Tonemap_1_11(vec3 x) {\n   return ((x * (A_1_4 * x + C_1_6 * B_1_5) + D_1_7 * E_1_8) / (x * (A_1_4 * x + B_1_5) + D_1_7 * F_1_9)) - E_1_8 / F_1_9;\n}\n\n// Based on Filmic Tonemapping Operators http://filmicgames.com/archives/75\nvec3 tonemap_1_12(vec3 color) {\n    float ExposureBias = 2.0;\n    vec3 curr = Uncharted2Tonemap_1_11(ExposureBias * color);\n\n    vec3 whiteScale = 1.0 / Uncharted2Tonemap_1_11(vec3(W_1_10));\n    return curr * whiteScale;\n}\n\n\n\n// Set camera exposure based on angle between sun and eye\n\nfloat exposure_2_13(vec3 eye, vec3 L) {\n  return mix(\n    1.5,\n    300.0,\n    pow((1.0 - dot(normalize(eye), L)) / 2.0, 10.0)\n  );\n}\n\n\n\n/*\nModified from https://github.com/wdas/brdf/blob/master/src/brdfs/disney.brdf\n\nOriginal license notice:\n# Copyright Disney Enterprises, Inc.  All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the "License");\n# you may not use this file except in compliance with the License\n# and the following modification to it: Section 6 Trademarks.\n# deleted and replaced with:\n#\n# 6. Trademarks. This License does not grant permission to use the\n# trade names, trademarks, service marks, or product names of the\n# Licensor and its affiliates, except as required for reproducing\n# the content of the NOTICE file.\n#\n# You may obtain a copy of the License at\n# http://www.apache.org/licenses/LICENSE-2.0\n*/\n\nfloat specularTint_3_14 = 0.0;\nfloat anisotropic_3_15 = 0.0;\nfloat sheen_3_16 = 0.0;\nfloat sheenTint_3_17 = 0.5;\nfloat clearcoat_3_18 = 0.0;\nfloat clearcoatGloss_3_19 = 1.0;\n\nconst float PI_3_20 = 3.14159265358979323846;\n\nfloat sqr_3_21(float x) { return x*x; }\n\nfloat SchlickFresnel_3_22(float u) {\n  float m = clamp(1.0 - u, 0.0, 1.0);\n  float m2 = m * m;\n  return m2 * m2 * m; // pow(m, 5)\n}\n\nfloat GTR1_3_23(float NdotH, float a) {\n  if (a >= 1.0) return 1.0 / PI_3_20;\n  float a2 = a * a;\n  float t = 1.0 + (a2 - 1.0) * NdotH * NdotH;\n  return (a2 - 1.0) / (PI_3_20 * log(a2) * t);\n}\n\nfloat GTR2_3_24(float NdotH, float a) {\n  float a2 = a * a;\n  float t = 1.0 + (a2 - 1.0) * NdotH * NdotH;\n  return a2 / (PI_3_20 * t * t);\n}\n\nfloat GTR2_aniso_3_25(float NdotH, float HdotX, float HdotY, float ax, float ay) {\n  return 1.0 / (\n    PI_3_20 * ax * ay *\n    sqr_3_21(sqr_3_21(HdotX / ax) + sqr_3_21(HdotY / ay) + NdotH * NdotH)\n  );\n}\n\nfloat smithG_GGX_3_26(float Ndotv, float alphaG) {\n  float a = alphaG * alphaG;\n  float b = Ndotv * Ndotv;\n  return 1.0 / (Ndotv + sqrt(a + b - a * b));\n}\n\nvec3 mon2lin_3_27(vec3 x) {\n  return vec3(pow(x[0], 2.2), pow(x[1], 2.2), pow(x[2], 2.2));\n}\n\nvec3 brdf_3_28(\n  vec3 baseColor,\n  float metallic,\n  float subsurface,\n  float specular,\n  float roughness,\n  vec3 L, vec3 V, vec3 N\n) {\n  float NdotL = dot(N, L);\n  float NdotV = dot(N, V);\n\n  vec3 H = normalize(L + V);\n  float NdotH = dot(N, H);\n  float LdotH = dot(L, H);\n\n  vec3 Cdlin = mon2lin_3_27(baseColor);\n  float Cdlum = 0.3 * Cdlin[0] + 0.6 * Cdlin[1]  + 0.1 * Cdlin[2]; // luminance approx.\n\n  vec3 Ctint = Cdlum > 0.0 ? Cdlin / Cdlum : vec3(1.0); // normalize lum. to isolate hue+sat\n  vec3 Cspec0 = mix(specular * .08 * mix(vec3(1.0), Ctint, specularTint_3_14), Cdlin, metallic);\n  vec3 Csheen = mix(vec3(1.0), Ctint, sheenTint_3_17);\n\n  // Diffuse fresnel - go from 1 at normal incidence to .5 at grazing\n  // and mix in diffuse retro-reflection based on roughness\n  float FL = SchlickFresnel_3_22(NdotL), FV = SchlickFresnel_3_22(NdotV);\n  float Fd90 = 0.5 + 2.0 * LdotH * LdotH * roughness;\n  float Fd = mix(1.0, Fd90, FL) * mix(1.0, Fd90, FV);\n\n  // Based on Hanrahan-Krueger brdf approximation of isotropic bssrdf\n  // 1.25 scale is used to (roughly) preserve albedo\n  // Fss90 used to "flatten" retroreflection based on roughness\n  float Fss90 = LdotH * LdotH * roughness;\n  float Fss = mix(1.0, Fss90, FL) * mix(1.0, Fss90, FV);\n  float ss = 1.25 * (Fss * (1.0 / (NdotL + NdotV) - 0.5) + 0.5);\n\n  // specular\n  float Ds = GTR2_3_24(NdotH, max(0.001, sqr_3_21(roughness)));\n  float FH = SchlickFresnel_3_22(LdotH);\n  vec3 Fs = mix(Cspec0, vec3(1.0), FH);\n  float roughg = sqr_3_21(roughness * 0.5 + 0.5);\n  float Gs = smithG_GGX_3_26(NdotL, roughg) * smithG_GGX_3_26(NdotV, roughg);\n\n  // sheen\n  vec3 Fsheen = FH * sheen_3_16 * Csheen;\n\n  // clearcoat (ior = 1.5 -> F0 = 0.04)\n  float Dr = GTR1_3_23(NdotH, mix(0.1, 0.001, clearcoatGloss_3_19));\n  float Fr = mix(0.04, 1.0, FH);\n  float Gr = smithG_GGX_3_26(NdotL, 0.25) * smithG_GGX_3_26(NdotV, 0.25);\n\n  return ((1.0/PI_3_20) * mix(Fd, ss, subsurface) * Cdlin + Fsheen)\n    * (1.0 - metallic) +\n    Gs * Fs * Ds +\n    0.25 * clearcoat_3_18 * Gr * Fr * Dr;\n}\n\n\n\n\nuniform sampler2D topographyMap;\nuniform sampler2D diffuseMap;\nuniform sampler2D landmaskMap;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\n\nvoid main() {\n  vec3 constantLight = vNormal;\n  vec3 V = vNormal;\n\n  vec3 infoSample = texture2D(landmaskMap, vUv).rgb;\n  float landness = infoSample.r;\n  float countryBorder = infoSample.b;\n\n  float oceanDepth = (0.5 - texture2D(topographyMap, vUv).r) * 2.0;\n\n  vec3 oceanColor = mix(\n    vec3(0.1, 0.15, 0.45),\n    vec3(0.1, 0.15, 0.35),\n    oceanDepth\n  );\n\n  vec3 diffuseColor = mix(\n    oceanColor,\n    toLinear_4_1(texture2D(diffuseMap, vUv).rgb),\n    landness\n  );\n\n  vec3 N = vNormal;\n  vec3 L = normalize(constantLight);\n  vec3 H = normalize(L + V);\n\n  float roughness = mix(\n    mix(0.75, 0.55, oceanDepth),\n    (1.0 - diffuseColor.r * 0.5),\n    landness\n  );\n\n  vec3 color = vec3(0.0);\n  if (dot(vNormal, L) > 0.0) {\n    vec3 lightColor = vec3(10.0);\n\n    color = lightColor * brdf_3_28(\n      diffuseColor,\n      0.0, //metallic\n      0.5, //subsurface\n      0.0, //specular\n      roughness, //roughness\n      L, V, N\n    );\n  }\n\n  vec3 shaded = toGamma_5_3(tonemap_1_12(color * 1.0));\n  vec3 final = mix(shaded, vec3(1.0), countryBorder);\n  gl_FragColor = vec4(final, 1.0);\n}\n';
}),require.register("shaders/dayAndNight.frag.glsl",function(n,e,t){t.exports='#extension GL_OES_standard_derivatives : enable\nprecision highp float;\n#define GLSLIFY 1\n\nconst float gamma_9_0 = 2.2;\n\nfloat toLinear_9_1(float v) {\n  return pow(v, gamma_9_0);\n}\n\nvec2 toLinear_9_1(vec2 v) {\n  return pow(v, vec2(gamma_9_0));\n}\n\nvec3 toLinear_9_1(vec3 v) {\n  return pow(v, vec3(gamma_9_0));\n}\n\nvec4 toLinear_9_1(vec4 v) {\n  return vec4(toLinear_9_1(v.rgb), v.a);\n}\n\n\n\nconst float gamma_10_2 = 2.2;\n\nfloat toGamma_10_3(float v) {\n  return pow(v, 1.0 / gamma_10_2);\n}\n\nvec2 toGamma_10_3(vec2 v) {\n  return pow(v, vec2(1.0 / gamma_10_2));\n}\n\nvec3 toGamma_10_3(vec3 v) {\n  return pow(v, vec3(1.0 / gamma_10_2));\n}\n\nvec4 toGamma_10_3(vec4 v) {\n  return vec4(toGamma_10_3(v.rgb), v.a);\n}\n\n\n\n// Based on https://docs.unrealengine.com/latest/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf\n\nvec2 heightDerivative_1_4(vec2 texST, sampler2D map) {\n    vec2 TexDx = dFdx(texST);\n    vec2 TexDy = dFdy(texST);\n    vec2 STll = texST;\n    vec2 STlr = texST + TexDx;\n    vec2 STul = texST + TexDy;\n    float Hll = texture2D(map, STll).x;\n    float Hlr = texture2D(map, STlr).x;\n    float Hul = texture2D(map, STul).x;\n    float dBs = Hlr - Hll;\n    float dBt = Hul - Hll;\n    return vec2(dBs, dBt);\n}\n\n\n\n// Based on https://docs.unrealengine.com/latest/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf\n\nvec3 perturbNormal_2_5(vec3 surf_pos, vec3 surf_norm, vec2 dHdxy) {\n  // Calling derivatives per-component to address android bug:\n  // http://stackoverflow.com/questions/20272272/\n  vec3 vSigmaX = vec3(dFdx(surf_pos.x), dFdx(surf_pos.y), dFdx(surf_pos.z));\n  vec3 vSigmaY = vec3(dFdy(surf_pos.x), dFdy(surf_pos.y), dFdy(surf_pos.z));\n  vec3 vN = vec3(normalize(surf_norm)); // normalized\n  vec3 R1 = cross(vSigmaY, vN);\n  vec3 R2 = cross(vN, vSigmaX);\n\n  float fDet = dot(vSigmaX, R1);\n  vec3 vGrad = sign(fDet) * (dHdxy.x * R1 + dHdxy.y * R2);\n  return normalize(abs(fDet) * surf_norm - vGrad);\n}\n\n\n\n// Based on https://github.com/vorg/pragmatic-pbr/blob/master/local_modules/glsl-tonemap-uncharted2/index.glsl\nfloat A_3_6 = 0.15;\nfloat B_3_7 = 0.50;\nfloat C_3_8 = 0.10;\nfloat D_3_9 = 0.20;\nfloat E_3_10 = 0.02;\nfloat F_3_11 = 0.30;\nfloat W_3_12 = 11.2;\n\nvec3 Uncharted2Tonemap_3_13(vec3 x) {\n   return ((x * (A_3_6 * x + C_3_8 * B_3_7) + D_3_9 * E_3_10) / (x * (A_3_6 * x + B_3_7) + D_3_9 * F_3_11)) - E_3_10 / F_3_11;\n}\n\n// Based on Filmic Tonemapping Operators http://filmicgames.com/archives/75\nvec3 tonemap_3_14(vec3 color) {\n    float ExposureBias = 2.0;\n    vec3 curr = Uncharted2Tonemap_3_13(ExposureBias * color);\n\n    vec3 whiteScale = 1.0 / Uncharted2Tonemap_3_13(vec3(W_3_12));\n    return curr * whiteScale;\n}\n\n\n\n// Set camera exposure based on angle between sun and eye\n\nfloat exposure_4_15(vec3 eye, vec3 L) {\n  return mix(\n    1.5,\n    300.0,\n    pow((1.0 - dot(normalize(eye), L)) / 2.0, 10.0)\n  );\n}\n\n\n\n// Scale bump map effect to produce relatively even relief\n// shading across surface. Goal is to avoid too much shading\n// at glancing angles and too little shading in the center.\n//\n// Also, invert bumps for oceans since the ocean height map\n// is inverted and allow for an additional bump scale factor with\n// `oceanFactor`. This allows ocean floor rendering to show\n// full bumps vs ocean surface rendering being flat.\n\nfloat terrainBumpScale_5_16(\n  float landness,\n  float oceanFactor,\n  float vNdotL,\n  float vNdotV,\n  vec3 vEye,\n  vec3 vPosition\n) {\n  float shadowStart = 0.25;\n  float bumpFalloff = clamp(vNdotL / shadowStart, 0.0, 0.5);\n\n  float bumpScale = mix(\n    0.005,\n    0.05,\n    vNdotL * vNdotL * vNdotV\n  ) * bumpFalloff;\n\n  if (landness < 0.5) {\n    bumpScale *= -oceanFactor;\n  }\n\n  return bumpScale;\n}\n\n\n\nvec3 atmosphere_6_17(float NdotL, float NdotV, vec3 color) {\n  return (\n    max(pow(NdotL, 2.0), 0.0) *\n    pow(1.0 - NdotV, 12.0)\n  ) * color;\n}\n\n\n\nvec3 nightAmbient_7_18(\n  float NdotL,\n  vec3 diffuseColor,\n  sampler2D lightsMap,\n  vec2 vUv\n) {\n  return 0.01 * (\n    texture2D(lightsMap, vUv).r * vec3(0.8, 0.8, 0.5) +\n    0.3 * vec3(0.1, 0.1, 1.0) * diffuseColor\n  ) * clamp((-NdotL + 0.01) * 2.0, 0.0, 1.0);\n}\n\n\n\n/*\nModified from https://github.com/wdas/brdf/blob/master/src/brdfs/disney.brdf\n\nOriginal license notice:\n# Copyright Disney Enterprises, Inc.  All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the "License");\n# you may not use this file except in compliance with the License\n# and the following modification to it: Section 6 Trademarks.\n# deleted and replaced with:\n#\n# 6. Trademarks. This License does not grant permission to use the\n# trade names, trademarks, service marks, or product names of the\n# Licensor and its affiliates, except as required for reproducing\n# the content of the NOTICE file.\n#\n# You may obtain a copy of the License at\n# http://www.apache.org/licenses/LICENSE-2.0\n*/\n\nfloat specularTint_8_19 = 0.0;\nfloat anisotropic_8_20 = 0.0;\nfloat sheen_8_21 = 0.0;\nfloat sheenTint_8_22 = 0.5;\nfloat clearcoat_8_23 = 0.0;\nfloat clearcoatGloss_8_24 = 1.0;\n\nconst float PI_8_25 = 3.14159265358979323846;\n\nfloat sqr_8_26(float x) { return x*x; }\n\nfloat SchlickFresnel_8_27(float u) {\n  float m = clamp(1.0 - u, 0.0, 1.0);\n  float m2 = m * m;\n  return m2 * m2 * m; // pow(m, 5)\n}\n\nfloat GTR1_8_28(float NdotH, float a) {\n  if (a >= 1.0) return 1.0 / PI_8_25;\n  float a2 = a * a;\n  float t = 1.0 + (a2 - 1.0) * NdotH * NdotH;\n  return (a2 - 1.0) / (PI_8_25 * log(a2) * t);\n}\n\nfloat GTR2_8_29(float NdotH, float a) {\n  float a2 = a * a;\n  float t = 1.0 + (a2 - 1.0) * NdotH * NdotH;\n  return a2 / (PI_8_25 * t * t);\n}\n\nfloat GTR2_aniso_8_30(float NdotH, float HdotX, float HdotY, float ax, float ay) {\n  return 1.0 / (\n    PI_8_25 * ax * ay *\n    sqr_8_26(sqr_8_26(HdotX / ax) + sqr_8_26(HdotY / ay) + NdotH * NdotH)\n  );\n}\n\nfloat smithG_GGX_8_31(float Ndotv, float alphaG) {\n  float a = alphaG * alphaG;\n  float b = Ndotv * Ndotv;\n  return 1.0 / (Ndotv + sqrt(a + b - a * b));\n}\n\nvec3 mon2lin_8_32(vec3 x) {\n  return vec3(pow(x[0], 2.2), pow(x[1], 2.2), pow(x[2], 2.2));\n}\n\nvec3 brdf_8_33(\n  vec3 baseColor,\n  float metallic,\n  float subsurface,\n  float specular,\n  float roughness,\n  vec3 L, vec3 V, vec3 N\n) {\n  float NdotL = dot(N, L);\n  float NdotV = dot(N, V);\n\n  vec3 H = normalize(L + V);\n  float NdotH = dot(N, H);\n  float LdotH = dot(L, H);\n\n  vec3 Cdlin = mon2lin_8_32(baseColor);\n  float Cdlum = 0.3 * Cdlin[0] + 0.6 * Cdlin[1]  + 0.1 * Cdlin[2]; // luminance approx.\n\n  vec3 Ctint = Cdlum > 0.0 ? Cdlin / Cdlum : vec3(1.0); // normalize lum. to isolate hue+sat\n  vec3 Cspec0 = mix(specular * .08 * mix(vec3(1.0), Ctint, specularTint_8_19), Cdlin, metallic);\n  vec3 Csheen = mix(vec3(1.0), Ctint, sheenTint_8_22);\n\n  // Diffuse fresnel - go from 1 at normal incidence to .5 at grazing\n  // and mix in diffuse retro-reflection based on roughness\n  float FL = SchlickFresnel_8_27(NdotL), FV = SchlickFresnel_8_27(NdotV);\n  float Fd90 = 0.5 + 2.0 * LdotH * LdotH * roughness;\n  float Fd = mix(1.0, Fd90, FL) * mix(1.0, Fd90, FV);\n\n  // Based on Hanrahan-Krueger brdf approximation of isotropic bssrdf\n  // 1.25 scale is used to (roughly) preserve albedo\n  // Fss90 used to "flatten" retroreflection based on roughness\n  float Fss90 = LdotH * LdotH * roughness;\n  float Fss = mix(1.0, Fss90, FL) * mix(1.0, Fss90, FV);\n  float ss = 1.25 * (Fss * (1.0 / (NdotL + NdotV) - 0.5) + 0.5);\n\n  // specular\n  float Ds = GTR2_8_29(NdotH, max(0.001, sqr_8_26(roughness)));\n  float FH = SchlickFresnel_8_27(LdotH);\n  vec3 Fs = mix(Cspec0, vec3(1.0), FH);\n  float roughg = sqr_8_26(roughness * 0.5 + 0.5);\n  float Gs = smithG_GGX_8_31(NdotL, roughg) * smithG_GGX_8_31(NdotV, roughg);\n\n  // sheen\n  vec3 Fsheen = FH * sheen_8_21 * Csheen;\n\n  // clearcoat (ior = 1.5 -> F0 = 0.04)\n  float Dr = GTR1_8_28(NdotH, mix(0.1, 0.001, clearcoatGloss_8_24));\n  float Fr = mix(0.04, 1.0, FH);\n  float Gr = smithG_GGX_8_31(NdotL, 0.25) * smithG_GGX_8_31(NdotV, 0.25);\n\n  return ((1.0/PI_8_25) * mix(Fd, ss, subsurface) * Cdlin + Fsheen)\n    * (1.0 - metallic) +\n    Gs * Fs * Ds +\n    0.25 * clearcoat_8_23 * Gr * Fr * Dr;\n}\n\n\n\n\nuniform sampler2D topographyMap;\nuniform sampler2D diffuseMap;\nuniform sampler2D landmaskMap;\nuniform sampler2D lightsMap;\nuniform vec3 lightDirection;\nuniform vec3 eye;\n\nvarying vec2 vUv;\nvarying vec3 vPosition;\nvarying vec3 vNormal;\n\nvoid main() {\n  vec3 V = normalize(eye - vPosition);\n  float vNdotL = dot(vNormal, lightDirection);\n  float vNdotL_clamped = clamp(vNdotL, 0.0, 1.0);\n  float vNdotV = dot(vNormal, V);\n  float vNdotV_clamped = clamp(vNdotV, 0.0, 1.0);\n\n  vec3 infoSample = texture2D(landmaskMap, vUv, -0.5).rgb;\n  float landness = infoSample.r;\n  float countryBorder = infoSample.b;\n\n  float oceanDepth = (0.5 - texture2D(topographyMap, vUv).r) * 2.0;\n\n  vec2 dHdxy = heightDerivative_1_4(vUv, topographyMap) *\n    terrainBumpScale_5_16(landness, 0.0, vNdotL, vNdotV, eye, vPosition);\n\n  vec3 oceanColor = mix(\n    vec3(0.0, 0.0, 0.35),\n    vec3(0.0, 0.0, 0.3),\n    oceanDepth\n  );\n\n  vec3 diffuseColor = mix(\n    oceanColor,\n    toLinear_9_1(texture2D(diffuseMap, vUv).rgb),\n    landness\n  );\n\n\n  vec3 N = perturbNormal_2_5(normalize(vPosition), vNormal, dHdxy);\n  vec3 L = normalize(lightDirection);\n  vec3 H = normalize(L + V);\n\n  float roughness = mix(\n    mix(0.6, 0.8, oceanDepth),\n    (1.0 - diffuseColor.r * 0.5),\n    smoothstep(0.25, 0.75, landness)\n  );\n\n  vec3 color = nightAmbient_7_18(vNdotL, diffuseColor, lightsMap, vUv);\n  if (dot(vNormal, L) > 0.0) {\n    vec3 lightColor = vec3(8.0);\n\n    float incidence = pow(dot(N, L), 1.5);\n\n    color = lightColor * incidence * brdf_8_33(\n      diffuseColor,\n      0.0, //metallic\n      0.5, //subsurface\n      0.3, //specular\n      roughness, //roughness\n      L, V, N\n    );\n\n    color += atmosphere_6_17(\n      vNdotL_clamped,\n      vNdotV_clamped,\n      vec3(0.1, 0.1, 1.0) * 20.0\n    );\n  }\n\n  vec3 shaded = toGamma_10_3(tonemap_3_14(color * exposure_4_15(eye, L)));\n  vec3 final = mix(shaded, vec3(1.0), countryBorder);\n  gl_FragColor = vec4(final, 1.0);\n}\n'}),require.register("shaders/elevation.frag.glsl",function(n,e,t){t.exports='#extension GL_OES_standard_derivatives : enable\nprecision highp float;\n#define GLSLIFY 1\n\nconst float gamma_9_0 = 2.2;\n\nfloat toLinear_9_1(float v) {\n  return pow(v, gamma_9_0);\n}\n\nvec2 toLinear_9_1(vec2 v) {\n  return pow(v, vec2(gamma_9_0));\n}\n\nvec3 toLinear_9_1(vec3 v) {\n  return pow(v, vec3(gamma_9_0));\n}\n\nvec4 toLinear_9_1(vec4 v) {\n  return vec4(toLinear_9_1(v.rgb), v.a);\n}\n\n\n\nconst float gamma_10_2 = 2.2;\n\nfloat toGamma_10_3(float v) {\n  return pow(v, 1.0 / gamma_10_2);\n}\n\nvec2 toGamma_10_3(vec2 v) {\n  return pow(v, vec2(1.0 / gamma_10_2));\n}\n\nvec3 toGamma_10_3(vec3 v) {\n  return pow(v, vec3(1.0 / gamma_10_2));\n}\n\nvec4 toGamma_10_3(vec4 v) {\n  return vec4(toGamma_10_3(v.rgb), v.a);\n}\n\n\n\n// Based on https://docs.unrealengine.com/latest/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf\n\nvec2 heightDerivative_1_4(vec2 texST, sampler2D map) {\n    vec2 TexDx = dFdx(texST);\n    vec2 TexDy = dFdy(texST);\n    vec2 STll = texST;\n    vec2 STlr = texST + TexDx;\n    vec2 STul = texST + TexDy;\n    float Hll = texture2D(map, STll).x;\n    float Hlr = texture2D(map, STlr).x;\n    float Hul = texture2D(map, STul).x;\n    float dBs = Hlr - Hll;\n    float dBt = Hul - Hll;\n    return vec2(dBs, dBt);\n}\n\n\n\n// Based on https://docs.unrealengine.com/latest/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf\n\nvec3 perturbNormal_2_5(vec3 surf_pos, vec3 surf_norm, vec2 dHdxy) {\n  // Calling derivatives per-component to address android bug:\n  // http://stackoverflow.com/questions/20272272/\n  vec3 vSigmaX = vec3(dFdx(surf_pos.x), dFdx(surf_pos.y), dFdx(surf_pos.z));\n  vec3 vSigmaY = vec3(dFdy(surf_pos.x), dFdy(surf_pos.y), dFdy(surf_pos.z));\n  vec3 vN = vec3(normalize(surf_norm)); // normalized\n  vec3 R1 = cross(vSigmaY, vN);\n  vec3 R2 = cross(vN, vSigmaX);\n\n  float fDet = dot(vSigmaX, R1);\n  vec3 vGrad = sign(fDet) * (dHdxy.x * R1 + dHdxy.y * R2);\n  return normalize(abs(fDet) * surf_norm - vGrad);\n}\n\n\n\n// Based on https://github.com/vorg/pragmatic-pbr/blob/master/local_modules/glsl-tonemap-uncharted2/index.glsl\nfloat A_3_6 = 0.15;\nfloat B_3_7 = 0.50;\nfloat C_3_8 = 0.10;\nfloat D_3_9 = 0.20;\nfloat E_3_10 = 0.02;\nfloat F_3_11 = 0.30;\nfloat W_3_12 = 11.2;\n\nvec3 Uncharted2Tonemap_3_13(vec3 x) {\n   return ((x * (A_3_6 * x + C_3_8 * B_3_7) + D_3_9 * E_3_10) / (x * (A_3_6 * x + B_3_7) + D_3_9 * F_3_11)) - E_3_10 / F_3_11;\n}\n\n// Based on Filmic Tonemapping Operators http://filmicgames.com/archives/75\nvec3 tonemap_3_14(vec3 color) {\n    float ExposureBias = 2.0;\n    vec3 curr = Uncharted2Tonemap_3_13(ExposureBias * color);\n\n    vec3 whiteScale = 1.0 / Uncharted2Tonemap_3_13(vec3(W_3_12));\n    return curr * whiteScale;\n}\n\n\n\n// Set camera exposure based on angle between sun and eye\n\nfloat exposure_4_15(vec3 eye, vec3 L) {\n  return mix(\n    1.5,\n    300.0,\n    pow((1.0 - dot(normalize(eye), L)) / 2.0, 10.0)\n  );\n}\n\n\n\n// Scale bump map effect to produce relatively even relief\n// shading across surface. Goal is to avoid too much shading\n// at glancing angles and too little shading in the center.\n//\n// Also, invert bumps for oceans since the ocean height map\n// is inverted and allow for an additional bump scale factor with\n// `oceanFactor`. This allows ocean floor rendering to show\n// full bumps vs ocean surface rendering being flat.\n\nfloat terrainBumpScale_5_16(\n  float landness,\n  float oceanFactor,\n  float vNdotL,\n  float vNdotV,\n  vec3 vEye,\n  vec3 vPosition\n) {\n  float shadowStart = 0.25;\n  float bumpFalloff = clamp(vNdotL / shadowStart, 0.0, 0.5);\n\n  float bumpScale = mix(\n    0.005,\n    0.05,\n    vNdotL * vNdotL * vNdotV\n  ) * bumpFalloff;\n\n  if (landness < 0.5) {\n    bumpScale *= -oceanFactor;\n  }\n\n  return bumpScale;\n}\n\n\n\nvec3 atmosphere_6_17(float NdotL, float NdotV, vec3 color) {\n  return (\n    max(pow(NdotL, 2.0), 0.0) *\n    pow(1.0 - NdotV, 12.0)\n  ) * color;\n}\n\n\n\nvec3 nightAmbient_7_18(\n  float NdotL,\n  vec3 diffuseColor,\n  sampler2D lightsMap,\n  vec2 vUv\n) {\n  return 0.01 * (\n    texture2D(lightsMap, vUv).r * vec3(0.8, 0.8, 0.5) +\n    0.3 * vec3(0.1, 0.1, 1.0) * diffuseColor\n  ) * clamp((-NdotL + 0.01) * 2.0, 0.0, 1.0);\n}\n\n\n\n/*\nModified from https://github.com/wdas/brdf/blob/master/src/brdfs/disney.brdf\n\nOriginal license notice:\n# Copyright Disney Enterprises, Inc.  All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the "License");\n# you may not use this file except in compliance with the License\n# and the following modification to it: Section 6 Trademarks.\n# deleted and replaced with:\n#\n# 6. Trademarks. This License does not grant permission to use the\n# trade names, trademarks, service marks, or product names of the\n# Licensor and its affiliates, except as required for reproducing\n# the content of the NOTICE file.\n#\n# You may obtain a copy of the License at\n# http://www.apache.org/licenses/LICENSE-2.0\n*/\n\nfloat specularTint_8_19 = 0.0;\nfloat anisotropic_8_20 = 0.0;\nfloat sheen_8_21 = 0.0;\nfloat sheenTint_8_22 = 0.5;\nfloat clearcoat_8_23 = 0.0;\nfloat clearcoatGloss_8_24 = 1.0;\n\nconst float PI_8_25 = 3.14159265358979323846;\n\nfloat sqr_8_26(float x) { return x*x; }\n\nfloat SchlickFresnel_8_27(float u) {\n  float m = clamp(1.0 - u, 0.0, 1.0);\n  float m2 = m * m;\n  return m2 * m2 * m; // pow(m, 5)\n}\n\nfloat GTR1_8_28(float NdotH, float a) {\n  if (a >= 1.0) return 1.0 / PI_8_25;\n  float a2 = a * a;\n  float t = 1.0 + (a2 - 1.0) * NdotH * NdotH;\n  return (a2 - 1.0) / (PI_8_25 * log(a2) * t);\n}\n\nfloat GTR2_8_29(float NdotH, float a) {\n  float a2 = a * a;\n  float t = 1.0 + (a2 - 1.0) * NdotH * NdotH;\n  return a2 / (PI_8_25 * t * t);\n}\n\nfloat GTR2_aniso_8_30(float NdotH, float HdotX, float HdotY, float ax, float ay) {\n  return 1.0 / (\n    PI_8_25 * ax * ay *\n    sqr_8_26(sqr_8_26(HdotX / ax) + sqr_8_26(HdotY / ay) + NdotH * NdotH)\n  );\n}\n\nfloat smithG_GGX_8_31(float Ndotv, float alphaG) {\n  float a = alphaG * alphaG;\n  float b = Ndotv * Ndotv;\n  return 1.0 / (Ndotv + sqrt(a + b - a * b));\n}\n\nvec3 mon2lin_8_32(vec3 x) {\n  return vec3(pow(x[0], 2.2), pow(x[1], 2.2), pow(x[2], 2.2));\n}\n\nvec3 brdf_8_33(\n  vec3 baseColor,\n  float metallic,\n  float subsurface,\n  float specular,\n  float roughness,\n  vec3 L, vec3 V, vec3 N\n) {\n  float NdotL = dot(N, L);\n  float NdotV = dot(N, V);\n\n  vec3 H = normalize(L + V);\n  float NdotH = dot(N, H);\n  float LdotH = dot(L, H);\n\n  vec3 Cdlin = mon2lin_8_32(baseColor);\n  float Cdlum = 0.3 * Cdlin[0] + 0.6 * Cdlin[1]  + 0.1 * Cdlin[2]; // luminance approx.\n\n  vec3 Ctint = Cdlum > 0.0 ? Cdlin / Cdlum : vec3(1.0); // normalize lum. to isolate hue+sat\n  vec3 Cspec0 = mix(specular * .08 * mix(vec3(1.0), Ctint, specularTint_8_19), Cdlin, metallic);\n  vec3 Csheen = mix(vec3(1.0), Ctint, sheenTint_8_22);\n\n  // Diffuse fresnel - go from 1 at normal incidence to .5 at grazing\n  // and mix in diffuse retro-reflection based on roughness\n  float FL = SchlickFresnel_8_27(NdotL), FV = SchlickFresnel_8_27(NdotV);\n  float Fd90 = 0.5 + 2.0 * LdotH * LdotH * roughness;\n  float Fd = mix(1.0, Fd90, FL) * mix(1.0, Fd90, FV);\n\n  // Based on Hanrahan-Krueger brdf approximation of isotropic bssrdf\n  // 1.25 scale is used to (roughly) preserve albedo\n  // Fss90 used to "flatten" retroreflection based on roughness\n  float Fss90 = LdotH * LdotH * roughness;\n  float Fss = mix(1.0, Fss90, FL) * mix(1.0, Fss90, FV);\n  float ss = 1.25 * (Fss * (1.0 / (NdotL + NdotV) - 0.5) + 0.5);\n\n  // specular\n  float Ds = GTR2_8_29(NdotH, max(0.001, sqr_8_26(roughness)));\n  float FH = SchlickFresnel_8_27(LdotH);\n  vec3 Fs = mix(Cspec0, vec3(1.0), FH);\n  float roughg = sqr_8_26(roughness * 0.5 + 0.5);\n  float Gs = smithG_GGX_8_31(NdotL, roughg) * smithG_GGX_8_31(NdotV, roughg);\n\n  // sheen\n  vec3 Fsheen = FH * sheen_8_21 * Csheen;\n\n  // clearcoat (ior = 1.5 -> F0 = 0.04)\n  float Dr = GTR1_8_28(NdotH, mix(0.1, 0.001, clearcoatGloss_8_24));\n  float Fr = mix(0.04, 1.0, FH);\n  float Gr = smithG_GGX_8_31(NdotL, 0.25) * smithG_GGX_8_31(NdotV, 0.25);\n\n  return ((1.0/PI_8_25) * mix(Fd, ss, subsurface) * Cdlin + Fsheen)\n    * (1.0 - metallic) +\n    Gs * Fs * Ds +\n    0.25 * clearcoat_8_23 * Gr * Fr * Dr;\n}\n\n\n\n\nuniform sampler2D topographyMap;\nuniform sampler2D diffuseMap;\nuniform sampler2D landmaskMap;\nuniform sampler2D lightsMap;\nuniform vec3 lightDirection;\nuniform vec3 eye;\n\nvarying vec2 vUv;\nvarying vec3 vPosition;\nvarying vec3 vNormal;\n\nvoid main() {\n  vec3 constantLight = vNormal;\n  vec3 V = vNormal;\n\n  vec3 infoSample = texture2D(landmaskMap, vUv, -0.5).rgb;\n  float landness = infoSample.r;\n  float countryBorder = infoSample.b;\n\n  float elevation = texture2D(topographyMap, vUv).r;\n\n  float steps = 16.0;\n  vec3 diffuseColor = vec3(1.0, 0.75, 0.5) *\n    floor((elevation / 0.9) * steps) / steps;\n\n  if (landness < 0.5) {\n    diffuseColor =vec3(0.25, 0.5, 1.0) *\n    floor((elevation / 0.9) * steps) / steps;\n  }\n\n  // Outline the transition from land to sea\n  diffuseColor = mix(\n    diffuseColor,\n    vec3(0.0, 0.0, 0.5),\n    pow(1.0 - abs(landness - 0.5) * 2.0, 1.0)\n  );\n\n  vec3 N = vNormal;\n  vec3 L = normalize(constantLight);\n  vec3 H = normalize(L + V);\n\n  vec3 color = vec3(0.0);\n  if (dot(vNormal, L) > 0.0) {\n    vec3 lightColor = vec3(20.0);\n\n    color = lightColor * brdf_8_33(\n      diffuseColor,\n      0.0, //metallic\n      0.5, //subsurface\n      0.3, //specular\n      0.99, //roughness\n      L, V, N\n    );\n\n    color += atmosphere_6_17(\n      dot(vNormal, L),\n      dot(vNormal, normalize(eye - vPosition)),\n      vec3(5.0)\n    );\n  }\n\n  vec3 shaded = toGamma_10_3(tonemap_3_14(color * 0.5));\n  vec3 final = mix(shaded, vec3(1.0), countryBorder);\n  gl_FragColor = vec4(final, 1.0);\n}\n'}),require.register("shaders/functions/atmosphere.glsl",function(n,e,t){t.exports="#define GLSLIFY 1\nvec3 atmosphere(float NdotL, float NdotV, vec3 color) {\n  return (\n    max(pow(NdotL, 2.0), 0.0) *\n    pow(1.0 - NdotV, 12.0)\n  ) * color;\n}\n\n\n"}),require.register("shaders/functions/brdf.glsl",function(n,e,t){t.exports='#define GLSLIFY 1\n/*\nModified from https://github.com/wdas/brdf/blob/master/src/brdfs/disney.brdf\n\nOriginal license notice:\n# Copyright Disney Enterprises, Inc.  All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the "License");\n# you may not use this file except in compliance with the License\n# and the following modification to it: Section 6 Trademarks.\n# deleted and replaced with:\n#\n# 6. Trademarks. This License does not grant permission to use the\n# trade names, trademarks, service marks, or product names of the\n# Licensor and its affiliates, except as required for reproducing\n# the content of the NOTICE file.\n#\n# You may obtain a copy of the License at\n# http://www.apache.org/licenses/LICENSE-2.0\n*/\n\nfloat specularTint = 0.0;\nfloat anisotropic = 0.0;\nfloat sheen = 0.0;\nfloat sheenTint = 0.5;\nfloat clearcoat = 0.0;\nfloat clearcoatGloss = 1.0;\n\nconst float PI = 3.14159265358979323846;\n\nfloat sqr(float x) { return x*x; }\n\nfloat SchlickFresnel(float u) {\n  float m = clamp(1.0 - u, 0.0, 1.0);\n  float m2 = m * m;\n  return m2 * m2 * m; // pow(m, 5)\n}\n\nfloat GTR1(float NdotH, float a) {\n  if (a >= 1.0) return 1.0 / PI;\n  float a2 = a * a;\n  float t = 1.0 + (a2 - 1.0) * NdotH * NdotH;\n  return (a2 - 1.0) / (PI * log(a2) * t);\n}\n\nfloat GTR2(float NdotH, float a) {\n  float a2 = a * a;\n  float t = 1.0 + (a2 - 1.0) * NdotH * NdotH;\n  return a2 / (PI * t * t);\n}\n\nfloat GTR2_aniso(float NdotH, float HdotX, float HdotY, float ax, float ay) {\n  return 1.0 / (\n    PI * ax * ay *\n    sqr(sqr(HdotX / ax) + sqr(HdotY / ay) + NdotH * NdotH)\n  );\n}\n\nfloat smithG_GGX(float Ndotv, float alphaG) {\n  float a = alphaG * alphaG;\n  float b = Ndotv * Ndotv;\n  return 1.0 / (Ndotv + sqrt(a + b - a * b));\n}\n\nvec3 mon2lin(vec3 x) {\n  return vec3(pow(x[0], 2.2), pow(x[1], 2.2), pow(x[2], 2.2));\n}\n\nvec3 brdf(\n  vec3 baseColor,\n  float metallic,\n  float subsurface,\n  float specular,\n  float roughness,\n  vec3 L, vec3 V, vec3 N\n) {\n  float NdotL = dot(N, L);\n  float NdotV = dot(N, V);\n\n  vec3 H = normalize(L + V);\n  float NdotH = dot(N, H);\n  float LdotH = dot(L, H);\n\n  vec3 Cdlin = mon2lin(baseColor);\n  float Cdlum = 0.3 * Cdlin[0] + 0.6 * Cdlin[1]  + 0.1 * Cdlin[2]; // luminance approx.\n\n  vec3 Ctint = Cdlum > 0.0 ? Cdlin / Cdlum : vec3(1.0); // normalize lum. to isolate hue+sat\n  vec3 Cspec0 = mix(specular * .08 * mix(vec3(1.0), Ctint, specularTint), Cdlin, metallic);\n  vec3 Csheen = mix(vec3(1.0), Ctint, sheenTint);\n\n  // Diffuse fresnel - go from 1 at normal incidence to .5 at grazing\n  // and mix in diffuse retro-reflection based on roughness\n  float FL = SchlickFresnel(NdotL), FV = SchlickFresnel(NdotV);\n  float Fd90 = 0.5 + 2.0 * LdotH * LdotH * roughness;\n  float Fd = mix(1.0, Fd90, FL) * mix(1.0, Fd90, FV);\n\n  // Based on Hanrahan-Krueger brdf approximation of isotropic bssrdf\n  // 1.25 scale is used to (roughly) preserve albedo\n  // Fss90 used to "flatten" retroreflection based on roughness\n  float Fss90 = LdotH * LdotH * roughness;\n  float Fss = mix(1.0, Fss90, FL) * mix(1.0, Fss90, FV);\n  float ss = 1.25 * (Fss * (1.0 / (NdotL + NdotV) - 0.5) + 0.5);\n\n  // specular\n  float Ds = GTR2(NdotH, max(0.001, sqr(roughness)));\n  float FH = SchlickFresnel(LdotH);\n  vec3 Fs = mix(Cspec0, vec3(1.0), FH);\n  float roughg = sqr(roughness * 0.5 + 0.5);\n  float Gs = smithG_GGX(NdotL, roughg) * smithG_GGX(NdotV, roughg);\n\n  // sheen\n  vec3 Fsheen = FH * sheen * Csheen;\n\n  // clearcoat (ior = 1.5 -> F0 = 0.04)\n  float Dr = GTR1(NdotH, mix(0.1, 0.001, clearcoatGloss));\n  float Fr = mix(0.04, 1.0, FH);\n  float Gr = smithG_GGX(NdotL, 0.25) * smithG_GGX(NdotV, 0.25);\n\n  return ((1.0/PI) * mix(Fd, ss, subsurface) * Cdlin + Fsheen)\n    * (1.0 - metallic) +\n    Gs * Fs * Ds +\n    0.25 * clearcoat * Gr * Fr * Dr;\n}\n\n\n'}),require.register("shaders/functions/exposure.glsl",function(n,e,t){t.exports="#define GLSLIFY 1\n// Set camera exposure based on angle between sun and eye\n\nfloat exposure(vec3 eye, vec3 L) {\n  return mix(\n    1.5,\n    300.0,\n    pow((1.0 - dot(normalize(eye), L)) / 2.0, 10.0)\n  );\n}\n\n\n"}),require.register("shaders/functions/heightDerivative.glsl",function(n,e,t){t.exports="#define GLSLIFY 1\n// Based on https://docs.unrealengine.com/latest/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf\n\nvec2 heightDerivative(vec2 texST, sampler2D map) {\n    vec2 TexDx = dFdx(texST);\n    vec2 TexDy = dFdy(texST);\n    vec2 STll = texST;\n    vec2 STlr = texST + TexDx;\n    vec2 STul = texST + TexDy;\n    float Hll = texture2D(map, STll).x;\n    float Hlr = texture2D(map, STlr).x;\n    float Hul = texture2D(map, STul).x;\n    float dBs = Hlr - Hll;\n    float dBt = Hul - Hll;\n    return vec2(dBs, dBt);\n}\n\n\n"}),require.register("shaders/functions/isNan.glsl",function(n,e,t){t.exports="#define GLSLIFY 1\n// Hack isNan for debugging since WebGL doesn't define it\n\nbool isNan(float val) {\n  return (val <= 0.0 || 0.0 <= val) ? false : true;\n}\n\n\n"}),require.register("shaders/functions/nightAmbient.glsl",function(n,e,t){t.exports="#define GLSLIFY 1\nvec3 nightAmbient(\n  float NdotL,\n  vec3 diffuseColor,\n  sampler2D lightsMap,\n  vec2 vUv\n) {\n  return 0.01 * (\n    texture2D(lightsMap, vUv).r * vec3(0.8, 0.8, 0.5) +\n    0.3 * vec3(0.1, 0.1, 1.0) * diffuseColor\n  ) * clamp((-NdotL + 0.01) * 2.0, 0.0, 1.0);\n}\n\n\n"}),require.register("shaders/functions/perturbNormal.glsl",function(n,e,t){t.exports="#define GLSLIFY 1\n// Based on https://docs.unrealengine.com/latest/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf\n\nvec3 perturbNormal(vec3 surf_pos, vec3 surf_norm, vec2 dHdxy) {\n  // Calling derivatives per-component to address android bug:\n  // http://stackoverflow.com/questions/20272272/\n  vec3 vSigmaX = vec3(dFdx(surf_pos.x), dFdx(surf_pos.y), dFdx(surf_pos.z));\n  vec3 vSigmaY = vec3(dFdy(surf_pos.x), dFdy(surf_pos.y), dFdy(surf_pos.z));\n  vec3 vN = vec3(normalize(surf_norm)); // normalized\n  vec3 R1 = cross(vSigmaY, vN);\n  vec3 R2 = cross(vN, vSigmaX);\n\n  float fDet = dot(vSigmaX, R1);\n  vec3 vGrad = sign(fDet) * (dHdxy.x * R1 + dHdxy.y * R2);\n  return normalize(abs(fDet) * surf_norm - vGrad);\n}\n\n\n"}),require.register("shaders/functions/terrainBumpScale.glsl",function(n,e,t){t.exports="#define GLSLIFY 1\n// Scale bump map effect to produce relatively even relief\n// shading across surface. Goal is to avoid too much shading\n// at glancing angles and too little shading in the center.\n//\n// Also, invert bumps for oceans since the ocean height map\n// is inverted and allow for an additional bump scale factor with\n// `oceanFactor`. This allows ocean floor rendering to show\n// full bumps vs ocean surface rendering being flat.\n\nfloat terrainBumpScale(\n  float landness,\n  float oceanFactor,\n  float vNdotL,\n  float vNdotV,\n  vec3 vEye,\n  vec3 vPosition\n) {\n  float shadowStart = 0.25;\n  float bumpFalloff = clamp(vNdotL / shadowStart, 0.0, 0.5);\n\n  float bumpScale = mix(\n    0.005,\n    0.05,\n    vNdotL * vNdotL * vNdotV\n  ) * bumpFalloff;\n\n  if (landness < 0.5) {\n    bumpScale *= -oceanFactor;\n  }\n\n  return bumpScale;\n}\n\n\n"}),require.register("shaders/functions/tonemap.glsl",function(n,e,t){t.exports="#define GLSLIFY 1\n// Based on https://github.com/vorg/pragmatic-pbr/blob/master/local_modules/glsl-tonemap-uncharted2/index.glsl\nfloat A = 0.15;\nfloat B = 0.50;\nfloat C = 0.10;\nfloat D = 0.20;\nfloat E = 0.02;\nfloat F = 0.30;\nfloat W = 11.2;\n\nvec3 Uncharted2Tonemap(vec3 x) {\n   return ((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - E / F;\n}\n\n// Based on Filmic Tonemapping Operators http://filmicgames.com/archives/75\nvec3 tonemap(vec3 color) {\n    float ExposureBias = 2.0;\n    vec3 curr = Uncharted2Tonemap(ExposureBias * color);\n\n    vec3 whiteScale = 1.0 / Uncharted2Tonemap(vec3(W));\n    return curr * whiteScale;\n}\n\n\n"}),require.register("shaders/globe.vert.glsl",function(n,e,t){t.exports="precision highp float;\n#define GLSLIFY 1\n\nfloat transpose_1_0(float m) {\n  return m;\n}\n\nmat2 transpose_1_0(mat2 m) {\n  return mat2(m[0][0], m[1][0],\n              m[0][1], m[1][1]);\n}\n\nmat3 transpose_1_0(mat3 m) {\n  return mat3(m[0][0], m[1][0], m[2][0],\n              m[0][1], m[1][1], m[2][1],\n              m[0][2], m[1][2], m[2][2]);\n}\n\nmat4 transpose_1_0(mat4 m) {\n  return mat4(m[0][0], m[1][0], m[2][0], m[3][0],\n              m[0][1], m[1][1], m[2][1], m[3][1],\n              m[0][2], m[1][2], m[2][2], m[3][2],\n              m[0][3], m[1][3], m[2][3], m[3][3]);\n}\n\n\nfloat inverse_2_1(float m) {\n  return 1.0 / m;\n}\n\nmat2 inverse_2_1(mat2 m) {\n  return mat2(m[1][1],-m[0][1],\n             -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\n\nmat3 inverse_2_1(mat3 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nmat4 inverse_2_1(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\n\n\nattribute vec3 position;\nattribute vec2 texcoord;\nattribute float elevation;\n\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 projection;\n\nuniform float oceanElevationScale;\nuniform float landElevationScale;\n\nvarying vec2 vUv;\nvarying vec3 vPosition;\nvarying vec3 vNormal;\n\nvoid main(void) {\n  mat4 modelView = view * model;\n\n  float PI = 3.14159265;\n\n  vUv = texcoord;\n\n  float scale = 1.0;\n  if (elevation > 0.0) {\n    scale += elevation * landElevationScale;\n  }\n  else {\n    scale += elevation * oceanElevationScale;\n  }\n\n  vec3 spherePosition = scale * position;\n\n  gl_Position = projection * modelView * vec4(spherePosition, 1.0);\n  vPosition = vec3(model * vec4(spherePosition, 1.0));\n\n  mat3 normalMatrix = transpose_1_0(inverse_2_1(mat3(model)));\n  vNormal = normalize(normalMatrix * spherePosition);\n}\n";
}),require.register("shaders/night.frag.glsl",function(n,e,t){t.exports="#extension GL_OES_standard_derivatives : enable\nprecision highp float;\n#define GLSLIFY 1\n\nconst float gamma_4_0 = 2.2;\n\nfloat toLinear_4_1(float v) {\n  return pow(v, gamma_4_0);\n}\n\nvec2 toLinear_4_1(vec2 v) {\n  return pow(v, vec2(gamma_4_0));\n}\n\nvec3 toLinear_4_1(vec3 v) {\n  return pow(v, vec3(gamma_4_0));\n}\n\nvec4 toLinear_4_1(vec4 v) {\n  return vec4(toLinear_4_1(v.rgb), v.a);\n}\n\n\n\nconst float gamma_5_2 = 2.2;\n\nfloat toGamma_5_3(float v) {\n  return pow(v, 1.0 / gamma_5_2);\n}\n\nvec2 toGamma_5_3(vec2 v) {\n  return pow(v, vec2(1.0 / gamma_5_2));\n}\n\nvec3 toGamma_5_3(vec3 v) {\n  return pow(v, vec3(1.0 / gamma_5_2));\n}\n\nvec4 toGamma_5_3(vec4 v) {\n  return vec4(toGamma_5_3(v.rgb), v.a);\n}\n\n\n\n// Based on https://github.com/vorg/pragmatic-pbr/blob/master/local_modules/glsl-tonemap-uncharted2/index.glsl\nfloat A_1_4 = 0.15;\nfloat B_1_5 = 0.50;\nfloat C_1_6 = 0.10;\nfloat D_1_7 = 0.20;\nfloat E_1_8 = 0.02;\nfloat F_1_9 = 0.30;\nfloat W_1_10 = 11.2;\n\nvec3 Uncharted2Tonemap_1_11(vec3 x) {\n   return ((x * (A_1_4 * x + C_1_6 * B_1_5) + D_1_7 * E_1_8) / (x * (A_1_4 * x + B_1_5) + D_1_7 * F_1_9)) - E_1_8 / F_1_9;\n}\n\n// Based on Filmic Tonemapping Operators http://filmicgames.com/archives/75\nvec3 tonemap_1_12(vec3 color) {\n    float ExposureBias = 2.0;\n    vec3 curr = Uncharted2Tonemap_1_11(ExposureBias * color);\n\n    vec3 whiteScale = 1.0 / Uncharted2Tonemap_1_11(vec3(W_1_10));\n    return curr * whiteScale;\n}\n\n\n\n// Set camera exposure based on angle between sun and eye\n\nfloat exposure_2_13(vec3 eye, vec3 L) {\n  return mix(\n    1.5,\n    300.0,\n    pow((1.0 - dot(normalize(eye), L)) / 2.0, 10.0)\n  );\n}\n\n\n\nvec3 nightAmbient_3_14(\n  float NdotL,\n  vec3 diffuseColor,\n  sampler2D lightsMap,\n  vec2 vUv\n) {\n  return 0.01 * (\n    texture2D(lightsMap, vUv).r * vec3(0.8, 0.8, 0.5) +\n    0.3 * vec3(0.1, 0.1, 1.0) * diffuseColor\n  ) * clamp((-NdotL + 0.01) * 2.0, 0.0, 1.0);\n}\n\n\n\n\nuniform sampler2D topographyMap;\nuniform sampler2D diffuseMap;\nuniform sampler2D landmaskMap;\nuniform sampler2D lightsMap;\nuniform vec3 eye;\n\nvarying vec2 vUv;\nvarying vec3 vPosition;\nvarying vec3 vNormal;\n\nvoid main() {\n  vec3 infoSample = texture2D(landmaskMap, vUv, -0.5).rgb;\n  float landness = infoSample.r;\n  float countryBorder = infoSample.b;\n\n  float oceanDepth = (0.5 - texture2D(topographyMap, vUv).r) * 2.0;\n\n  vec3 oceanColor = mix(\n    vec3(0.0, 0.0, 0.3),\n    vec3(0.0, 0.0, 0.35),\n    oceanDepth\n  );\n\n  vec3 diffuseColor = mix(\n    oceanColor,\n    toLinear_4_1(texture2D(diffuseMap, vUv).rgb),\n    landness\n  );\n\n  vec3 color = nightAmbient_3_14(-1.0, diffuseColor, lightsMap, vUv);\n\n  vec3 shaded = toGamma_5_3(tonemap_1_12(color * 150.0));\n  vec3 final = mix(shaded, vec3(1.0), countryBorder);\n  gl_FragColor = vec4(final, 1.0);\n}\n"}),require.alias("buffer/index.js","buffer"),require.alias("process/browser.js","process"),n=require("process"),require.register("___globals___",function(n,e,t){})}(),require("___globals___");