!function(){"use strict";var n="undefined"==typeof window?global:window;if("function"!=typeof n.require){var e={},t={},a={},o={}.hasOwnProperty,r=/^\.\.?(\/|$)/,i=function(n,e){for(var t,a=[],o=(r.test(e)?n+"/"+e:e).split("/"),i=0,s=o.length;i<s;i++)t=o[i],".."===t?a.pop():"."!==t&&""!==t&&a.push(t);return a.join("/")},s=function(n){return n.split("/").slice(0,-1).join("/")},l=function(e){return function(t){var a=i(s(e),t);return n.require(a,e)}},c=function(n,e){var a=null;a=h&&h.createHot(n);var o={id:n,exports:{},hot:a};return t[n]=o,e(o.exports,l(n),o),o.exports},u=function(n){return a[n]?u(a[n]):n},d=function(n,e){return u(i(s(n),e))},f=function(n,a){null==a&&(a="/");var r=u(n);if(o.call(t,r))return t[r].exports;if(o.call(e,r))return c(r,e[r]);throw new Error("Cannot find module '"+n+"' from '"+a+"'")};f.alias=function(n,e){a[e]=n};var v=/\.[^.\/]+$/,m=/\/index(\.[^\/]+)?$/,_=function(n){if(v.test(n)){var e=n.replace(v,"");o.call(a,e)&&a[e].replace(v,"")!==e+"/index"||(a[e]=n)}if(m.test(n)){var t=n.replace(m,"");o.call(a,t)||(a[t]=n)}};f.register=f.define=function(n,a){if("object"==typeof n)for(var r in n)o.call(n,r)&&f.register(r,n[r]);else e[n]=a,delete t[n],_(n)},f.list=function(){var n=[];for(var t in e)o.call(e,t)&&n.push(t);return n};var h=n._hmr&&new n._hmr(d,f,e,t);f._cache=t,f.hmr=h&&h.wrap,f.brunch=!0,n.require=f}}(),function(){var n;window;require.register("initialize.js",function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{"default":n}}function o(n){if(n&&n.__esModule)return n;var e={};if(null!=n)for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(e[t]=n[t]);return e["default"]=n,e}var r=e("d3"),i=o(r),s=e("twgl.js"),l=a(s),c=e("js/controller"),u=a(c);document.addEventListener("DOMContentLoaded",function(){var n=l["default"].getWebGLContext(document.querySelector(".map-canvas canvas"));i.json("data/vectors.json",function(e,t){new u["default"](n,t)})})}),require.register("js/bordersLayer.js",function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{"default":n}}function o(n){if(n&&n.__esModule)return n;var e={};if(null!=n)for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(e[t]=n[t]);return e["default"]=n,e}function r(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(n,"__esModule",{value:!0});var i=function(){function n(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}return function(e,t,a){return t&&n(e.prototype,t),a&&n(e,a),e}}(),s=e("d3"),l=(o(s),e("topojson")),c=o(l),u=e("lodash"),d=(a(u),e("./utils")),f=function(){function n(e,t,a){r(this,n),this.options={countries:{enabled:!1}},this.layerCanvas=a,this.countries=c.feature(t,t.objects.countries),this.draw()}return i(n,[{key:"draw",value:function(){var n=this.layerCanvas.ctx;n.fillStyle="#000",n.fillRect(0,0,this.layerCanvas.width,this.layerCanvas.height),this.options.countries.enabled&&(n.beginPath(),this.layerCanvas.path(this.countries),n.lineWidth=1*this.layerCanvas.scale,n.strokeStyle="#fff",n.stroke()),(0,d.dispatchEvent)("borders-updated")}}]),n}();n["default"]=f}),require.register("js/camera.js",function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{"default":n}}function o(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(n,"__esModule",{value:!0});var r=function(){function n(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}return function(e,t,a){return t&&n(e.prototype,t),a&&n(e,a),e}}(),i=e("lodash"),s=a(i),l=e("hammerjs"),c=(a(l),e("twgl.js")),u=a(c),d=e("./controlRange"),f=a(d),v=e("./utils"),m=u["default"].m4,_=function(){function n(e){var t=this;o(this,n),this.gl=e,this.fov=50,this.longitude=new f["default"](0,(-180),180,(!0)),this.latitude=new f["default"](0,(-90),90),this.zoom=new f["default"](.5,0,1),this.dragging=!1,this.dragStart=void 0,this.mousePosition=void 0,this.hammer=new Hammer(e.canvas),this.hammer.get("pinch").set({enable:!0}),document.addEventListener("mousemove",function(n){t.handleMouseMove(n)}),e.canvas.addEventListener("mousedown",function(){t.dragging=!0}),document.addEventListener("selectstart",function(n){t.dragging===!0&&n.preventDefault()}),document.addEventListener("mouseup",function(){t.dragging=!1}),e.canvas.addEventListener("scroll",function(){return!1}),this.hammer.on("pan",function(n){return"mouse"!=n.pointerType&&t.handlePan(8*n.velocityX,8*n.velocityY),!1}),this.hammer.on("pinchstart",function(n){t.lastZoom=t.zoom.value,t.pinching=!0}),this.hammer.on("pinchend",function(n){t.pinching=!1}),this.hammer.on("pinch",function(n){t.pinching&&t.zoom.changeTo(t.lastZoom+.5*(n.scale-1))}),window.addEventListener("wheel",function(n){var a=.001*-n.deltaY;1===n.mozInputSource&&1===n.deltaMode&&(a*=50),n.target==e.canvas&&(t.zoom.changeBy(a),n.preventDefault())})}return r(n,[{key:"handleMouseMove",value:function(n){var e={x:n.screenX,y:n.screenY};if(void 0!==this.mousePosition&&this.dragging){var t=e.x-this.mousePosition.x,a=e.y-this.mousePosition.y;this.handlePan(.3*t,.3*a),n.stopPropagation()}this.mousePosition=e}},{key:"handlePan",value:function(n,e){var t=1-.8*this.zoom.value;this.longitude.changeBy(-n*t),this.latitude.changeBy(e*t)}},{key:"getValues",value:function(n){return"sphere"==n?this.getSphereValues():this.getPlaneValues()}},{key:"getSphereValues",value:function(){var n=this.gl.canvas.width/this.gl.canvas.height,e=(0,v.toRadians)(30)/s["default"].clamp(n,0,1),t=m.perspective(e,n,.01,10),a=[0,0,-(4.5-3*this.zoom.value)],o=m.identity();m.rotateY(o,(0,v.toRadians)(this.longitude.value+180),o),m.rotateX(o,(0,v.toRadians)(this.latitude.value),o),a=m.transformPoint(o,a);var r=m.transformPoint(o,[0,1,0]),i=[0,0,0],l=m.inverse(m.lookAt(a,i,r));return{view:l,projection:t,eye:a}}},{key:"getPlaneValues",value:function(){var n=this.gl.canvas.width/this.gl.canvas.height,e=(0,v.toRadians)(30)/s["default"].clamp(n,0,1),t=m.perspective(e,n,.01,10),a=[this.longitude.value/180,0,-this.latitude.value/180],o=[a[0],2.5-2.25*this.zoom.value,a[2]],r=[0,0,-1],i=m.inverse(m.lookAt(o,a,r));return{view:i,projection:t,eye:o}}}]),n}();n["default"]=_}),require.register("js/components/checkboxOption.js",function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{"default":n}}function o(n,e){i["default"].component("checkbox-option",i["default"].extend({data:function(){return e[this.property].data},props:["label","property"],template:'\n      <label v-bind:class="[\'checkbox-option\', { active: enabled }]">\n        <input type="checkbox" v-model="enabled">\n        {{label}}\n      </label>\n    ',watch:{enabled:{handler:function(){var t=this;window.requestAnimationFrame(function(){window.requestAnimationFrame(function(){n.layerUpdated(e[t.property].layer)})})}}}}))}Object.defineProperty(n,"__esModule",{value:!0}),n["default"]=o;var r=e("vue/dist/vue.js"),i=a(r),s=e("lodash");a(s)}),require.register("js/components/projections.js",function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{"default":n}}function o(n,e){i["default"].component("projections",i["default"].extend({data:function(){return e},computed:{},props:[],template:'\n      <div class="projections">\n        <div class="radio-buttons">\n          <div class="radio-button"\n            v-bind:class="{ active: projection == \'sphere\' }">\n            <label>\n              <input type="radio" name="projection"\n                value="sphere" v-model="projection">\n              Globe\n            </label>\n          </div>\n          <div class="radio-button"\n            v-bind:class="{ active: projection == \'plane\' }">\n            <label>\n              <input type="radio" name="projection"\n                value="plane" v-model="projection">\n              Flat\n            </label>\n          </div>\n        </div>\n      </div>\n    ',watch:{projection:{handler:function(){n.updated()}}}}))}Object.defineProperty(n,"__esModule",{value:!0}),n["default"]=o;var r=e("vue/dist/vue.js"),i=a(r)}),require.register("js/components/rangeSlider.js",function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{"default":n}}function o(n,e){i["default"].component("range-slider",i["default"].extend({beforeCreate:function(){this.updateFormatted=function(n){n.formatted=e[n.property].formatted(n)}},created:function(){this.updateFormatted(this)},data:function(){return l["default"].extend(e[this.property].data,{formatted:""})},props:["label","property","vertical"],template:"\n      <div v-bind:class=\"['range-slider', 'range-control', { vertical: vertical }]\">\n        <div class=\"top-row\">\n          <label>{{label}}</label>\n          <span>{{formatted}}</span>\n        </div>\n        <div class=\"slider\">\n          <input type='range'\n            :min='min'\n            :max='max'\n            step=\"any\"\n            v-model.number=\"value\">\n        </div>\n      </div>\n    ",watch:{value:{handler:function(){this.updateFormatted(this),n.updated()}}}}))}Object.defineProperty(n,"__esModule",{value:!0}),n["default"]=o;var r=e("vue/dist/vue.js"),i=a(r),s=e("lodash"),l=a(s)}),require.register("js/components/renderModes.js",function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{"default":n}}function o(n,e){i["default"].component("render-modes",i["default"].extend({data:function(){return e},computed:{},props:[],template:'\n      <div class="render-modes">\n        <div class="radio-buttons">\n          <div class="radio-button"\n            v-bind:class="{ active: renderMode == \'dayAndNight\' }">\n            <label>\n              <input type="radio" name="render-mode"\n                value="dayAndNight" v-model="renderMode">\n              Day and Night\n            </label>\n            <div v-show="renderMode == \'dayAndNight\'" class="sub-group">\n              <range-slider\n                label="Hour of Day"\n                property="hourOfDay">\n              </range-slider>\n              <range-slider\n                label="Day of Year"\n                property="dayOfYear">\n              </range-slider>\n            </div>\n          </div>\n          <div class="radio-button"\n            v-bind:class="{ active: renderMode == \'day\' }">\n            <label>\n              <input type="radio" name="render-mode"\n                value="day" v-model="renderMode">\n              Day\n            </label>\n          </div>\n          <div class="radio-button"\n            v-bind:class="{ active: renderMode == \'night\' }">\n            <label>\n              <input type="radio" name="render-mode"\n                value="night" v-model="renderMode">\n              Night\n            </label>\n          </div>\n          <div class="radio-button"\n            v-bind:class="{ active: renderMode == \'elevation\' }">\n            <label>\n              <input type="radio" name="render-mode"\n                value="elevation" v-model="renderMode">\n              Elevation\n            </label>\n            <div v-show="renderMode == \'elevation\'" class="sub-group">\n              <range-slider\n                label="Elevation Scale"\n                property="elevationScale">\n              </range-slider>\n            </div>\n          </div>\n        </div>\n      </div>\n    ',watch:{renderMode:{handler:function(){n.updated()}}}}))}Object.defineProperty(n,"__esModule",{value:!0}),n["default"]=o;var r=e("vue/dist/vue.js"),i=a(r)}),require.register("js/controlRange.js",function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{"default":n}}function o(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(n,"__esModule",{value:!0});var r=function(){function n(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}return function(e,t,a){return t&&n(e.prototype,t),a&&n(e,a),e}}(),i=e("lodash"),s=a(i),l=function(){function n(e,t,a){var r=!(arguments.length<=3||void 0===arguments[3])&&arguments[3];o(this,n),this.value=e,this.min=t,this.max=a,this.wrap=r}return r(n,[{key:"changeBy",value:function(n){this.changeTo(this.value+n)}},{key:"changeTo",value:function(n){this.wrap?this.setWrap(n):this.setClamp(n)}},{key:"setClamp",value:function(n){this.value=s["default"].clamp(n,this.min,this.max)}},{key:"setWrap",value:function(n){if(n>this.max){var e=n%this.max;n=this.min+e}else n<this.min&&(n=this.max-(this.min-n));this.value=n}}]),n}();n["default"]=l}),require.register("js/controller.js",function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{"default":n}}function o(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(n,"__esModule",{value:!0});var r=function(){function n(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}return function(e,t,a){return t&&n(e.prototype,t),a&&n(e,a),e}}(),i=e("vue/dist/vue.js"),s=a(i),l=e("moment"),c=(a(l),e("numeral")),u=a(c),d=e("lodash"),f=a(d),v=e("stats.js"),m=a(v),_=e("./scene"),h=a(_),p=e("./renderer"),x=a(p),g=e("./camera"),b=a(g),y=e("./layerCanvas"),w=a(y),L=e("./landMaskLayer"),N=a(L),F=e("./bordersLayer"),C=a(F),S=e("./components/rangeSlider"),D=a(S),T=e("./components/checkboxOption"),G=a(T),H=e("./components/renderModes"),M=a(H),E=e("./components/projections"),z=a(E),R=function(){function n(e,t){var a=this;o(this,n),this.layerCanvas=new w["default"](e),this.layers={landmask:new N["default"](e,t,this.layerCanvas),borders:new C["default"](e,t,this.layerCanvas)},this.scene=new h["default"](e,this.layerCanvas,this.layers),this.renderer=new x["default"](e,this.scene),this.camera=new b["default"](e);var r=function(){return""},i=function(n){return(0,u["default"])(n.value).format("0.00")+"Â°"},l=function(){return a.scene.calculatedMoment().format("h:mm a")+" UTC"},c=function(){return a.scene.calculatedMoment().format("YYYY-MM-DD")},d=function(n){return 1===n.value?"(Realistic) 1x":(0,u["default"])(n.value).format("0.00")+"X"},v={latitude:{data:this.camera.latitude,formatted:i},longitude:{data:this.camera.longitude,formatted:i},zoom:{data:this.camera.zoom,formatted:r},hourOfDay:{data:this.scene.hourOfDay,formatted:l},dayOfYear:{data:this.scene.dayOfYear,formatted:c},elevationScale:{data:this.scene.elevationScale,formatted:d},rivers:{data:this.layers.landmask.options.rivers,layer:"landmask"},countries:{data:this.layers.borders.options.countries,layer:"borders"}};(0,D["default"])(this,v),(0,G["default"])(this,v),(0,M["default"])(this,this.scene),(0,z["default"])(this,this.scene),this.vue=new s["default"]({el:".map-controls"}),this.updateQueued=!1,f["default"].each(this.layers,function(n,e){f["default"].defer(function(){a.layerUpdated(e)})}),window.addEventListener("resize",function(){a.updated()}),window.addEventListener("texture-loaded",function(){a.updated()})}return r(n,[{key:"enableStats",value:function(){this.stats=new m["default"],this.stats.showPanel(0),this.stats.dom.style.left="auto",this.stats.dom.style.right="0",document.body.appendChild(this.stats.dom)}},{key:"layerUpdated",value:function(n){this.layers[n].draw()}},{key:"updated",value:function(){var n=this;this.updateQueued||(this.updateQueued=!0,window.requestAnimationFrame(function(){if(n.renderFrame(),n.updateQueued=!1,!n.loaded){n.loaded=!0;var e=document.querySelector(".loading");e.parentNode.removeChild(e)}}))}},{key:"renderFrame",value:function(){this.stats&&this.stats.begin(),this.renderer.render(window.performance.now(),this.scene,this.camera,this.renderer),this.stats&&this.stats.end()}}]),n}();n["default"]=R}),require.register("js/coordinates.js",function(n,e,t){"use strict";function a(n){return n/1e3/86400+2440587.5}function o(n){var e=a(n)-2451545,t=357.529+.98560028*e,o=280.459+.98564736*e,i=o+1.915*Math.sin((0,r.toRadians)(t))+.02*Math.sin((0,r.toRadians)(2*t)),s=23.439-3.6e-7*e,l=Math.cos((0,r.toRadians)(s))*Math.sin((0,r.toRadians)(i)),c=Math.cos((0,r.toRadians)(i)),u=Math.atan2(l,c),d=Math.asin(Math.sin((0,r.toRadians)(s))*Math.sin((0,r.toRadians)(i))),f=18.697374558+24.06570982441908*e,v=f/24*Math.PI*2-u;return{hourAngle:v,declination:d}}Object.defineProperty(n,"__esModule",{value:!0}),n["default"]=o;var r=e("./utils")}),require.register("js/landMaskLayer.js",function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{"default":n}}function o(n){if(n&&n.__esModule)return n;var e={};if(null!=n)for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(e[t]=n[t]);return e["default"]=n,e}function r(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(n,"__esModule",{value:!0});var i=function(){function n(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}return function(e,t,a){return t&&n(e.prototype,t),a&&n(e,a),e}}(),s=e("d3"),l=(o(s),e("topojson")),c=o(l),u=e("lodash"),d=(a(u),e("./utils")),f=function(){function n(e,t,a){r(this,n),this.options={rivers:{enabled:!1}},this.layerCanvas=a,this.land=c.feature(t,t.objects.land),this.lakes=c.feature(t,t.objects.lakes),this.rivers=c.feature(t,t.objects.rivers)}return i(n,[{key:"draw",value:function(){var n=this.layerCanvas.ctx;n.fillStyle="#000",n.fillRect(0,0,this.layerCanvas.width,this.layerCanvas.height),n.beginPath(),this.layerCanvas.path(this.land),n.fillStyle="#fff",n.fill(),n.lineWidth=1*this.scale,n.strokeStyle="#fff",n.stroke(),n.beginPath(),this.layerCanvas.path(this.lakes),n.fillStyle="#000",n.fill(),n.lineWidth=1*this.layerCanvas.scale,n.strokeStyle="#000",n.stroke(),this.options.rivers.enabled&&(n.beginPath(),this.layerCanvas.path(this.rivers),n.lineWidth=1*this.layerCanvas.scale,n.strokeStyle="#000",n.stroke()),(0,d.dispatchEvent)("landmask-updated")}}]),n}();n["default"]=f}),require.register("js/layerCanvas.js",function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{"default":n}}function o(n){if(n&&n.__esModule)return n;var e={};if(null!=n)for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(e[t]=n[t]);return e["default"]=n,e}function r(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(n,"__esModule",{value:!0});var i=e("d3"),s=o(i),l=e("lodash"),c=(a(l),function u(n){r(this,u),n.getParameter(n.MAX_TEXTURE_SIZE)>=8192?(this.width=8192,this.height=4096,this.scale=1):(this.width=4096,this.height=2048,this.scale=.5),this.projection=s.geoEquirectangular().scale(this.height/Math.PI).translate([this.width/2,this.height/2]),this.canvas=s.select(document.createElement("canvas")).attr("width",this.width).attr("height",this.height),this.ctx=this.canvas.node().getContext("2d"),this.path=s.geoPath().projection(this.projection).context(this.ctx)});n["default"]=c}),require.register("js/octahedronSphere.js",function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{"default":n}}function o(n){for(var e=new Float32Array(d["default"].flatten([[0,1,0],[0,0,-1],[-1,0,0],[0,1,0],[-1,0,0],[0,0,1],[0,1,0],[0,0,1],[1,0,0],[0,1,0],[1,0,0],[0,0,-1],[0,-1,0],[-1,0,0],[0,0,-1],[0,-1,0],[0,0,1],[-1,0,0],[0,-1,0],[1,0,0],[0,0,1],[0,-1,0],[0,0,-1],[1,0,0]])),t=[new f.Vec3Array(e)],a=0;a<n;a++){for(var o=t[a],s=new f.Vec3Array(new Float32Array(4*o.data.length)),l=0;l<o.length;l+=3)r(o,s,l);t.push(s)}for(var c=t[t.length-1],u=new f.Vec2Array(new Float32Array(2*c.length)),v=0;v<c.length;v+=3)i(u,c,v);var m=0,_=new Int16Array(c.length),h=new f.Vec3Array(new Float32Array(c.data.length)),p=new f.Vec2Array(new Float32Array(u.data.length)),x={},g=0;for(g;g<c.length;g++){var b=c.get(g),y=u.get(g),w=[b[0],b[1],b[2],y[0],y[1]].join(","),L=x[w];void 0===L?(x[w]=m,h.set(m,b),p.set(m,y),_[g]=m,m+=1):_[g]=L}return{indices:_.subarray(0,g),position:h.data.subarray(0,3*m),texcoord:p.data.subarray(0,2*m),elevation:new Float32Array(m)}}function r(n,e,t){var a=n.get(t),o=n.get(t+1),r=n.get(t+2),i=Array.prototype.slice.call(v.normalize(v.add(a,o))),s=Array.prototype.slice.call(v.normalize(v.add(o,r))),l=Array.prototype.slice.call(v.normalize(v.add(r,a)));e.setRange(4*t,[a,i,l,i,s,l,i,o,s,l,s,r])}function i(n,e,t){var a=s(e.get(t)),o=s(e.get(t+1)),r=s(e.get(t+2)),i=Math.min(a[0],o[0],r[0]),l=Math.max(a[0],o[0],r[0]);l-i>.5&&(a[0]=1==a[0]?0:a[0],o[0]=1==o[0]?0:o[0],r[0]=1==r[0]?0:r[0]),n.setRange(t,[a,o,r])}function s(n){return[Math.atan2(n[0],n[2])/(2*Math.PI)+.5,1-(Math.asin(n[1])/Math.PI+.5)]}Object.defineProperty(n,"__esModule",{value:!0}),n["default"]=o;var l=e("twgl.js"),c=a(l),u=e("lodash"),d=a(u),f=e("./vectorArray"),v=c["default"].v3}),require.register("js/renderer.js",function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{"default":n}}function o(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(n,"__esModule",{value:!0});var r=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(n[a]=t[a])}return n},i=function(){function n(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}return function(e,t,a){return t&&n(e.prototype,t),a&&n(e,a),e}}(),s=e("twgl.js"),l=a(s),c=e("./shaders.js"),u=a(c),d=l["default"].m4,f=function(){function n(e,t){var a=this;o(this,n),this.gl=e,e.clearColor(0,0,0,0),this.derivatives=e.getExtension("OES_standard_derivatives"),this.anisotropic=e.getExtension("EXT_texture_filter_anisotropic"),this.uniforms={};for(name in t.textures){var r=t.textures[name];this.setupGlobeTexture(e,r),this.uniforms[name]=r}this.shaders=new u["default"](e),e.enable(e.DEPTH_TEST),e.enable(e.CULL_FACE),window.addEventListener("texture-loaded",function(n){a.uniforms[n.detail.texture+"Size"]=new Float32Array([n.detail.width,n.detail.height])}),this.updateCanvasSize(e),window.addEventListener("resize",function(){a.updateCanvasSize(e)})}return i(n,[{key:"setupGlobeTexture",value:function(n,e){n.bindTexture(n.TEXTURE_2D,e),this.anisotropic&&n.texParameterf(n.TEXTURE_2D,this.anisotropic.TEXTURE_MAX_ANISOTROPY_EXT,16),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.REPEAT),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.LINEAR_MIPMAP_LINEAR)}},{key:"render",value:function(n,e,t){var a=this.gl;a.clear(a.COLOR_BUFFER_BIT|a.DEPTH_BUFFER_BIT);var o=d.identity(),i=e.getSunVector();r(this.uniforms,t.getValues(e.projection),e.getElevationScales(),{model:o,time:n,lightDirection:d.transformPoint(i,[-1,0,0]),flatProjection:"plane"==e.projection});var s=this.shaders.getProgram(e.projection,e.renderMode);a.useProgram(s.program),l["default"].setBuffersAndAttributes(a,s,e[e.projection+"Buffer"]),l["default"].setUniforms(s,this.uniforms),a.drawElements(a.TRIANGLES,e[e.projection+"Buffer"].numElements,a.UNSIGNED_SHORT,0)}},{key:"updateCanvasSize",value:function(n){var e=n.canvas.parentNode.offsetWidth,t=n.canvas.parentNode.offsetHeight;if(e+"px"!=n.canvas.style.width||t+"px"!=n.canvas.style.height){n.canvas.style.width=e+"px",n.canvas.style.height=t+"px";var a=window.devicePixelRatio||1;a>1&&e>1500&&(a-=.5),n.canvas.width=Math.floor(e*a),n.canvas.height=Math.floor(t*a),n.viewport(0,0,n.canvas.width,n.canvas.height)}}}]),n}();n["default"]=f}),require.register("js/scene.js",function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{"default":n}}function o(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(n,"__esModule",{value:!0});var r=function(){function n(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}return function(e,t,a){return t&&n(e.prototype,t),a&&n(e,a),e}}(),i=e("twgl.js"),s=a(i),l=e("moment"),c=a(l),u=e("lodash"),d=a(u),f=e("./utils"),v=e("./controlRange"),m=a(v),_=e("./octahedronSphere"),h=a(_),p=e("./coordinates.js"),x=a(p),g=s["default"].m4,b=function(){function n(e,t,a){var r=this;o(this,n),this.gl=e,this.layerCanvas=t,this.layers=a,this.hourOfDay=new m["default"](12,.001,23.999),this.dayOfYear=new m["default"](182,1,365),this.elevationScale=new m["default"](10,1,30),this.sphere=(0,h["default"])(6),this.sphereBuffer=s["default"].createBufferInfoFromArrays(e,{indices:{numComponents:3,data:this.sphere.indices},position:{numComponents:3,data:this.sphere.position},texcoord:{numComponents:2,data:this.sphere.texcoord},elevation:{numComponents:1,data:this.sphere.elevation}}),this.plane=s["default"].primitives.createPlaneVertices(2,1,255,127),this.plane.elevation=new Float32Array(this.sphere.position.length),this.planeBuffer=s["default"].createBufferInfoFromArrays(e,{indices:{numComponents:3,data:this.plane.indices},position:{numComponents:3,data:this.plane.position},texcoord:{numComponents:2,data:this.plane.texcoord},elevation:{numComponents:1,data:this.plane.elevation}}),this.projection="sphere",this.renderMode="dayAndNight",this.fillInElevations(),this.initTextures(),window.addEventListener("landmask-updated",function(){r.updateLayerTexture("landmask")}),window.addEventListener("borders-updated",function(){r.updateLayerTexture("borders")})}return r(n,[{key:"updateLayerTexture",value:function(n){var e=this.layerCanvas.canvas.node();s["default"].setTextureFromElement(this.gl,this.textures[n+"Map"],e),(0,f.dispatchEvent)("texture-loaded",{texture:n+"Map",width:e.width,height:e.height})}},{key:"initTextures",value:function(){var n={diffuseMap:{format:this.gl.RGB,internalFormat:this.gl.RGB,src:"data/color-4096.jpg",color:[0,0,0,1]},topographyMap:{format:this.gl.LUMINANCE,internalFormat:this.gl.LUMINANCE,src:"data/topo-bathy-4096.jpg",color:[0,0,0,1]},landmaskMap:{format:this.gl.LUMINANCE,internalFormat:this.gl.LUMINANCE,width:2,height:2},bordersMap:{format:this.gl.LUMINANCE,internalFormat:this.gl.LUMINANCE,width:2,height:2},lightsMap:{src:"data/lights-4096.png",format:this.gl.LUMINANCE,internalFormat:this.gl.LUMINANCE,color:[0,0,0,1]}};for(var e in n)(0,f.dispatchEvent)("texture-loaded",{texture:e,width:1,height:1});this.textures=s["default"].createTextures(this.gl,n,function(n,e,t){for(var a in t)(0,f.dispatchEvent)("texture-loaded",{texture:a,width:t[a].width,height:t[a].height})})}},{key:"calculatedMoment",value:function(){return(0,c["default"])("2016-01-01T00:00:00.000Z").utcOffset(0).dayOfYear(this.dayOfYear.value).add(60*this.hourOfDay.value*60,"seconds")}},{key:"getSunVector",value:function(){var n=this.calculatedMoment(),e=(0,x["default"])(d["default"].toInteger(n.format("x"))),t=g.identity();return t=g.rotateY(t,Math.PI/2-e.hourAngle),t=g.rotateZ(t,-e.declination)}},{key:"getElevationScales",value:function(){var n=20068/6371e3,e=n,t=0;return"elevation"===this.renderMode&&(e=this.elevationScale.value*n,t=this.elevationScale.value*n),{oceanElevationScale:t,landElevationScale:e}}},{key:"fillInElevations",value:function(){var n=this,e=new Image;e.onload=function(){var t=document.createElement("canvas");t.width=e.width,t.height=e.height;var a=t.getContext("2d");a.drawImage(e,0,0,e.width,e.height);for(var o=a.getImageData(0,0,e.width,e.height).data,r=e.width-1,i=e.height-1,l=0;l<n.sphere.elevation.length;l++){var c=n.sphere.texcoord[2*l],u=n.sphere.texcoord[2*l+1],f=d["default"].clamp(d["default"].floor((1==c?0:c)*r),0,r),v=d["default"].clamp(d["default"].floor((1==u?0:u)*i),0,i),m=o[4*[f+v*e.width]];n.sphere.elevation[l]=m/255-.5}s["default"].setAttribInfoBufferFromArray(n.gl,n.sphereBuffer.attribs.elevation,n.sphere.elevation),s["default"].setAttribInfoBufferFromArray(n.gl,n.planeBuffer.attribs.elevation,n.plane.elevation)},e.src="data/topo-bathy-128.jpg"}}]),n}();n["default"]=b}),require.register("js/shaders.js",function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{"default":n}}function o(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(n,"__esModule",{value:!0});var r=function(){function n(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}return function(e,t,a){return t&&n(e.prototype,t),a&&n(e,a),e}}(),i=e("twgl.js"),s=e("../shaders/sphere.vert.glsl"),l=a(s),c=e("../shaders/plane.vert.glsl"),u=a(c),d=e("../shaders/dayAndNight.frag.glsl"),f=a(d),v=e("../shaders/dayAndNightSimple.frag.glsl"),m=a(v),_=e("../shaders/day.frag.glsl"),h=a(_),p=e("../shaders/night.frag.glsl"),x=a(p),g=e("../shaders/elevation.frag.glsl"),b=a(g),y=function(){function n(e){o(this,n),this.shaders={sphere:{dayAndNight:(0,i.createProgramInfo)(e,[l["default"],f["default"]]),day:(0,i.createProgramInfo)(e,[l["default"],h["default"]]),night:(0,i.createProgramInfo)(e,[l["default"],x["default"]]),elevation:(0,i.createProgramInfo)(e,[l["default"],b["default"]])},plane:{dayAndNight:(0,i.createProgramInfo)(e,[u["default"],m["default"]]),day:(0,i.createProgramInfo)(e,[u["default"],h["default"]]),night:(0,i.createProgramInfo)(e,[u["default"],x["default"]]),elevation:(0,i.createProgramInfo)(e,[u["default"],b["default"]])}}}return r(n,[{key:"getProgram",value:function(n,e){return this.shaders[n][e]}}]),n}();n["default"]=y}),require.register("js/utils.js",function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{"default":n}}function o(n){return n/180*Math.PI}function r(n,e){var t=document.createEvent("CustomEvent");t.initCustomEvent(n,!1,!1,e||{}),window.dispatchEvent(t)}Object.defineProperty(n,"__esModule",{value:!0}),n.toRadians=o,n.dispatchEvent=r;var i=e("platform"),s=(a(i),e("lodash"));a(s)}),require.register("js/vectorArray.js",function(n,e,t){"use strict";function a(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(n,"__esModule",{value:!0});var o=function(){function n(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}return function(e,t,a){return t&&n(e.prototype,t),a&&n(e,a),e}}();n.Vec2Array=function(){function n(e){a(this,n),this.data=e,this.length=e.length/2}return o(n,[{key:"get",value:function(n){var e=2*n;return[this.data[e],this.data[e+1]]}},{key:"setRange",value:function(n,e){for(var t=0;t<e.length;t++)this.set(n+t,e[t])}},{key:"set",value:function(n,e){this.data[2*n]=e[0],this.data[2*n+1]=e[1]}}]),n}(),n.Vec3Array=function(){function n(e){a(this,n),this.data=e,this.length=e.length/3}return o(n,[{key:"get",value:function(n){var e=3*n;return[this.data[e],this.data[e+1],this.data[e+2]]}},{key:"setRange",value:function(n,e){for(var t=0;t<e.length;t++)this.set(n+t,e[t])}},{key:"set",value:function(n,e){this.data[3*n]=e[0],this.data[3*n+1]=e[1],this.data[3*n+2]=e[2]}}]),n}()}),require.register("shaders/day.frag.glsl",function(n,e,t){t.exports='#extension GL_OES_standard_derivatives : enable\nprecision highp float;\n#define GLSLIFY 1\n\nconst float gamma_5_0 = 2.2;\n\nfloat toLinear_5_1(float v) {\n  return pow(v, gamma_5_0);\n}\n\nvec2 toLinear_5_1(vec2 v) {\n  return pow(v, vec2(gamma_5_0));\n}\n\nvec3 toLinear_5_1(vec3 v) {\n  return pow(v, vec3(gamma_5_0));\n}\n\nvec4 toLinear_5_1(vec4 v) {\n  return vec4(toLinear_5_1(v.rgb), v.a);\n}\n\n\n\nconst float gamma_6_2 = 2.2;\n\nfloat toGamma_6_3(float v) {\n  return pow(v, 1.0 / gamma_6_2);\n}\n\nvec2 toGamma_6_3(vec2 v) {\n  return pow(v, vec2(1.0 / gamma_6_2));\n}\n\nvec3 toGamma_6_3(vec3 v) {\n  return pow(v, vec3(1.0 / gamma_6_2));\n}\n\nvec4 toGamma_6_3(vec4 v) {\n  return vec4(toGamma_6_3(v.rgb), v.a);\n}\n\n\n\n// Based on https://github.com/vorg/pragmatic-pbr/blob/master/local_modules/glsl-tonemap-uncharted2/index.glsl\nfloat A_1_4 = 0.15;\nfloat B_1_5 = 0.50;\nfloat C_1_6 = 0.10;\nfloat D_1_7 = 0.20;\nfloat E_1_8 = 0.02;\nfloat F_1_9 = 0.30;\nfloat W_1_10 = 11.2;\n\nvec3 Uncharted2Tonemap_1_11(vec3 x) {\n   return ((x * (A_1_4 * x + C_1_6 * B_1_5) + D_1_7 * E_1_8) / (x * (A_1_4 * x + B_1_5) + D_1_7 * F_1_9)) - E_1_8 / F_1_9;\n}\n\n// Based on Filmic Tonemapping Operators http://filmicgames.com/archives/75\nvec3 tonemap_1_12(vec3 color) {\n    float ExposureBias = 2.0;\n    vec3 curr = Uncharted2Tonemap_1_11(ExposureBias * color);\n\n    vec3 whiteScale = 1.0 / Uncharted2Tonemap_1_11(vec3(W_1_10));\n    return curr * whiteScale;\n}\n\n\n\n// Set camera exposure based on angle between sun and eye\n\nfloat exposure_2_13(vec3 eye, vec3 L, float low, float high) {\n  return mix(\n    low,\n    high,\n    pow((1.0 - dot(normalize(eye), L)) / 2.0, 10.0)\n  );\n}\n\n\n\n/*\nModified from https://github.com/wdas/brdf/blob/master/src/brdfs/disney.brdf\n\nOriginal license notice:\n# Copyright Disney Enterprises, Inc.  All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the "License");\n# you may not use this file except in compliance with the License\n# and the following modification to it: Section 6 Trademarks.\n# deleted and replaced with:\n#\n# 6. Trademarks. This License does not grant permission to use the\n# trade names, trademarks, service marks, or product names of the\n# Licensor and its affiliates, except as required for reproducing\n# the content of the NOTICE file.\n#\n# You may obtain a copy of the License at\n# http://www.apache.org/licenses/LICENSE-2.0\n*/\n\nfloat specularTint_3_14 = 0.0;\nfloat anisotropic_3_15 = 0.0;\nfloat sheen_3_16 = 0.0;\nfloat sheenTint_3_17 = 0.5;\nfloat clearcoat_3_18 = 0.0;\nfloat clearcoatGloss_3_19 = 1.0;\n\nconst float PI_3_20 = 3.14159265358979323846;\n\nfloat sqr_3_21(float x) { return x*x; }\n\nfloat SchlickFresnel_3_22(float u) {\n  float m = clamp(1.0 - u, 0.0, 1.0);\n  float m2 = m * m;\n  return m2 * m2 * m; // pow(m, 5)\n}\n\nfloat GTR1_3_23(float NdotH, float a) {\n  if (a >= 1.0) return 1.0 / PI_3_20;\n  float a2 = a * a;\n  float t = 1.0 + (a2 - 1.0) * NdotH * NdotH;\n  return (a2 - 1.0) / (PI_3_20 * log(a2) * t);\n}\n\nfloat GTR2_3_24(float NdotH, float a) {\n  float a2 = a * a;\n  float t = 1.0 + (a2 - 1.0) * NdotH * NdotH;\n  return a2 / (PI_3_20 * t * t);\n}\n\nfloat GTR2_aniso_3_25(float NdotH, float HdotX, float HdotY, float ax, float ay) {\n  return 1.0 / (\n    PI_3_20 * ax * ay *\n    sqr_3_21(sqr_3_21(HdotX / ax) + sqr_3_21(HdotY / ay) + NdotH * NdotH)\n  );\n}\n\nfloat smithG_GGX_3_26(float Ndotv, float alphaG) {\n  float a = alphaG * alphaG;\n  float b = Ndotv * Ndotv;\n  return 1.0 / (Ndotv + sqrt(a + b - a * b));\n}\n\nvec3 mon2lin_3_27(vec3 x) {\n  return vec3(pow(x[0], 2.2), pow(x[1], 2.2), pow(x[2], 2.2));\n}\n\nvec3 brdf_3_28(\n  vec3 baseColor,\n  float metallic,\n  float subsurface,\n  float specular,\n  float roughness,\n  vec3 L, vec3 V, vec3 N\n) {\n  float NdotL = dot(N, L);\n  float NdotV = dot(N, V);\n\n  vec3 H = normalize(L + V);\n  float NdotH = dot(N, H);\n  float LdotH = dot(L, H);\n\n  vec3 Cdlin = mon2lin_3_27(baseColor);\n  float Cdlum = 0.3 * Cdlin[0] + 0.6 * Cdlin[1]  + 0.1 * Cdlin[2]; // luminance approx.\n\n  vec3 Ctint = Cdlum > 0.0 ? Cdlin / Cdlum : vec3(1.0); // normalize lum. to isolate hue+sat\n  vec3 Cspec0 = mix(specular * .08 * mix(vec3(1.0), Ctint, specularTint_3_14), Cdlin, metallic);\n  vec3 Csheen = mix(vec3(1.0), Ctint, sheenTint_3_17);\n\n  // Diffuse fresnel - go from 1 at normal incidence to .5 at grazing\n  // and mix in diffuse retro-reflection based on roughness\n  float FL = SchlickFresnel_3_22(NdotL), FV = SchlickFresnel_3_22(NdotV);\n  float Fd90 = 0.5 + 2.0 * LdotH * LdotH * roughness;\n  float Fd = mix(1.0, Fd90, FL) * mix(1.0, Fd90, FV);\n\n  // Based on Hanrahan-Krueger brdf approximation of isotropic bssrdf\n  // 1.25 scale is used to (roughly) preserve albedo\n  // Fss90 used to "flatten" retroreflection based on roughness\n  float Fss90 = LdotH * LdotH * roughness;\n  float Fss = mix(1.0, Fss90, FL) * mix(1.0, Fss90, FV);\n  float ss = 1.25 * (Fss * (1.0 / (NdotL + NdotV) - 0.5) + 0.5);\n\n  // specular\n  float Ds = GTR2_3_24(NdotH, max(0.001, sqr_3_21(roughness)));\n  float FH = SchlickFresnel_3_22(LdotH);\n  vec3 Fs = mix(Cspec0, vec3(1.0), FH);\n  float roughg = sqr_3_21(roughness * 0.5 + 0.5);\n  float Gs = smithG_GGX_3_26(NdotL, roughg) * smithG_GGX_3_26(NdotV, roughg);\n\n  // sheen\n  vec3 Fsheen = FH * sheen_3_16 * Csheen;\n\n  // clearcoat (ior = 1.5 -> F0 = 0.04)\n  float Dr = GTR1_3_23(NdotH, mix(0.1, 0.001, clearcoatGloss_3_19));\n  float Fr = mix(0.04, 1.0, FH);\n  float Gr = smithG_GGX_3_26(NdotL, 0.25) * smithG_GGX_3_26(NdotV, 0.25);\n\n  return ((1.0/PI_3_20) * mix(Fd, ss, subsurface) * Cdlin + Fsheen)\n    * (1.0 - metallic) +\n    Gs * Fs * Ds +\n    0.25 * clearcoat_3_18 * Gr * Fr * Dr;\n}\n\n\n\n// Based on:\n// http://stackoverflow.com/questions/13501081/efficient-bicubic-filtering-code-in-glsl\n\nvec4 cubic_4_29(float v) {\n  vec4 n = vec4(1.0, 2.0, 3.0, 4.0) - v;\n  vec4 s = n * n * n;\n  float x = s.x;\n  float y = s.y - 4.0 * s.x;\n  float z = s.z - 4.0 * s.y + 6.0 * s.x;\n  float w = 6.0 - x - y - z;\n  return vec4(x, y, z, w);\n}\n\nvec4 texture2DCubic_4_30(\n  sampler2D tex,\n  vec2 uv,\n  vec2 textureResolution\n) {\n  vec2 texcoord = uv * textureResolution;\n  texcoord -= vec2(0.5);\n  float fx = fract(texcoord.x);\n  float fy = fract(texcoord.y);\n  texcoord.x -= fx;\n  texcoord.y -= fy;\n\n  vec4 xcubic = cubic_4_29(fx);\n  vec4 ycubic = cubic_4_29(fy);\n\n  vec4 c = vec4(\n    texcoord.x - 0.5,\n    texcoord.x + 1.5,\n    texcoord.y - 0.5,\n    texcoord.y + 1.5\n  );\n\n  vec4 s = vec4(\n    xcubic.x + xcubic.y,\n    xcubic.z + xcubic.w,\n    ycubic.x + ycubic.y,\n    ycubic.z + ycubic.w\n  );\n\n  vec4 offset = c + vec4(\n    xcubic.y,\n    xcubic.w,\n    ycubic.y,\n    ycubic.w\n  ) / s;\n\n  vec4 sample0 = texture2D(tex,\n    vec2(offset.x, offset.z) / textureResolution);\n\n  vec4 sample1 = texture2D(tex,\n    vec2(offset.y, offset.z) / textureResolution);\n\n  vec4 sample2 = texture2D(tex,\n    vec2(offset.x, offset.w) / textureResolution);\n\n  vec4 sample3 = texture2D(tex,\n    vec2(offset.y, offset.w) / textureResolution);\n\n  float sx = s.x / (s.x + s.y);\n  float sy = s.z / (s.z + s.w);\n\n  return mix(\n    mix(sample3, sample2, sx),\n    mix(sample1, sample0, sx),\n    sy\n  );\n}\n\n\n\n\nuniform sampler2D topographyMap;\nuniform sampler2D diffuseMap;\nuniform sampler2D landmaskMap;\nuniform sampler2D bordersMap;\nuniform vec2 bordersMapSize;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\n\nvoid main() {\n  vec3 constantLight = vNormal;\n  vec3 V = vNormal;\n\n  float landness = texture2D(landmaskMap, vUv, -0.25).r;\n  float countryBorder = texture2D(bordersMap, vUv, -0.25).r;\n  float oceanDepth = (0.5 - texture2D(topographyMap, vUv).r) * 2.0;\n\n  vec3 oceanColor = mix(\n    vec3(0.1, 0.15, 0.45),\n    vec3(0.1, 0.15, 0.35),\n    oceanDepth\n  );\n\n  vec3 diffuseColor = mix(\n    oceanColor,\n    toLinear_5_1(texture2D(diffuseMap, vUv).rgb),\n    landness\n  );\n\n  vec3 N = vNormal;\n  vec3 L = normalize(constantLight);\n  vec3 H = normalize(L + V);\n\n  float roughness = mix(\n    mix(0.75, 0.55, oceanDepth),\n    (1.0 - diffuseColor.r * 0.5),\n    landness\n  );\n\n  vec3 color = vec3(0.0);\n  if (dot(vNormal, L) > 0.0) {\n    vec3 lightColor = vec3(10.0);\n\n    color = lightColor * brdf_3_28(\n      diffuseColor,\n      0.0, //metallic\n      0.5, //subsurface\n      0.0, //specular\n      roughness, //roughness\n      L, V, N\n    );\n  }\n\n  vec3 shaded = toGamma_6_3(tonemap_1_12(color * 1.0));\n  vec3 final = shaded + countryBorder;\n  gl_FragColor = vec4(final, 1.0);\n}\n';
}),require.register("shaders/dayAndNight.frag.glsl",function(n,e,t){t.exports='#extension GL_OES_standard_derivatives : enable\nprecision highp float;\n#define GLSLIFY 1\n\nconst float gamma_10_0 = 2.2;\n\nfloat toLinear_10_1(float v) {\n  return pow(v, gamma_10_0);\n}\n\nvec2 toLinear_10_1(vec2 v) {\n  return pow(v, vec2(gamma_10_0));\n}\n\nvec3 toLinear_10_1(vec3 v) {\n  return pow(v, vec3(gamma_10_0));\n}\n\nvec4 toLinear_10_1(vec4 v) {\n  return vec4(toLinear_10_1(v.rgb), v.a);\n}\n\n\n\nconst float gamma_11_2 = 2.2;\n\nfloat toGamma_11_3(float v) {\n  return pow(v, 1.0 / gamma_11_2);\n}\n\nvec2 toGamma_11_3(vec2 v) {\n  return pow(v, vec2(1.0 / gamma_11_2));\n}\n\nvec3 toGamma_11_3(vec3 v) {\n  return pow(v, vec3(1.0 / gamma_11_2));\n}\n\nvec4 toGamma_11_3(vec4 v) {\n  return vec4(toGamma_11_3(v.rgb), v.a);\n}\n\n\n\n\n// Based on:\n// http://stackoverflow.com/questions/13501081/efficient-bicubic-filtering-code-in-glsl\n\nvec4 cubic_9_4(float v) {\n  vec4 n = vec4(1.0, 2.0, 3.0, 4.0) - v;\n  vec4 s = n * n * n;\n  float x = s.x;\n  float y = s.y - 4.0 * s.x;\n  float z = s.z - 4.0 * s.y + 6.0 * s.x;\n  float w = 6.0 - x - y - z;\n  return vec4(x, y, z, w);\n}\n\nvec4 texture2DCubic_9_5(\n  sampler2D tex,\n  vec2 uv,\n  vec2 textureResolution\n) {\n  vec2 texcoord = uv * textureResolution;\n  texcoord -= vec2(0.5);\n  float fx = fract(texcoord.x);\n  float fy = fract(texcoord.y);\n  texcoord.x -= fx;\n  texcoord.y -= fy;\n\n  vec4 xcubic = cubic_9_4(fx);\n  vec4 ycubic = cubic_9_4(fy);\n\n  vec4 c = vec4(\n    texcoord.x - 0.5,\n    texcoord.x + 1.5,\n    texcoord.y - 0.5,\n    texcoord.y + 1.5\n  );\n\n  vec4 s = vec4(\n    xcubic.x + xcubic.y,\n    xcubic.z + xcubic.w,\n    ycubic.x + ycubic.y,\n    ycubic.z + ycubic.w\n  );\n\n  vec4 offset = c + vec4(\n    xcubic.y,\n    xcubic.w,\n    ycubic.y,\n    ycubic.w\n  ) / s;\n\n  vec4 sample0 = texture2D(tex,\n    vec2(offset.x, offset.z) / textureResolution);\n\n  vec4 sample1 = texture2D(tex,\n    vec2(offset.y, offset.z) / textureResolution);\n\n  vec4 sample2 = texture2D(tex,\n    vec2(offset.x, offset.w) / textureResolution);\n\n  vec4 sample3 = texture2D(tex,\n    vec2(offset.y, offset.w) / textureResolution);\n\n  float sx = s.x / (s.x + s.y);\n  float sy = s.z / (s.z + s.w);\n\n  return mix(\n    mix(sample3, sample2, sx),\n    mix(sample1, sample0, sx),\n    sy\n  );\n}\n\n\n\n\n// Based on https://docs.unrealengine.com/latest/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf\n\nvec2 heightDerivative_1_6(\n  vec2 texST,\n  sampler2D map,\n  vec2 textureResolution\n) {\n  vec2 TexDx = dFdx(texST);\n  vec2 TexDy = dFdy(texST);\n  vec2 STll = texST;\n  vec2 STlr = texST + TexDx;\n  vec2 STul = texST + TexDy;\n  float Hll = texture2DCubic_9_5(map, STll, textureResolution).x;\n  float Hlr = texture2DCubic_9_5(map, STlr, textureResolution).x;\n  float Hul = texture2DCubic_9_5(map, STul, textureResolution).x;\n  float dBs = Hlr - Hll;\n  float dBt = Hul - Hll;\n  return vec2(dBs, dBt);\n}\n\n\n\n// Based on https://docs.unrealengine.com/latest/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf\n\nvec3 perturbNormal_2_7(vec3 surf_pos, vec3 surf_norm, vec2 dHdxy) {\n  // Calling derivatives per-component to address android bug:\n  // http://stackoverflow.com/questions/20272272/\n  vec3 vSigmaX = vec3(dFdx(surf_pos.x), dFdx(surf_pos.y), dFdx(surf_pos.z));\n  vec3 vSigmaY = vec3(dFdy(surf_pos.x), dFdy(surf_pos.y), dFdy(surf_pos.z));\n  vec3 vN = vec3(normalize(surf_norm)); // normalized\n  vec3 R1 = cross(vSigmaY, vN);\n  vec3 R2 = cross(vN, vSigmaX);\n\n  float fDet = dot(vSigmaX, R1);\n  vec3 vGrad = sign(fDet) * (dHdxy.x * R1 + dHdxy.y * R2);\n  return normalize(abs(fDet) * surf_norm - vGrad);\n}\n\n\n\n// Based on https://github.com/vorg/pragmatic-pbr/blob/master/local_modules/glsl-tonemap-uncharted2/index.glsl\nfloat A_3_8 = 0.15;\nfloat B_3_9 = 0.50;\nfloat C_3_10 = 0.10;\nfloat D_3_11 = 0.20;\nfloat E_3_12 = 0.02;\nfloat F_3_13 = 0.30;\nfloat W_3_14 = 11.2;\n\nvec3 Uncharted2Tonemap_3_15(vec3 x) {\n   return ((x * (A_3_8 * x + C_3_10 * B_3_9) + D_3_11 * E_3_12) / (x * (A_3_8 * x + B_3_9) + D_3_11 * F_3_13)) - E_3_12 / F_3_13;\n}\n\n// Based on Filmic Tonemapping Operators http://filmicgames.com/archives/75\nvec3 tonemap_3_16(vec3 color) {\n    float ExposureBias = 2.0;\n    vec3 curr = Uncharted2Tonemap_3_15(ExposureBias * color);\n\n    vec3 whiteScale = 1.0 / Uncharted2Tonemap_3_15(vec3(W_3_14));\n    return curr * whiteScale;\n}\n\n\n\n// Set camera exposure based on angle between sun and eye\n\nfloat exposure_4_17(vec3 eye, vec3 L, float low, float high) {\n  return mix(\n    low,\n    high,\n    pow((1.0 - dot(normalize(eye), L)) / 2.0, 10.0)\n  );\n}\n\n\n\n// Scale bump map effect to produce relatively even relief\n// shading across surface. Goal is to avoid too much shading\n// at glancing angles and too little shading in the center.\n//\n// Also, allow for an additional bump scale factor with\n// `oceanFactor`. This allows ocean floor rendering to show\n// full bumps vs ocean surface rendering being flat.\n\nfloat terrainBumpScale_5_18(\n  float landness,\n  float oceanFactor,\n  float vNdotL,\n  float vNdotV,\n  vec3 vEye,\n  vec3 vPosition\n) {\n  float shadowStart = 0.25;\n  float bumpFalloff = clamp(vNdotL / shadowStart, 0.0, 0.5);\n\n  float bumpScale = mix(\n    0.005,\n    0.05,\n    vNdotL * vNdotL * vNdotV\n  ) * bumpFalloff;\n\n  if (landness < 0.5) {\n    bumpScale *= -oceanFactor;\n  }\n\n  return bumpScale;\n}\n\n\n\nvec3 atmosphere_6_19(float NdotL, float NdotV, vec3 color) {\n  return (\n    max(pow(NdotL, 2.0), 0.0) *\n    pow(1.0 - NdotV, 12.0)\n  ) * color;\n}\n\n\n\nvec3 nightAmbient_7_20(\n  float NdotL,\n  vec3 diffuseColor,\n  float nightLightAmount,\n  vec2 vUv\n) {\n  return 0.01 * (\n    nightLightAmount * vec3(1.0, 1.0, 0.8) +\n    0.1 * vec3(0.1, 0.1, 1.0) * diffuseColor\n  ) * clamp((-NdotL + 0.01) * 2.0, 0.0, 1.0);\n}\n\n\n\n/*\nModified from https://github.com/wdas/brdf/blob/master/src/brdfs/disney.brdf\n\nOriginal license notice:\n# Copyright Disney Enterprises, Inc.  All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the "License");\n# you may not use this file except in compliance with the License\n# and the following modification to it: Section 6 Trademarks.\n# deleted and replaced with:\n#\n# 6. Trademarks. This License does not grant permission to use the\n# trade names, trademarks, service marks, or product names of the\n# Licensor and its affiliates, except as required for reproducing\n# the content of the NOTICE file.\n#\n# You may obtain a copy of the License at\n# http://www.apache.org/licenses/LICENSE-2.0\n*/\n\nfloat specularTint_8_21 = 0.0;\nfloat anisotropic_8_22 = 0.0;\nfloat sheen_8_23 = 0.0;\nfloat sheenTint_8_24 = 0.5;\nfloat clearcoat_8_25 = 0.0;\nfloat clearcoatGloss_8_26 = 1.0;\n\nconst float PI_8_27 = 3.14159265358979323846;\n\nfloat sqr_8_28(float x) { return x*x; }\n\nfloat SchlickFresnel_8_29(float u) {\n  float m = clamp(1.0 - u, 0.0, 1.0);\n  float m2 = m * m;\n  return m2 * m2 * m; // pow(m, 5)\n}\n\nfloat GTR1_8_30(float NdotH, float a) {\n  if (a >= 1.0) return 1.0 / PI_8_27;\n  float a2 = a * a;\n  float t = 1.0 + (a2 - 1.0) * NdotH * NdotH;\n  return (a2 - 1.0) / (PI_8_27 * log(a2) * t);\n}\n\nfloat GTR2_8_31(float NdotH, float a) {\n  float a2 = a * a;\n  float t = 1.0 + (a2 - 1.0) * NdotH * NdotH;\n  return a2 / (PI_8_27 * t * t);\n}\n\nfloat GTR2_aniso_8_32(float NdotH, float HdotX, float HdotY, float ax, float ay) {\n  return 1.0 / (\n    PI_8_27 * ax * ay *\n    sqr_8_28(sqr_8_28(HdotX / ax) + sqr_8_28(HdotY / ay) + NdotH * NdotH)\n  );\n}\n\nfloat smithG_GGX_8_33(float Ndotv, float alphaG) {\n  float a = alphaG * alphaG;\n  float b = Ndotv * Ndotv;\n  return 1.0 / (Ndotv + sqrt(a + b - a * b));\n}\n\nvec3 mon2lin_8_34(vec3 x) {\n  return vec3(pow(x[0], 2.2), pow(x[1], 2.2), pow(x[2], 2.2));\n}\n\nvec3 brdf_8_35(\n  vec3 baseColor,\n  float metallic,\n  float subsurface,\n  float specular,\n  float roughness,\n  vec3 L, vec3 V, vec3 N\n) {\n  float NdotL = dot(N, L);\n  float NdotV = dot(N, V);\n\n  vec3 H = normalize(L + V);\n  float NdotH = dot(N, H);\n  float LdotH = dot(L, H);\n\n  vec3 Cdlin = mon2lin_8_34(baseColor);\n  float Cdlum = 0.3 * Cdlin[0] + 0.6 * Cdlin[1]  + 0.1 * Cdlin[2]; // luminance approx.\n\n  vec3 Ctint = Cdlum > 0.0 ? Cdlin / Cdlum : vec3(1.0); // normalize lum. to isolate hue+sat\n  vec3 Cspec0 = mix(specular * .08 * mix(vec3(1.0), Ctint, specularTint_8_21), Cdlin, metallic);\n  vec3 Csheen = mix(vec3(1.0), Ctint, sheenTint_8_24);\n\n  // Diffuse fresnel - go from 1 at normal incidence to .5 at grazing\n  // and mix in diffuse retro-reflection based on roughness\n  float FL = SchlickFresnel_8_29(NdotL), FV = SchlickFresnel_8_29(NdotV);\n  float Fd90 = 0.5 + 2.0 * LdotH * LdotH * roughness;\n  float Fd = mix(1.0, Fd90, FL) * mix(1.0, Fd90, FV);\n\n  // Based on Hanrahan-Krueger brdf approximation of isotropic bssrdf\n  // 1.25 scale is used to (roughly) preserve albedo\n  // Fss90 used to "flatten" retroreflection based on roughness\n  float Fss90 = LdotH * LdotH * roughness;\n  float Fss = mix(1.0, Fss90, FL) * mix(1.0, Fss90, FV);\n  float ss = 1.25 * (Fss * (1.0 / (NdotL + NdotV) - 0.5) + 0.5);\n\n  // specular\n  float Ds = GTR2_8_31(NdotH, max(0.001, sqr_8_28(roughness)));\n  float FH = SchlickFresnel_8_29(LdotH);\n  vec3 Fs = mix(Cspec0, vec3(1.0), FH);\n  float roughg = sqr_8_28(roughness * 0.5 + 0.5);\n  float Gs = smithG_GGX_8_33(NdotL, roughg) * smithG_GGX_8_33(NdotV, roughg);\n\n  // sheen\n  vec3 Fsheen = FH * sheen_8_23 * Csheen;\n\n  // clearcoat (ior = 1.5 -> F0 = 0.04)\n  float Dr = GTR1_8_30(NdotH, mix(0.1, 0.001, clearcoatGloss_8_26));\n  float Fr = mix(0.04, 1.0, FH);\n  float Gr = smithG_GGX_8_33(NdotL, 0.25) * smithG_GGX_8_33(NdotV, 0.25);\n\n  return ((1.0/PI_8_27) * mix(Fd, ss, subsurface) * Cdlin + Fsheen)\n    * (1.0 - metallic) +\n    Gs * Fs * Ds +\n    0.25 * clearcoat_8_25 * Gr * Fr * Dr;\n}\n\n\n\n\n\nuniform sampler2D topographyMap;\nuniform vec2 topographyMapSize;\nuniform sampler2D diffuseMap;\nuniform sampler2D landmaskMap;\nuniform sampler2D bordersMap;\nuniform vec2 bordersMapSize;\nuniform sampler2D lightsMap;\nuniform vec3 lightDirection;\nuniform vec3 eye;\n\nvarying vec2 vUv;\nvarying vec3 vPosition;\nvarying vec3 vNormal;\n\nvoid main() {\n  vec3 V = normalize(eye - vPosition);\n  float vNdotL = dot(vNormal, lightDirection);\n  float vNdotL_clamped = clamp(vNdotL, 0.0, 1.0);\n  float vNdotV = dot(vNormal, V);\n  float vNdotV_clamped = clamp(vNdotV, 0.0, 1.0);\n\n  float landness = texture2D(landmaskMap, vUv, -0.25).r;\n  float countryBorder = texture2D(bordersMap, vUv, -0.25).r;\n  float oceanDepth = (0.5 - texture2D(topographyMap, vUv).r) * 2.0;\n\n  vec2 dHdxy = heightDerivative_1_6(\n    vUv,\n    topographyMap,\n    topographyMapSize\n  );\n\n  dHdxy *= terrainBumpScale_5_18(\n    landness,\n    0.0,\n    vNdotL,\n    vNdotV,\n    eye,\n    vPosition\n  );\n\n  vec3 oceanColor = mix(\n    vec3(0.0, 0.0, 0.35),\n    vec3(0.0, 0.0, 0.3),\n    oceanDepth\n  );\n\n  vec3 diffuseColor = mix(\n    oceanColor,\n    toLinear_10_1(texture2D(diffuseMap, vUv).rgb),\n    landness\n  );\n\n  vec3 N = perturbNormal_2_7(vPosition, vNormal, dHdxy);\n  vec3 L = normalize(lightDirection);\n  vec3 H = normalize(L + V);\n\n  float roughness = mix(\n    mix(0.6, 0.8, oceanDepth),\n    (1.0 - diffuseColor.r * 0.5),\n    smoothstep(0.25, 0.75, landness)\n  );\n\n  vec3 color = nightAmbient_7_20(\n    vNdotL,\n    diffuseColor,\n    texture2D(lightsMap, vUv).x,\n    vUv\n  );\n\n  if (dot(vNormal, L) > 0.0) {\n    vec3 lightColor = vec3(8.0);\n\n    float incidence = pow(dot(N, L), 1.5);\n\n    color = lightColor * incidence * brdf_8_35(\n      diffuseColor,\n      0.0, //metallic\n      0.5, //subsurface\n      0.3, //specular\n      roughness, //roughness\n      L, V, N\n    );\n\n    color += atmosphere_6_19(\n      vNdotL_clamped,\n      vNdotV_clamped,\n      vec3(0.1, 0.1, 1.0) * 20.0\n    );\n  }\n\n  vec3 shaded = toGamma_11_3(tonemap_3_16(color * exposure_4_17(eye, L, 1.5, 300.0)));\n  vec3 final = shaded + countryBorder;\n\n  gl_FragColor = vec4(final, 1.0);\n}\n'}),require.register("shaders/dayAndNightSimple.frag.glsl",function(n,e,t){t.exports='#extension GL_OES_standard_derivatives : enable\nprecision highp float;\n#define GLSLIFY 1\n\nconst float gamma_10_0 = 2.2;\n\nfloat toLinear_10_1(float v) {\n  return pow(v, gamma_10_0);\n}\n\nvec2 toLinear_10_1(vec2 v) {\n  return pow(v, vec2(gamma_10_0));\n}\n\nvec3 toLinear_10_1(vec3 v) {\n  return pow(v, vec3(gamma_10_0));\n}\n\nvec4 toLinear_10_1(vec4 v) {\n  return vec4(toLinear_10_1(v.rgb), v.a);\n}\n\n\n\nconst float gamma_11_2 = 2.2;\n\nfloat toGamma_11_3(float v) {\n  return pow(v, 1.0 / gamma_11_2);\n}\n\nvec2 toGamma_11_3(vec2 v) {\n  return pow(v, vec2(1.0 / gamma_11_2));\n}\n\nvec3 toGamma_11_3(vec3 v) {\n  return pow(v, vec3(1.0 / gamma_11_2));\n}\n\nvec4 toGamma_11_3(vec4 v) {\n  return vec4(toGamma_11_3(v.rgb), v.a);\n}\n\n\n\n\n// Based on:\n// http://stackoverflow.com/questions/13501081/efficient-bicubic-filtering-code-in-glsl\n\nvec4 cubic_9_4(float v) {\n  vec4 n = vec4(1.0, 2.0, 3.0, 4.0) - v;\n  vec4 s = n * n * n;\n  float x = s.x;\n  float y = s.y - 4.0 * s.x;\n  float z = s.z - 4.0 * s.y + 6.0 * s.x;\n  float w = 6.0 - x - y - z;\n  return vec4(x, y, z, w);\n}\n\nvec4 texture2DCubic_9_5(\n  sampler2D tex,\n  vec2 uv,\n  vec2 textureResolution\n) {\n  vec2 texcoord = uv * textureResolution;\n  texcoord -= vec2(0.5);\n  float fx = fract(texcoord.x);\n  float fy = fract(texcoord.y);\n  texcoord.x -= fx;\n  texcoord.y -= fy;\n\n  vec4 xcubic = cubic_9_4(fx);\n  vec4 ycubic = cubic_9_4(fy);\n\n  vec4 c = vec4(\n    texcoord.x - 0.5,\n    texcoord.x + 1.5,\n    texcoord.y - 0.5,\n    texcoord.y + 1.5\n  );\n\n  vec4 s = vec4(\n    xcubic.x + xcubic.y,\n    xcubic.z + xcubic.w,\n    ycubic.x + ycubic.y,\n    ycubic.z + ycubic.w\n  );\n\n  vec4 offset = c + vec4(\n    xcubic.y,\n    xcubic.w,\n    ycubic.y,\n    ycubic.w\n  ) / s;\n\n  vec4 sample0 = texture2D(tex,\n    vec2(offset.x, offset.z) / textureResolution);\n\n  vec4 sample1 = texture2D(tex,\n    vec2(offset.y, offset.z) / textureResolution);\n\n  vec4 sample2 = texture2D(tex,\n    vec2(offset.x, offset.w) / textureResolution);\n\n  vec4 sample3 = texture2D(tex,\n    vec2(offset.y, offset.w) / textureResolution);\n\n  float sx = s.x / (s.x + s.y);\n  float sy = s.z / (s.z + s.w);\n\n  return mix(\n    mix(sample3, sample2, sx),\n    mix(sample1, sample0, sx),\n    sy\n  );\n}\n\n\n\n\n// Based on https://docs.unrealengine.com/latest/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf\n\nvec2 heightDerivative_1_6(\n  vec2 texST,\n  sampler2D map,\n  vec2 textureResolution\n) {\n  vec2 TexDx = dFdx(texST);\n  vec2 TexDy = dFdy(texST);\n  vec2 STll = texST;\n  vec2 STlr = texST + TexDx;\n  vec2 STul = texST + TexDy;\n  float Hll = texture2DCubic_9_5(map, STll, textureResolution).x;\n  float Hlr = texture2DCubic_9_5(map, STlr, textureResolution).x;\n  float Hul = texture2DCubic_9_5(map, STul, textureResolution).x;\n  float dBs = Hlr - Hll;\n  float dBt = Hul - Hll;\n  return vec2(dBs, dBt);\n}\n\n\n\n// Based on https://docs.unrealengine.com/latest/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf\n\nvec3 perturbNormal_2_7(vec3 surf_pos, vec3 surf_norm, vec2 dHdxy) {\n  // Calling derivatives per-component to address android bug:\n  // http://stackoverflow.com/questions/20272272/\n  vec3 vSigmaX = vec3(dFdx(surf_pos.x), dFdx(surf_pos.y), dFdx(surf_pos.z));\n  vec3 vSigmaY = vec3(dFdy(surf_pos.x), dFdy(surf_pos.y), dFdy(surf_pos.z));\n  vec3 vN = vec3(normalize(surf_norm)); // normalized\n  vec3 R1 = cross(vSigmaY, vN);\n  vec3 R2 = cross(vN, vSigmaX);\n\n  float fDet = dot(vSigmaX, R1);\n  vec3 vGrad = sign(fDet) * (dHdxy.x * R1 + dHdxy.y * R2);\n  return normalize(abs(fDet) * surf_norm - vGrad);\n}\n\n\n\n// Based on https://github.com/vorg/pragmatic-pbr/blob/master/local_modules/glsl-tonemap-uncharted2/index.glsl\nfloat A_3_8 = 0.15;\nfloat B_3_9 = 0.50;\nfloat C_3_10 = 0.10;\nfloat D_3_11 = 0.20;\nfloat E_3_12 = 0.02;\nfloat F_3_13 = 0.30;\nfloat W_3_14 = 11.2;\n\nvec3 Uncharted2Tonemap_3_15(vec3 x) {\n   return ((x * (A_3_8 * x + C_3_10 * B_3_9) + D_3_11 * E_3_12) / (x * (A_3_8 * x + B_3_9) + D_3_11 * F_3_13)) - E_3_12 / F_3_13;\n}\n\n// Based on Filmic Tonemapping Operators http://filmicgames.com/archives/75\nvec3 tonemap_3_16(vec3 color) {\n    float ExposureBias = 2.0;\n    vec3 curr = Uncharted2Tonemap_3_15(ExposureBias * color);\n\n    vec3 whiteScale = 1.0 / Uncharted2Tonemap_3_15(vec3(W_3_14));\n    return curr * whiteScale;\n}\n\n\n\n// Set camera exposure based on angle between sun and eye\n\nfloat exposure_4_17(vec3 eye, vec3 L, float low, float high) {\n  return mix(\n    low,\n    high,\n    pow((1.0 - dot(normalize(eye), L)) / 2.0, 10.0)\n  );\n}\n\n\n\n// Scale bump map effect to produce relatively even relief\n// shading across surface. Goal is to avoid too much shading\n// at glancing angles and too little shading in the center.\n//\n// Also, allow for an additional bump scale factor with\n// `oceanFactor`. This allows ocean floor rendering to show\n// full bumps vs ocean surface rendering being flat.\n\nfloat terrainBumpScale_5_18(\n  float landness,\n  float oceanFactor,\n  float vNdotL,\n  float vNdotV,\n  vec3 vEye,\n  vec3 vPosition\n) {\n  float shadowStart = 0.25;\n  float bumpFalloff = clamp(vNdotL / shadowStart, 0.0, 0.5);\n\n  float bumpScale = mix(\n    0.005,\n    0.05,\n    vNdotL * vNdotL * vNdotV\n  ) * bumpFalloff;\n\n  if (landness < 0.5) {\n    bumpScale *= -oceanFactor;\n  }\n\n  return bumpScale;\n}\n\n\n\nvec3 atmosphere_6_19(float NdotL, float NdotV, vec3 color) {\n  return (\n    max(pow(NdotL, 2.0), 0.0) *\n    pow(1.0 - NdotV, 12.0)\n  ) * color;\n}\n\n\n\nvec3 nightAmbient_7_20(\n  float NdotL,\n  vec3 diffuseColor,\n  float nightLightAmount,\n  vec2 vUv\n) {\n  return 0.01 * (\n    nightLightAmount * vec3(1.0, 1.0, 0.8) +\n    0.1 * vec3(0.1, 0.1, 1.0) * diffuseColor\n  ) * clamp((-NdotL + 0.01) * 2.0, 0.0, 1.0);\n}\n\n\n\n/*\nModified from https://github.com/wdas/brdf/blob/master/src/brdfs/disney.brdf\n\nOriginal license notice:\n# Copyright Disney Enterprises, Inc.  All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the "License");\n# you may not use this file except in compliance with the License\n# and the following modification to it: Section 6 Trademarks.\n# deleted and replaced with:\n#\n# 6. Trademarks. This License does not grant permission to use the\n# trade names, trademarks, service marks, or product names of the\n# Licensor and its affiliates, except as required for reproducing\n# the content of the NOTICE file.\n#\n# You may obtain a copy of the License at\n# http://www.apache.org/licenses/LICENSE-2.0\n*/\n\nfloat specularTint_8_21 = 0.0;\nfloat anisotropic_8_22 = 0.0;\nfloat sheen_8_23 = 0.0;\nfloat sheenTint_8_24 = 0.5;\nfloat clearcoat_8_25 = 0.0;\nfloat clearcoatGloss_8_26 = 1.0;\n\nconst float PI_8_27 = 3.14159265358979323846;\n\nfloat sqr_8_28(float x) { return x*x; }\n\nfloat SchlickFresnel_8_29(float u) {\n  float m = clamp(1.0 - u, 0.0, 1.0);\n  float m2 = m * m;\n  return m2 * m2 * m; // pow(m, 5)\n}\n\nfloat GTR1_8_30(float NdotH, float a) {\n  if (a >= 1.0) return 1.0 / PI_8_27;\n  float a2 = a * a;\n  float t = 1.0 + (a2 - 1.0) * NdotH * NdotH;\n  return (a2 - 1.0) / (PI_8_27 * log(a2) * t);\n}\n\nfloat GTR2_8_31(float NdotH, float a) {\n  float a2 = a * a;\n  float t = 1.0 + (a2 - 1.0) * NdotH * NdotH;\n  return a2 / (PI_8_27 * t * t);\n}\n\nfloat GTR2_aniso_8_32(float NdotH, float HdotX, float HdotY, float ax, float ay) {\n  return 1.0 / (\n    PI_8_27 * ax * ay *\n    sqr_8_28(sqr_8_28(HdotX / ax) + sqr_8_28(HdotY / ay) + NdotH * NdotH)\n  );\n}\n\nfloat smithG_GGX_8_33(float Ndotv, float alphaG) {\n  float a = alphaG * alphaG;\n  float b = Ndotv * Ndotv;\n  return 1.0 / (Ndotv + sqrt(a + b - a * b));\n}\n\nvec3 mon2lin_8_34(vec3 x) {\n  return vec3(pow(x[0], 2.2), pow(x[1], 2.2), pow(x[2], 2.2));\n}\n\nvec3 brdf_8_35(\n  vec3 baseColor,\n  float metallic,\n  float subsurface,\n  float specular,\n  float roughness,\n  vec3 L, vec3 V, vec3 N\n) {\n  float NdotL = dot(N, L);\n  float NdotV = dot(N, V);\n\n  vec3 H = normalize(L + V);\n  float NdotH = dot(N, H);\n  float LdotH = dot(L, H);\n\n  vec3 Cdlin = mon2lin_8_34(baseColor);\n  float Cdlum = 0.3 * Cdlin[0] + 0.6 * Cdlin[1]  + 0.1 * Cdlin[2]; // luminance approx.\n\n  vec3 Ctint = Cdlum > 0.0 ? Cdlin / Cdlum : vec3(1.0); // normalize lum. to isolate hue+sat\n  vec3 Cspec0 = mix(specular * .08 * mix(vec3(1.0), Ctint, specularTint_8_21), Cdlin, metallic);\n  vec3 Csheen = mix(vec3(1.0), Ctint, sheenTint_8_24);\n\n  // Diffuse fresnel - go from 1 at normal incidence to .5 at grazing\n  // and mix in diffuse retro-reflection based on roughness\n  float FL = SchlickFresnel_8_29(NdotL), FV = SchlickFresnel_8_29(NdotV);\n  float Fd90 = 0.5 + 2.0 * LdotH * LdotH * roughness;\n  float Fd = mix(1.0, Fd90, FL) * mix(1.0, Fd90, FV);\n\n  // Based on Hanrahan-Krueger brdf approximation of isotropic bssrdf\n  // 1.25 scale is used to (roughly) preserve albedo\n  // Fss90 used to "flatten" retroreflection based on roughness\n  float Fss90 = LdotH * LdotH * roughness;\n  float Fss = mix(1.0, Fss90, FL) * mix(1.0, Fss90, FV);\n  float ss = 1.25 * (Fss * (1.0 / (NdotL + NdotV) - 0.5) + 0.5);\n\n  // specular\n  float Ds = GTR2_8_31(NdotH, max(0.001, sqr_8_28(roughness)));\n  float FH = SchlickFresnel_8_29(LdotH);\n  vec3 Fs = mix(Cspec0, vec3(1.0), FH);\n  float roughg = sqr_8_28(roughness * 0.5 + 0.5);\n  float Gs = smithG_GGX_8_33(NdotL, roughg) * smithG_GGX_8_33(NdotV, roughg);\n\n  // sheen\n  vec3 Fsheen = FH * sheen_8_23 * Csheen;\n\n  // clearcoat (ior = 1.5 -> F0 = 0.04)\n  float Dr = GTR1_8_30(NdotH, mix(0.1, 0.001, clearcoatGloss_8_26));\n  float Fr = mix(0.04, 1.0, FH);\n  float Gr = smithG_GGX_8_33(NdotL, 0.25) * smithG_GGX_8_33(NdotV, 0.25);\n\n  return ((1.0/PI_8_27) * mix(Fd, ss, subsurface) * Cdlin + Fsheen)\n    * (1.0 - metallic) +\n    Gs * Fs * Ds +\n    0.25 * clearcoat_8_25 * Gr * Fr * Dr;\n}\n\n\n\nfloat lambertDiffuse_12_36(\n  vec3 lightDirection,\n  vec3 surfaceNormal) {\n  return max(0.0, dot(lightDirection, surfaceNormal));\n}\n\n\n\n\nuniform sampler2D topographyMap;\nuniform vec2 topographyMapSize;\nuniform sampler2D diffuseMap;\nuniform sampler2D landmaskMap;\nuniform sampler2D bordersMap;\nuniform vec2 bordersMapSize;\nuniform sampler2D lightsMap;\nuniform vec3 lightDirection;\nuniform vec3 eye;\n\nvarying vec2 vUv;\nvarying vec3 vPosition;\nvarying vec3 vSpherePosition;\nvarying vec3 vNormal;\n\nvoid main() {\n  vec3 V = normalize(eye - vPosition);\n  float vNdotL = dot(vNormal, lightDirection);\n  float vNdotL_clamped = clamp(vNdotL, 0.0, 1.0);\n  float vNdotV = dot(vNormal, V);\n  float vNdotV_clamped = clamp(vNdotV, 0.0, 1.0);\n\n  float landness = texture2D(landmaskMap, vUv, -0.25).r;\n  float countryBorder = texture2D(bordersMap, vUv, -0.25).r;\n  float oceanDepth = (0.5 - texture2D(topographyMap, vUv).r) * 2.0;\n\n  vec2 dHdxy = heightDerivative_1_6(\n    vUv,\n    topographyMap,\n    topographyMapSize\n  );\n\n  dHdxy *= terrainBumpScale_5_18(\n    landness,\n    0.0,\n    vNdotL,\n    vNdotV,\n    eye,\n    vSpherePosition\n  );\n\n  vec3 oceanColor = mix(\n    vec3(0.1, 0.1, 0.35),\n    vec3(0.1, 0.1, 0.3),\n    oceanDepth\n  );\n\n  vec3 diffuseColor = mix(\n    oceanColor,\n    toLinear_10_1(texture2D(diffuseMap, vUv).rgb),\n    landness\n  );\n\n  vec3 N = perturbNormal_2_7(vSpherePosition, vNormal, dHdxy);\n  vec3 L = normalize(lightDirection);\n  vec3 H = normalize(L + V);\n\n  float roughness = mix(\n    mix(0.6, 0.8, oceanDepth),\n    (1.0 - diffuseColor.r * 0.5),\n    smoothstep(0.25, 0.75, landness)\n  );\n\n  vec3 color = nightAmbient_7_20(\n    vNdotL - 0.025,\n    diffuseColor,\n    texture2D(lightsMap, vUv).x,\n    vUv\n  );\n\n  vec3 lightColor = vec3(0.05);\n\n  if (dot(vNormal, L) > 0.0) {\n    float incidence = dot(N, L);\n    color = color + lightColor * pow(diffuseColor, vec3(2.2)) * incidence;\n  }\n\n  vec3 shaded = toGamma_11_3(tonemap_3_16(color * 100.0));\n  vec3 final = shaded + countryBorder;\n\n  vec3 terminatorColor = vec3(0.4, 0.4, 0.0);\n  final += terminatorColor * min(pow(1.0 - abs(vNdotL), 250.0), 1.0);\n  gl_FragColor = vec4(final, 1.0);\n}\n'}),require.register("shaders/elevation.frag.glsl",function(n,e,t){t.exports='#extension GL_OES_standard_derivatives : enable\nprecision highp float;\n#define GLSLIFY 1\n\nconst float gamma_10_0 = 2.2;\n\nfloat toLinear_10_1(float v) {\n  return pow(v, gamma_10_0);\n}\n\nvec2 toLinear_10_1(vec2 v) {\n  return pow(v, vec2(gamma_10_0));\n}\n\nvec3 toLinear_10_1(vec3 v) {\n  return pow(v, vec3(gamma_10_0));\n}\n\nvec4 toLinear_10_1(vec4 v) {\n  return vec4(toLinear_10_1(v.rgb), v.a);\n}\n\n\n\nconst float gamma_11_2 = 2.2;\n\nfloat toGamma_11_3(float v) {\n  return pow(v, 1.0 / gamma_11_2);\n}\n\nvec2 toGamma_11_3(vec2 v) {\n  return pow(v, vec2(1.0 / gamma_11_2));\n}\n\nvec3 toGamma_11_3(vec3 v) {\n  return pow(v, vec3(1.0 / gamma_11_2));\n}\n\nvec4 toGamma_11_3(vec4 v) {\n  return vec4(toGamma_11_3(v.rgb), v.a);\n}\n\n\n\n\n// Based on:\n// http://stackoverflow.com/questions/13501081/efficient-bicubic-filtering-code-in-glsl\n\nvec4 cubic_9_4(float v) {\n  vec4 n = vec4(1.0, 2.0, 3.0, 4.0) - v;\n  vec4 s = n * n * n;\n  float x = s.x;\n  float y = s.y - 4.0 * s.x;\n  float z = s.z - 4.0 * s.y + 6.0 * s.x;\n  float w = 6.0 - x - y - z;\n  return vec4(x, y, z, w);\n}\n\nvec4 texture2DCubic_9_5(\n  sampler2D tex,\n  vec2 uv,\n  vec2 textureResolution\n) {\n  vec2 texcoord = uv * textureResolution;\n  texcoord -= vec2(0.5);\n  float fx = fract(texcoord.x);\n  float fy = fract(texcoord.y);\n  texcoord.x -= fx;\n  texcoord.y -= fy;\n\n  vec4 xcubic = cubic_9_4(fx);\n  vec4 ycubic = cubic_9_4(fy);\n\n  vec4 c = vec4(\n    texcoord.x - 0.5,\n    texcoord.x + 1.5,\n    texcoord.y - 0.5,\n    texcoord.y + 1.5\n  );\n\n  vec4 s = vec4(\n    xcubic.x + xcubic.y,\n    xcubic.z + xcubic.w,\n    ycubic.x + ycubic.y,\n    ycubic.z + ycubic.w\n  );\n\n  vec4 offset = c + vec4(\n    xcubic.y,\n    xcubic.w,\n    ycubic.y,\n    ycubic.w\n  ) / s;\n\n  vec4 sample0 = texture2D(tex,\n    vec2(offset.x, offset.z) / textureResolution);\n\n  vec4 sample1 = texture2D(tex,\n    vec2(offset.y, offset.z) / textureResolution);\n\n  vec4 sample2 = texture2D(tex,\n    vec2(offset.x, offset.w) / textureResolution);\n\n  vec4 sample3 = texture2D(tex,\n    vec2(offset.y, offset.w) / textureResolution);\n\n  float sx = s.x / (s.x + s.y);\n  float sy = s.z / (s.z + s.w);\n\n  return mix(\n    mix(sample3, sample2, sx),\n    mix(sample1, sample0, sx),\n    sy\n  );\n}\n\n\n\n\n// Based on https://docs.unrealengine.com/latest/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf\n\nvec2 heightDerivative_1_6(\n  vec2 texST,\n  sampler2D map,\n  vec2 textureResolution\n) {\n  vec2 TexDx = dFdx(texST);\n  vec2 TexDy = dFdy(texST);\n  vec2 STll = texST;\n  vec2 STlr = texST + TexDx;\n  vec2 STul = texST + TexDy;\n  float Hll = texture2DCubic_9_5(map, STll, textureResolution).x;\n  float Hlr = texture2DCubic_9_5(map, STlr, textureResolution).x;\n  float Hul = texture2DCubic_9_5(map, STul, textureResolution).x;\n  float dBs = Hlr - Hll;\n  float dBt = Hul - Hll;\n  return vec2(dBs, dBt);\n}\n\n\n\n// Based on https://docs.unrealengine.com/latest/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf\n\nvec3 perturbNormal_2_7(vec3 surf_pos, vec3 surf_norm, vec2 dHdxy) {\n  // Calling derivatives per-component to address android bug:\n  // http://stackoverflow.com/questions/20272272/\n  vec3 vSigmaX = vec3(dFdx(surf_pos.x), dFdx(surf_pos.y), dFdx(surf_pos.z));\n  vec3 vSigmaY = vec3(dFdy(surf_pos.x), dFdy(surf_pos.y), dFdy(surf_pos.z));\n  vec3 vN = vec3(normalize(surf_norm)); // normalized\n  vec3 R1 = cross(vSigmaY, vN);\n  vec3 R2 = cross(vN, vSigmaX);\n\n  float fDet = dot(vSigmaX, R1);\n  vec3 vGrad = sign(fDet) * (dHdxy.x * R1 + dHdxy.y * R2);\n  return normalize(abs(fDet) * surf_norm - vGrad);\n}\n\n\n\n// Based on https://github.com/vorg/pragmatic-pbr/blob/master/local_modules/glsl-tonemap-uncharted2/index.glsl\nfloat A_3_8 = 0.15;\nfloat B_3_9 = 0.50;\nfloat C_3_10 = 0.10;\nfloat D_3_11 = 0.20;\nfloat E_3_12 = 0.02;\nfloat F_3_13 = 0.30;\nfloat W_3_14 = 11.2;\n\nvec3 Uncharted2Tonemap_3_15(vec3 x) {\n   return ((x * (A_3_8 * x + C_3_10 * B_3_9) + D_3_11 * E_3_12) / (x * (A_3_8 * x + B_3_9) + D_3_11 * F_3_13)) - E_3_12 / F_3_13;\n}\n\n// Based on Filmic Tonemapping Operators http://filmicgames.com/archives/75\nvec3 tonemap_3_16(vec3 color) {\n    float ExposureBias = 2.0;\n    vec3 curr = Uncharted2Tonemap_3_15(ExposureBias * color);\n\n    vec3 whiteScale = 1.0 / Uncharted2Tonemap_3_15(vec3(W_3_14));\n    return curr * whiteScale;\n}\n\n\n\n// Set camera exposure based on angle between sun and eye\n\nfloat exposure_4_17(vec3 eye, vec3 L, float low, float high) {\n  return mix(\n    low,\n    high,\n    pow((1.0 - dot(normalize(eye), L)) / 2.0, 10.0)\n  );\n}\n\n\n\n// Scale bump map effect to produce relatively even relief\n// shading across surface. Goal is to avoid too much shading\n// at glancing angles and too little shading in the center.\n//\n// Also, allow for an additional bump scale factor with\n// `oceanFactor`. This allows ocean floor rendering to show\n// full bumps vs ocean surface rendering being flat.\n\nfloat terrainBumpScale_6_18(\n  float landness,\n  float oceanFactor,\n  float vNdotL,\n  float vNdotV,\n  vec3 vEye,\n  vec3 vPosition\n) {\n  float shadowStart = 0.25;\n  float bumpFalloff = clamp(vNdotL / shadowStart, 0.0, 0.5);\n\n  float bumpScale = mix(\n    0.005,\n    0.05,\n    vNdotL * vNdotL * vNdotV\n  ) * bumpFalloff;\n\n  if (landness < 0.5) {\n    bumpScale *= -oceanFactor;\n  }\n\n  return bumpScale;\n}\n\n\n\nvec3 atmosphere_5_19(float NdotL, float NdotV, vec3 color) {\n  return (\n    max(pow(NdotL, 2.0), 0.0) *\n    pow(1.0 - NdotV, 12.0)\n  ) * color;\n}\n\n\n\nvec3 nightAmbient_7_20(\n  float NdotL,\n  vec3 diffuseColor,\n  float nightLightAmount,\n  vec2 vUv\n) {\n  return 0.01 * (\n    nightLightAmount * vec3(1.0, 1.0, 0.8) +\n    0.1 * vec3(0.1, 0.1, 1.0) * diffuseColor\n  ) * clamp((-NdotL + 0.01) * 2.0, 0.0, 1.0);\n}\n\n\n\n/*\nModified from https://github.com/wdas/brdf/blob/master/src/brdfs/disney.brdf\n\nOriginal license notice:\n# Copyright Disney Enterprises, Inc.  All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the "License");\n# you may not use this file except in compliance with the License\n# and the following modification to it: Section 6 Trademarks.\n# deleted and replaced with:\n#\n# 6. Trademarks. This License does not grant permission to use the\n# trade names, trademarks, service marks, or product names of the\n# Licensor and its affiliates, except as required for reproducing\n# the content of the NOTICE file.\n#\n# You may obtain a copy of the License at\n# http://www.apache.org/licenses/LICENSE-2.0\n*/\n\nfloat specularTint_8_21 = 0.0;\nfloat anisotropic_8_22 = 0.0;\nfloat sheen_8_23 = 0.0;\nfloat sheenTint_8_24 = 0.5;\nfloat clearcoat_8_25 = 0.0;\nfloat clearcoatGloss_8_26 = 1.0;\n\nconst float PI_8_27 = 3.14159265358979323846;\n\nfloat sqr_8_28(float x) { return x*x; }\n\nfloat SchlickFresnel_8_29(float u) {\n  float m = clamp(1.0 - u, 0.0, 1.0);\n  float m2 = m * m;\n  return m2 * m2 * m; // pow(m, 5)\n}\n\nfloat GTR1_8_30(float NdotH, float a) {\n  if (a >= 1.0) return 1.0 / PI_8_27;\n  float a2 = a * a;\n  float t = 1.0 + (a2 - 1.0) * NdotH * NdotH;\n  return (a2 - 1.0) / (PI_8_27 * log(a2) * t);\n}\n\nfloat GTR2_8_31(float NdotH, float a) {\n  float a2 = a * a;\n  float t = 1.0 + (a2 - 1.0) * NdotH * NdotH;\n  return a2 / (PI_8_27 * t * t);\n}\n\nfloat GTR2_aniso_8_32(float NdotH, float HdotX, float HdotY, float ax, float ay) {\n  return 1.0 / (\n    PI_8_27 * ax * ay *\n    sqr_8_28(sqr_8_28(HdotX / ax) + sqr_8_28(HdotY / ay) + NdotH * NdotH)\n  );\n}\n\nfloat smithG_GGX_8_33(float Ndotv, float alphaG) {\n  float a = alphaG * alphaG;\n  float b = Ndotv * Ndotv;\n  return 1.0 / (Ndotv + sqrt(a + b - a * b));\n}\n\nvec3 mon2lin_8_34(vec3 x) {\n  return vec3(pow(x[0], 2.2), pow(x[1], 2.2), pow(x[2], 2.2));\n}\n\nvec3 brdf_8_35(\n  vec3 baseColor,\n  float metallic,\n  float subsurface,\n  float specular,\n  float roughness,\n  vec3 L, vec3 V, vec3 N\n) {\n  float NdotL = dot(N, L);\n  float NdotV = dot(N, V);\n\n  vec3 H = normalize(L + V);\n  float NdotH = dot(N, H);\n  float LdotH = dot(L, H);\n\n  vec3 Cdlin = mon2lin_8_34(baseColor);\n  float Cdlum = 0.3 * Cdlin[0] + 0.6 * Cdlin[1]  + 0.1 * Cdlin[2]; // luminance approx.\n\n  vec3 Ctint = Cdlum > 0.0 ? Cdlin / Cdlum : vec3(1.0); // normalize lum. to isolate hue+sat\n  vec3 Cspec0 = mix(specular * .08 * mix(vec3(1.0), Ctint, specularTint_8_21), Cdlin, metallic);\n  vec3 Csheen = mix(vec3(1.0), Ctint, sheenTint_8_24);\n\n  // Diffuse fresnel - go from 1 at normal incidence to .5 at grazing\n  // and mix in diffuse retro-reflection based on roughness\n  float FL = SchlickFresnel_8_29(NdotL), FV = SchlickFresnel_8_29(NdotV);\n  float Fd90 = 0.5 + 2.0 * LdotH * LdotH * roughness;\n  float Fd = mix(1.0, Fd90, FL) * mix(1.0, Fd90, FV);\n\n  // Based on Hanrahan-Krueger brdf approximation of isotropic bssrdf\n  // 1.25 scale is used to (roughly) preserve albedo\n  // Fss90 used to "flatten" retroreflection based on roughness\n  float Fss90 = LdotH * LdotH * roughness;\n  float Fss = mix(1.0, Fss90, FL) * mix(1.0, Fss90, FV);\n  float ss = 1.25 * (Fss * (1.0 / (NdotL + NdotV) - 0.5) + 0.5);\n\n  // specular\n  float Ds = GTR2_8_31(NdotH, max(0.001, sqr_8_28(roughness)));\n  float FH = SchlickFresnel_8_29(LdotH);\n  vec3 Fs = mix(Cspec0, vec3(1.0), FH);\n  float roughg = sqr_8_28(roughness * 0.5 + 0.5);\n  float Gs = smithG_GGX_8_33(NdotL, roughg) * smithG_GGX_8_33(NdotV, roughg);\n\n  // sheen\n  vec3 Fsheen = FH * sheen_8_23 * Csheen;\n\n  // clearcoat (ior = 1.5 -> F0 = 0.04)\n  float Dr = GTR1_8_30(NdotH, mix(0.1, 0.001, clearcoatGloss_8_26));\n  float Fr = mix(0.04, 1.0, FH);\n  float Gr = smithG_GGX_8_33(NdotL, 0.25) * smithG_GGX_8_33(NdotV, 0.25);\n\n  return ((1.0/PI_8_27) * mix(Fd, ss, subsurface) * Cdlin + Fsheen)\n    * (1.0 - metallic) +\n    Gs * Fs * Ds +\n    0.25 * clearcoat_8_25 * Gr * Fr * Dr;\n}\n\n\n\n\nuniform sampler2D topographyMap;\nuniform sampler2D diffuseMap;\nuniform sampler2D landmaskMap;\nuniform sampler2D bordersMap;\nuniform sampler2D lightsMap;\nuniform vec3 lightDirection;\nuniform vec3 eye;\nuniform bool flatProjection;\n\nvarying vec2 vUv;\nvarying vec3 vPosition;\nvarying vec3 vNormal;\n\nvoid main() {\n  vec3 constantLight = vNormal;\n  vec3 V = vNormal;\n\n  float landness = texture2D(landmaskMap, vUv, -0.25).r;\n  float countryBorder = texture2D(bordersMap, vUv, -0.25).r;\n  float elevation = texture2D(topographyMap, vUv).r;\n\n  float steps = 16.0;\n  vec3 diffuseColor = vec3(1.0, 0.75, 0.5) *\n    floor((elevation / 0.9) * steps) / steps;\n\n  if (landness < 0.5) {\n    diffuseColor =vec3(0.25, 0.5, 1.0) *\n    floor((elevation / 0.9) * steps) / steps;\n  }\n\n  // Outline the transition from land to sea\n  diffuseColor = mix(\n    diffuseColor,\n    vec3(0.0, 0.0, 0.5),\n    pow(1.0 - abs(landness - 0.5) * 2.0, 1.0)\n  );\n\n  vec3 N = vNormal;\n  vec3 L = normalize(constantLight);\n  vec3 H = normalize(L + V);\n\n  vec3 color = vec3(0.0);\n  if (dot(vNormal, L) > 0.0) {\n    vec3 lightColor = vec3(20.0);\n\n    color = lightColor * brdf_8_35(\n      diffuseColor,\n      0.0, //metallic\n      0.5, //subsurface\n      0.3, //specular\n      0.99, //roughness\n      L, V, N\n    );\n\n    if (!flatProjection) {\n      color += atmosphere_5_19(\n        dot(vNormal, L),\n        dot(vNormal, normalize(eye - vPosition)),\n        vec3(5.0)\n      );\n    }\n  }\n\n  vec3 shaded = toGamma_11_3(tonemap_3_16(color * 0.5));\n  vec3 final = shaded + countryBorder;\n  gl_FragColor = vec4(final, 1.0);\n}\n';
}),require.register("shaders/functions/atmosphere.glsl",function(n,e,t){t.exports="#define GLSLIFY 1\nvec3 atmosphere(float NdotL, float NdotV, vec3 color) {\n  return (\n    max(pow(NdotL, 2.0), 0.0) *\n    pow(1.0 - NdotV, 12.0)\n  ) * color;\n}\n\n\n"}),require.register("shaders/functions/brdf.glsl",function(n,e,t){t.exports='#define GLSLIFY 1\n/*\nModified from https://github.com/wdas/brdf/blob/master/src/brdfs/disney.brdf\n\nOriginal license notice:\n# Copyright Disney Enterprises, Inc.  All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the "License");\n# you may not use this file except in compliance with the License\n# and the following modification to it: Section 6 Trademarks.\n# deleted and replaced with:\n#\n# 6. Trademarks. This License does not grant permission to use the\n# trade names, trademarks, service marks, or product names of the\n# Licensor and its affiliates, except as required for reproducing\n# the content of the NOTICE file.\n#\n# You may obtain a copy of the License at\n# http://www.apache.org/licenses/LICENSE-2.0\n*/\n\nfloat specularTint = 0.0;\nfloat anisotropic = 0.0;\nfloat sheen = 0.0;\nfloat sheenTint = 0.5;\nfloat clearcoat = 0.0;\nfloat clearcoatGloss = 1.0;\n\nconst float PI = 3.14159265358979323846;\n\nfloat sqr(float x) { return x*x; }\n\nfloat SchlickFresnel(float u) {\n  float m = clamp(1.0 - u, 0.0, 1.0);\n  float m2 = m * m;\n  return m2 * m2 * m; // pow(m, 5)\n}\n\nfloat GTR1(float NdotH, float a) {\n  if (a >= 1.0) return 1.0 / PI;\n  float a2 = a * a;\n  float t = 1.0 + (a2 - 1.0) * NdotH * NdotH;\n  return (a2 - 1.0) / (PI * log(a2) * t);\n}\n\nfloat GTR2(float NdotH, float a) {\n  float a2 = a * a;\n  float t = 1.0 + (a2 - 1.0) * NdotH * NdotH;\n  return a2 / (PI * t * t);\n}\n\nfloat GTR2_aniso(float NdotH, float HdotX, float HdotY, float ax, float ay) {\n  return 1.0 / (\n    PI * ax * ay *\n    sqr(sqr(HdotX / ax) + sqr(HdotY / ay) + NdotH * NdotH)\n  );\n}\n\nfloat smithG_GGX(float Ndotv, float alphaG) {\n  float a = alphaG * alphaG;\n  float b = Ndotv * Ndotv;\n  return 1.0 / (Ndotv + sqrt(a + b - a * b));\n}\n\nvec3 mon2lin(vec3 x) {\n  return vec3(pow(x[0], 2.2), pow(x[1], 2.2), pow(x[2], 2.2));\n}\n\nvec3 brdf(\n  vec3 baseColor,\n  float metallic,\n  float subsurface,\n  float specular,\n  float roughness,\n  vec3 L, vec3 V, vec3 N\n) {\n  float NdotL = dot(N, L);\n  float NdotV = dot(N, V);\n\n  vec3 H = normalize(L + V);\n  float NdotH = dot(N, H);\n  float LdotH = dot(L, H);\n\n  vec3 Cdlin = mon2lin(baseColor);\n  float Cdlum = 0.3 * Cdlin[0] + 0.6 * Cdlin[1]  + 0.1 * Cdlin[2]; // luminance approx.\n\n  vec3 Ctint = Cdlum > 0.0 ? Cdlin / Cdlum : vec3(1.0); // normalize lum. to isolate hue+sat\n  vec3 Cspec0 = mix(specular * .08 * mix(vec3(1.0), Ctint, specularTint), Cdlin, metallic);\n  vec3 Csheen = mix(vec3(1.0), Ctint, sheenTint);\n\n  // Diffuse fresnel - go from 1 at normal incidence to .5 at grazing\n  // and mix in diffuse retro-reflection based on roughness\n  float FL = SchlickFresnel(NdotL), FV = SchlickFresnel(NdotV);\n  float Fd90 = 0.5 + 2.0 * LdotH * LdotH * roughness;\n  float Fd = mix(1.0, Fd90, FL) * mix(1.0, Fd90, FV);\n\n  // Based on Hanrahan-Krueger brdf approximation of isotropic bssrdf\n  // 1.25 scale is used to (roughly) preserve albedo\n  // Fss90 used to "flatten" retroreflection based on roughness\n  float Fss90 = LdotH * LdotH * roughness;\n  float Fss = mix(1.0, Fss90, FL) * mix(1.0, Fss90, FV);\n  float ss = 1.25 * (Fss * (1.0 / (NdotL + NdotV) - 0.5) + 0.5);\n\n  // specular\n  float Ds = GTR2(NdotH, max(0.001, sqr(roughness)));\n  float FH = SchlickFresnel(LdotH);\n  vec3 Fs = mix(Cspec0, vec3(1.0), FH);\n  float roughg = sqr(roughness * 0.5 + 0.5);\n  float Gs = smithG_GGX(NdotL, roughg) * smithG_GGX(NdotV, roughg);\n\n  // sheen\n  vec3 Fsheen = FH * sheen * Csheen;\n\n  // clearcoat (ior = 1.5 -> F0 = 0.04)\n  float Dr = GTR1(NdotH, mix(0.1, 0.001, clearcoatGloss));\n  float Fr = mix(0.04, 1.0, FH);\n  float Gr = smithG_GGX(NdotL, 0.25) * smithG_GGX(NdotV, 0.25);\n\n  return ((1.0/PI) * mix(Fd, ss, subsurface) * Cdlin + Fsheen)\n    * (1.0 - metallic) +\n    Gs * Fs * Ds +\n    0.25 * clearcoat * Gr * Fr * Dr;\n}\n\n\n'}),require.register("shaders/functions/exposure.glsl",function(n,e,t){t.exports="#define GLSLIFY 1\n// Set camera exposure based on angle between sun and eye\n\nfloat exposure(vec3 eye, vec3 L, float low, float high) {\n  return mix(\n    low,\n    high,\n    pow((1.0 - dot(normalize(eye), L)) / 2.0, 10.0)\n  );\n}\n\n\n"}),require.register("shaders/functions/heightDerivative.glsl",function(n,e,t){t.exports="#define GLSLIFY 1\n// Based on:\n// http://stackoverflow.com/questions/13501081/efficient-bicubic-filtering-code-in-glsl\n\nvec4 cubic_1_0(float v) {\n  vec4 n = vec4(1.0, 2.0, 3.0, 4.0) - v;\n  vec4 s = n * n * n;\n  float x = s.x;\n  float y = s.y - 4.0 * s.x;\n  float z = s.z - 4.0 * s.y + 6.0 * s.x;\n  float w = 6.0 - x - y - z;\n  return vec4(x, y, z, w);\n}\n\nvec4 texture2DCubic_1_1(\n  sampler2D tex,\n  vec2 uv,\n  vec2 textureResolution\n) {\n  vec2 texcoord = uv * textureResolution;\n  texcoord -= vec2(0.5);\n  float fx = fract(texcoord.x);\n  float fy = fract(texcoord.y);\n  texcoord.x -= fx;\n  texcoord.y -= fy;\n\n  vec4 xcubic = cubic_1_0(fx);\n  vec4 ycubic = cubic_1_0(fy);\n\n  vec4 c = vec4(\n    texcoord.x - 0.5,\n    texcoord.x + 1.5,\n    texcoord.y - 0.5,\n    texcoord.y + 1.5\n  );\n\n  vec4 s = vec4(\n    xcubic.x + xcubic.y,\n    xcubic.z + xcubic.w,\n    ycubic.x + ycubic.y,\n    ycubic.z + ycubic.w\n  );\n\n  vec4 offset = c + vec4(\n    xcubic.y,\n    xcubic.w,\n    ycubic.y,\n    ycubic.w\n  ) / s;\n\n  vec4 sample0 = texture2D(tex,\n    vec2(offset.x, offset.z) / textureResolution);\n\n  vec4 sample1 = texture2D(tex,\n    vec2(offset.y, offset.z) / textureResolution);\n\n  vec4 sample2 = texture2D(tex,\n    vec2(offset.x, offset.w) / textureResolution);\n\n  vec4 sample3 = texture2D(tex,\n    vec2(offset.y, offset.w) / textureResolution);\n\n  float sx = s.x / (s.x + s.y);\n  float sy = s.z / (s.z + s.w);\n\n  return mix(\n    mix(sample3, sample2, sx),\n    mix(sample1, sample0, sx),\n    sy\n  );\n}\n\n\n\n\n// Based on https://docs.unrealengine.com/latest/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf\n\nvec2 heightDerivative(\n  vec2 texST,\n  sampler2D map,\n  vec2 textureResolution\n) {\n  vec2 TexDx = dFdx(texST);\n  vec2 TexDy = dFdy(texST);\n  vec2 STll = texST;\n  vec2 STlr = texST + TexDx;\n  vec2 STul = texST + TexDy;\n  float Hll = texture2DCubic_1_1(map, STll, textureResolution).x;\n  float Hlr = texture2DCubic_1_1(map, STlr, textureResolution).x;\n  float Hul = texture2DCubic_1_1(map, STul, textureResolution).x;\n  float dBs = Hlr - Hll;\n  float dBt = Hul - Hll;\n  return vec2(dBs, dBt);\n}\n\n\n"}),require.register("shaders/functions/isNan.glsl",function(n,e,t){t.exports="#define GLSLIFY 1\n// Hack isNan for debugging since WebGL doesn't define it\n\nbool isNan(float val) {\n  return (val <= 0.0 || 0.0 <= val) ? false : true;\n}\n\n\n"}),require.register("shaders/functions/nightAmbient.glsl",function(n,e,t){t.exports="#define GLSLIFY 1\nvec3 nightAmbient(\n  float NdotL,\n  vec3 diffuseColor,\n  float nightLightAmount,\n  vec2 vUv\n) {\n  return 0.01 * (\n    nightLightAmount * vec3(1.0, 1.0, 0.8) +\n    0.1 * vec3(0.1, 0.1, 1.0) * diffuseColor\n  ) * clamp((-NdotL + 0.01) * 2.0, 0.0, 1.0);\n}\n\n\n"}),require.register("shaders/functions/perturbNormal.glsl",function(n,e,t){t.exports="#define GLSLIFY 1\n// Based on https://docs.unrealengine.com/latest/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf\n\nvec3 perturbNormal(vec3 surf_pos, vec3 surf_norm, vec2 dHdxy) {\n  // Calling derivatives per-component to address android bug:\n  // http://stackoverflow.com/questions/20272272/\n  vec3 vSigmaX = vec3(dFdx(surf_pos.x), dFdx(surf_pos.y), dFdx(surf_pos.z));\n  vec3 vSigmaY = vec3(dFdy(surf_pos.x), dFdy(surf_pos.y), dFdy(surf_pos.z));\n  vec3 vN = vec3(normalize(surf_norm)); // normalized\n  vec3 R1 = cross(vSigmaY, vN);\n  vec3 R2 = cross(vN, vSigmaX);\n\n  float fDet = dot(vSigmaX, R1);\n  vec3 vGrad = sign(fDet) * (dHdxy.x * R1 + dHdxy.y * R2);\n  return normalize(abs(fDet) * surf_norm - vGrad);\n}\n\n\n"}),require.register("shaders/functions/terrainBumpScale.glsl",function(n,e,t){t.exports="#define GLSLIFY 1\n// Scale bump map effect to produce relatively even relief\n// shading across surface. Goal is to avoid too much shading\n// at glancing angles and too little shading in the center.\n//\n// Also, allow for an additional bump scale factor with\n// `oceanFactor`. This allows ocean floor rendering to show\n// full bumps vs ocean surface rendering being flat.\n\nfloat terrainBumpScale(\n  float landness,\n  float oceanFactor,\n  float vNdotL,\n  float vNdotV,\n  vec3 vEye,\n  vec3 vPosition\n) {\n  float shadowStart = 0.25;\n  float bumpFalloff = clamp(vNdotL / shadowStart, 0.0, 0.5);\n\n  float bumpScale = mix(\n    0.005,\n    0.05,\n    vNdotL * vNdotL * vNdotV\n  ) * bumpFalloff;\n\n  if (landness < 0.5) {\n    bumpScale *= -oceanFactor;\n  }\n\n  return bumpScale;\n}\n\n\n"}),require.register("shaders/functions/texture2DCubic.glsl",function(n,e,t){t.exports="#define GLSLIFY 1\n// Based on:\n// http://stackoverflow.com/questions/13501081/efficient-bicubic-filtering-code-in-glsl\n\nvec4 cubic(float v) {\n  vec4 n = vec4(1.0, 2.0, 3.0, 4.0) - v;\n  vec4 s = n * n * n;\n  float x = s.x;\n  float y = s.y - 4.0 * s.x;\n  float z = s.z - 4.0 * s.y + 6.0 * s.x;\n  float w = 6.0 - x - y - z;\n  return vec4(x, y, z, w);\n}\n\nvec4 texture2DCubic(\n  sampler2D tex,\n  vec2 uv,\n  vec2 textureResolution\n) {\n  vec2 texcoord = uv * textureResolution;\n  texcoord -= vec2(0.5);\n  float fx = fract(texcoord.x);\n  float fy = fract(texcoord.y);\n  texcoord.x -= fx;\n  texcoord.y -= fy;\n\n  vec4 xcubic = cubic(fx);\n  vec4 ycubic = cubic(fy);\n\n  vec4 c = vec4(\n    texcoord.x - 0.5,\n    texcoord.x + 1.5,\n    texcoord.y - 0.5,\n    texcoord.y + 1.5\n  );\n\n  vec4 s = vec4(\n    xcubic.x + xcubic.y,\n    xcubic.z + xcubic.w,\n    ycubic.x + ycubic.y,\n    ycubic.z + ycubic.w\n  );\n\n  vec4 offset = c + vec4(\n    xcubic.y,\n    xcubic.w,\n    ycubic.y,\n    ycubic.w\n  ) / s;\n\n  vec4 sample0 = texture2D(tex,\n    vec2(offset.x, offset.z) / textureResolution);\n\n  vec4 sample1 = texture2D(tex,\n    vec2(offset.y, offset.z) / textureResolution);\n\n  vec4 sample2 = texture2D(tex,\n    vec2(offset.x, offset.w) / textureResolution);\n\n  vec4 sample3 = texture2D(tex,\n    vec2(offset.y, offset.w) / textureResolution);\n\n  float sx = s.x / (s.x + s.y);\n  float sy = s.z / (s.z + s.w);\n\n  return mix(\n    mix(sample3, sample2, sx),\n    mix(sample1, sample0, sx),\n    sy\n  );\n}\n\n\n"}),require.register("shaders/functions/tonemap.glsl",function(n,e,t){t.exports="#define GLSLIFY 1\n// Based on https://github.com/vorg/pragmatic-pbr/blob/master/local_modules/glsl-tonemap-uncharted2/index.glsl\nfloat A = 0.15;\nfloat B = 0.50;\nfloat C = 0.10;\nfloat D = 0.20;\nfloat E = 0.02;\nfloat F = 0.30;\nfloat W = 11.2;\n\nvec3 Uncharted2Tonemap(vec3 x) {\n   return ((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - E / F;\n}\n\n// Based on Filmic Tonemapping Operators http://filmicgames.com/archives/75\nvec3 tonemap(vec3 color) {\n    float ExposureBias = 2.0;\n    vec3 curr = Uncharted2Tonemap(ExposureBias * color);\n\n    vec3 whiteScale = 1.0 / Uncharted2Tonemap(vec3(W));\n    return curr * whiteScale;\n}\n\n\n"}),require.register("shaders/night.frag.glsl",function(n,e,t){t.exports="#extension GL_OES_standard_derivatives : enable\nprecision highp float;\n#define GLSLIFY 1\n\nconst float gamma_5_0 = 2.2;\n\nfloat toLinear_5_1(float v) {\n  return pow(v, gamma_5_0);\n}\n\nvec2 toLinear_5_1(vec2 v) {\n  return pow(v, vec2(gamma_5_0));\n}\n\nvec3 toLinear_5_1(vec3 v) {\n  return pow(v, vec3(gamma_5_0));\n}\n\nvec4 toLinear_5_1(vec4 v) {\n  return vec4(toLinear_5_1(v.rgb), v.a);\n}\n\n\n\nconst float gamma_6_2 = 2.2;\n\nfloat toGamma_6_3(float v) {\n  return pow(v, 1.0 / gamma_6_2);\n}\n\nvec2 toGamma_6_3(vec2 v) {\n  return pow(v, vec2(1.0 / gamma_6_2));\n}\n\nvec3 toGamma_6_3(vec3 v) {\n  return pow(v, vec3(1.0 / gamma_6_2));\n}\n\nvec4 toGamma_6_3(vec4 v) {\n  return vec4(toGamma_6_3(v.rgb), v.a);\n}\n\n\n\n// Based on https://github.com/vorg/pragmatic-pbr/blob/master/local_modules/glsl-tonemap-uncharted2/index.glsl\nfloat A_1_4 = 0.15;\nfloat B_1_5 = 0.50;\nfloat C_1_6 = 0.10;\nfloat D_1_7 = 0.20;\nfloat E_1_8 = 0.02;\nfloat F_1_9 = 0.30;\nfloat W_1_10 = 11.2;\n\nvec3 Uncharted2Tonemap_1_11(vec3 x) {\n   return ((x * (A_1_4 * x + C_1_6 * B_1_5) + D_1_7 * E_1_8) / (x * (A_1_4 * x + B_1_5) + D_1_7 * F_1_9)) - E_1_8 / F_1_9;\n}\n\n// Based on Filmic Tonemapping Operators http://filmicgames.com/archives/75\nvec3 tonemap_1_12(vec3 color) {\n    float ExposureBias = 2.0;\n    vec3 curr = Uncharted2Tonemap_1_11(ExposureBias * color);\n\n    vec3 whiteScale = 1.0 / Uncharted2Tonemap_1_11(vec3(W_1_10));\n    return curr * whiteScale;\n}\n\n\n\n// Set camera exposure based on angle between sun and eye\n\nfloat exposure_2_13(vec3 eye, vec3 L, float low, float high) {\n  return mix(\n    low,\n    high,\n    pow((1.0 - dot(normalize(eye), L)) / 2.0, 10.0)\n  );\n}\n\n\n\nvec3 nightAmbient_3_14(\n  float NdotL,\n  vec3 diffuseColor,\n  float nightLightAmount,\n  vec2 vUv\n) {\n  return 0.01 * (\n    nightLightAmount * vec3(1.0, 1.0, 0.8) +\n    0.1 * vec3(0.1, 0.1, 1.0) * diffuseColor\n  ) * clamp((-NdotL + 0.01) * 2.0, 0.0, 1.0);\n}\n\n\n\n// Based on:\n// http://stackoverflow.com/questions/13501081/efficient-bicubic-filtering-code-in-glsl\n\nvec4 cubic_4_15(float v) {\n  vec4 n = vec4(1.0, 2.0, 3.0, 4.0) - v;\n  vec4 s = n * n * n;\n  float x = s.x;\n  float y = s.y - 4.0 * s.x;\n  float z = s.z - 4.0 * s.y + 6.0 * s.x;\n  float w = 6.0 - x - y - z;\n  return vec4(x, y, z, w);\n}\n\nvec4 texture2DCubic_4_16(\n  sampler2D tex,\n  vec2 uv,\n  vec2 textureResolution\n) {\n  vec2 texcoord = uv * textureResolution;\n  texcoord -= vec2(0.5);\n  float fx = fract(texcoord.x);\n  float fy = fract(texcoord.y);\n  texcoord.x -= fx;\n  texcoord.y -= fy;\n\n  vec4 xcubic = cubic_4_15(fx);\n  vec4 ycubic = cubic_4_15(fy);\n\n  vec4 c = vec4(\n    texcoord.x - 0.5,\n    texcoord.x + 1.5,\n    texcoord.y - 0.5,\n    texcoord.y + 1.5\n  );\n\n  vec4 s = vec4(\n    xcubic.x + xcubic.y,\n    xcubic.z + xcubic.w,\n    ycubic.x + ycubic.y,\n    ycubic.z + ycubic.w\n  );\n\n  vec4 offset = c + vec4(\n    xcubic.y,\n    xcubic.w,\n    ycubic.y,\n    ycubic.w\n  ) / s;\n\n  vec4 sample0 = texture2D(tex,\n    vec2(offset.x, offset.z) / textureResolution);\n\n  vec4 sample1 = texture2D(tex,\n    vec2(offset.y, offset.z) / textureResolution);\n\n  vec4 sample2 = texture2D(tex,\n    vec2(offset.x, offset.w) / textureResolution);\n\n  vec4 sample3 = texture2D(tex,\n    vec2(offset.y, offset.w) / textureResolution);\n\n  float sx = s.x / (s.x + s.y);\n  float sy = s.z / (s.z + s.w);\n\n  return mix(\n    mix(sample3, sample2, sx),\n    mix(sample1, sample0, sx),\n    sy\n  );\n}\n\n\n\n\nuniform sampler2D topographyMap;\nuniform sampler2D diffuseMap;\nuniform sampler2D landmaskMap;\nuniform sampler2D bordersMap;\nuniform vec2 bordersMapSize;\nuniform sampler2D lightsMap;\nuniform vec3 eye;\n\nvarying vec2 vUv;\nvarying vec3 vPosition;\nvarying vec3 vNormal;\n\nvoid main() {\n  float landness = texture2D(landmaskMap, vUv, -0.25).r;\n  float countryBorder = texture2DCubic_4_16(\n    bordersMap,\n    vUv,\n    bordersMapSize\n  ).r;\n\n  float oceanDepth = (0.5 - texture2D(topographyMap, vUv).r) * 2.0;\n\n  vec3 oceanColor = mix(\n    vec3(0.0, 0.0, 0.3),\n    vec3(0.0, 0.0, 0.35),\n    oceanDepth\n  );\n\n  vec3 diffuseColor = mix(\n    oceanColor,\n    toLinear_5_1(texture2D(diffuseMap, vUv).rgb),\n    landness\n  );\n\n  vec3 color = nightAmbient_3_14(\n    -1.0,\n    diffuseColor,\n    texture2D(lightsMap, vUv).x,\n    vUv\n  );\n\n  vec3 shaded = toGamma_6_3(tonemap_1_12(color * 200.0));\n  vec3 final = shaded + countryBorder;\n  gl_FragColor = vec4(final, 1.0);\n}\n"}),require.register("shaders/plane.vert.glsl",function(n,e,t){t.exports="precision highp float;\n#define GLSLIFY 1\n\nfloat transpose_1_0(float m) {\n  return m;\n}\n\nmat2 transpose_1_0(mat2 m) {\n  return mat2(m[0][0], m[1][0],\n              m[0][1], m[1][1]);\n}\n\nmat3 transpose_1_0(mat3 m) {\n  return mat3(m[0][0], m[1][0], m[2][0],\n              m[0][1], m[1][1], m[2][1],\n              m[0][2], m[1][2], m[2][2]);\n}\n\nmat4 transpose_1_0(mat4 m) {\n  return mat4(m[0][0], m[1][0], m[2][0], m[3][0],\n              m[0][1], m[1][1], m[2][1], m[3][1],\n              m[0][2], m[1][2], m[2][2], m[3][2],\n              m[0][3], m[1][3], m[2][3], m[3][3]);\n}\n\n\nfloat inverse_2_1(float m) {\n  return 1.0 / m;\n}\n\nmat2 inverse_2_1(mat2 m) {\n  return mat2(m[1][1],-m[0][1],\n             -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\n\nmat3 inverse_2_1(mat3 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nmat4 inverse_2_1(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\n\n\nattribute vec3 position;\nattribute vec2 texcoord;\nattribute float elevation;\n\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 projection;\n\nuniform float oceanElevationScale;\nuniform float landElevationScale;\n\nvarying vec2 vUv;\nvarying vec3 vPosition;\nvarying vec3 vSpherePosition;\nvarying vec3 vNormal;\n\nconst float PI = 3.141592653589793;\n\nvoid main(void) {\n  mat4 modelView = view * model;\n  vUv = texcoord;\n\n  float scale;\n  if (elevation > 0.0) {\n    scale = elevation * landElevationScale;\n  }\n  else {\n    scale = elevation * oceanElevationScale;\n  }\n\n  vec3 planePosition = vec3(position.x, scale, position.z);\n\n  float x = planePosition.x * PI;\n  float z = planePosition.z * PI * 0.999;\n\n  vec3 spherePosition = vec3(sin(x) * cos(z), sin(z), cos(x) * cos(z));\n\n  gl_Position = projection * modelView * vec4(planePosition, 1.0);\n  vPosition = vec3(model * vec4(planePosition, 1.0));\n\n  mat3 normalMatrix = transpose_1_0(inverse_2_1(mat3(model)));\n  vSpherePosition = spherePosition;\n  vNormal = normalize(normalMatrix * spherePosition);\n}\n"}),require.register("shaders/sphere.vert.glsl",function(n,e,t){t.exports="precision highp float;\n#define GLSLIFY 1\n\nfloat transpose_1_0(float m) {\n  return m;\n}\n\nmat2 transpose_1_0(mat2 m) {\n  return mat2(m[0][0], m[1][0],\n              m[0][1], m[1][1]);\n}\n\nmat3 transpose_1_0(mat3 m) {\n  return mat3(m[0][0], m[1][0], m[2][0],\n              m[0][1], m[1][1], m[2][1],\n              m[0][2], m[1][2], m[2][2]);\n}\n\nmat4 transpose_1_0(mat4 m) {\n  return mat4(m[0][0], m[1][0], m[2][0], m[3][0],\n              m[0][1], m[1][1], m[2][1], m[3][1],\n              m[0][2], m[1][2], m[2][2], m[3][2],\n              m[0][3], m[1][3], m[2][3], m[3][3]);\n}\n\n\nfloat inverse_2_1(float m) {\n  return 1.0 / m;\n}\n\nmat2 inverse_2_1(mat2 m) {\n  return mat2(m[1][1],-m[0][1],\n             -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\n\nmat3 inverse_2_1(mat3 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nmat4 inverse_2_1(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\n\n\nattribute vec3 position;\nattribute vec2 texcoord;\nattribute float elevation;\n\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 projection;\n\nuniform float oceanElevationScale;\nuniform float landElevationScale;\n\nvarying vec2 vUv;\nvarying vec3 vPosition;\nvarying vec3 vNormal;\n\nvoid main(void) {\n  mat4 modelView = view * model;\n  vUv = texcoord;\n\n  float scale = 1.0;\n  if (elevation > 0.0) {\n    scale += elevation * landElevationScale;\n  }\n  else {\n    scale += elevation * oceanElevationScale;\n  }\n\n  vec3 spherePosition = scale * position;\n\n  gl_Position = projection * modelView * vec4(spherePosition, 1.0);\n  vPosition = vec3(model * vec4(spherePosition, 1.0));\n\n  mat3 normalMatrix = transpose_1_0(inverse_2_1(mat3(model)));\n  vNormal = normalize(normalMatrix * spherePosition);\n}\n"}),require.alias("buffer/index.js","buffer"),require.alias("process/browser.js","process"),n=require("process"),require.register("___globals___",function(n,e,t){})}(),require("___globals___");