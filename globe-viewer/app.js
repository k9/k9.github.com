!function(){"use strict";var n="undefined"==typeof window?global:window;if("function"!=typeof n.require){var e={},t={},a={},o={}.hasOwnProperty,r=/^\.\.?(\/|$)/,s=function(n,e){for(var t,a=[],o=(r.test(e)?n+"/"+e:e).split("/"),s=0,i=o.length;s<i;s++)t=o[s],".."===t?a.pop():"."!==t&&""!==t&&a.push(t);return a.join("/")},i=function(n){return n.split("/").slice(0,-1).join("/")},l=function(e){return function(t){var a=s(i(e),t);return n.require(a,e)}},c=function(n,e){var a=null;a=p&&p.createHot(n);var o={id:n,exports:{},hot:a};return t[n]=o,e(o.exports,l(n),o),o.exports},d=function(n){return a[n]?d(a[n]):n},f=function(n,e){return d(s(i(n),e))},u=function(n,a){null==a&&(a="/");var r=d(n);if(o.call(t,r))return t[r].exports;if(o.call(e,r))return c(r,e[r]);throw new Error("Cannot find module '"+n+"' from '"+a+"'")};u.alias=function(n,e){a[e]=n};var m=/\.[^.\/]+$/,v=/\/index(\.[^\/]+)?$/,_=function(n){if(m.test(n)){var e=n.replace(m,"");o.call(a,e)&&a[e].replace(m,"")!==e+"/index"||(a[e]=n)}if(v.test(n)){var t=n.replace(v,"");o.call(a,t)||(a[t]=n)}};u.register=u.define=function(n,a){if("object"==typeof n)for(var r in n)o.call(n,r)&&u.register(r,n[r]);else e[n]=a,delete t[n],_(n)},u.list=function(){var n=[];for(var t in e)o.call(e,t)&&n.push(t);return n};var p=n._hmr&&new n._hmr(f,u,e,t);u._cache=t,u.hmr=p&&p.wrap,u.brunch=!0,n.require=u}}(),function(){var n;window;require.register("initialize.js",function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{"default":n}}var o=e("twgl.js"),r=a(o),s=e("js/controller"),i=a(s);document.addEventListener("DOMContentLoaded",function(){var n=r["default"].getWebGLContext(document.querySelector(".map-canvas canvas"));new i["default"](n)})}),require.register("js/camera.js",function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{"default":n}}function o(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(n,"__esModule",{value:!0});var r=function(){function n(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}return function(e,t,a){return t&&n(e.prototype,t),a&&n(e,a),e}}(),s=e("lodash"),i=a(s),l=e("hammerjs"),c=(a(l),e("twgl.js")),d=a(c),f=e("./controlRange"),u=a(f),m=e("./utils"),v=d["default"].m4,_=function(){function n(e){var t=this;o(this,n),this.gl=e,this.fov=50,this.longitude=new u["default"](0,(-180),180,(!0)),this.latitude=new u["default"](0,(-90),90),this.zoom=new u["default"](.5,0,1),this.dragging=!1,this.dragStart=void 0,this.mousePosition=void 0,this.hammer=new Hammer(e.canvas),this.hammer.get("pinch").set({enable:!0}),document.addEventListener("mousemove",function(n){t.handleMouseMove(n)}),e.canvas.addEventListener("mousedown",function(){t.dragging=!0}),document.addEventListener("selectstart",function(n){t.dragging===!0&&n.preventDefault()}),document.addEventListener("mouseup",function(){t.dragging=!1}),e.canvas.addEventListener("scroll",function(){return!1}),this.hammer.on("pan",function(n){return"mouse"!=n.pointerType&&t.handlePan(8*n.velocityX,8*n.velocityY),!1}),this.hammer.on("pinchstart",function(n){t.lastZoom=t.zoom.value,t.pinching=!0}),this.hammer.on("pinchend",function(n){t.pinching=!1}),this.hammer.on("pinch",function(n){t.pinching&&t.zoom.changeTo(t.lastZoom+.5*(n.scale-1))}),window.addEventListener("wheel",function(n){var a=.001*-n.deltaY;1===n.mozInputSource&&(a*=50),n.target==e.canvas&&(t.zoom.changeBy(a),n.preventDefault())})}return r(n,[{key:"handleMouseMove",value:function(n){var e={x:n.screenX,y:n.screenY};if(void 0!==this.mousePosition&&this.dragging){var t=e.x-this.mousePosition.x,a=e.y-this.mousePosition.y;this.handlePan(.3*t,.3*a),n.stopPropagation()}this.mousePosition=e}},{key:"handlePan",value:function(n,e){var t=1-.8*this.zoom.value;this.longitude.changeBy(n*t),this.latitude.changeBy(e*t)}},{key:"getRenderValues",value:function(n){var e=n.canvas.clientWidth/n.canvas.clientHeight,t=(0,m.toRadians)(30)/i["default"].clamp(e,0,1),a=v.perspective(t,e,.01,10),o=[0,0,-(4.5-3*this.zoom.value)],r=v.identity();v.rotateY(r,-(0,m.toRadians)(this.longitude.value-90),r),v.rotateX(r,(0,m.toRadians)(this.latitude.value),r),o=v.transformPoint(r,o);var s=v.transformPoint(r,[0,1,0]),l=[0,0,0],c=v.inverse(v.lookAt(o,l,s));return{view:c,projection:a,eye:o}}}]),n}();n["default"]=_}),require.register("js/components/debugPanel.js",function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{"default":n}}function o(n){s["default"].component("debug-panel",s["default"].extend({data:function(){return n},computed:{formattedFps:function(){return numeral(this.fps).format("0.00")}},template:'\n      <div class="debug-panel">\n        <div class="top-row">\n          <label>FPS</label>\n          <span>{{formattedFps}}</span>\n        </div>\n      </div>\n    '}))}Object.defineProperty(n,"__esModule",{value:!0}),n["default"]=o;var r=e("vue"),s=a(r)}),require.register("js/components/rangeSlider.js",function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{"default":n}}function o(n,e){s["default"].component("range-slider",s["default"].extend({data:function(){return e[this.property].data},computed:{formatted:function(){return e[this.property].formatted(this)}},props:["label","property"],template:"\n      <div class=\"range-slider range-control\">\n        <div class=\"top-row\">\n          <label>{{label}}</label>\n          <span>{{formatted}}</span>\n        </div>\n        <div class=\"slider\">\n          <input type='range'\n            min='{{min}}'\n            max='{{max}}'\n            property='{{property}}'\n            step=\"any\"\n            v-model='value'>\n        </div>\n      </div>\n    ",watch:{$data:{handler:function(){n.updated()},deep:!0}}}))}Object.defineProperty(n,"__esModule",{value:!0}),n["default"]=o;var r=e("vue"),s=a(r)}),require.register("js/components/renderModes.js",function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{"default":n}}function o(n,e){s["default"].component("render-modes",s["default"].extend({data:function(){return e},computed:{},props:[],template:'\n      <div class="render-modes">\n        <div class="top-row">\n          <label>Mode</label>\n        </div>\n        <div class="radio-buttons">\n          <div class="radio-button"\n            v-bind:class="{ active: renderMode == \'dayAndNight\' }">\n            <label>\n              <input type="radio" name="render-mode"\n                value="dayAndNight" v-model="renderMode"\n                checked>\n              Day and Night\n            </label>\n            <div v-if="renderMode == \'dayAndNight\'" class="sub-group">\n              <range-slider\n                label="Hour of Day"\n                property="hourOfDay">\n              </range-slider>\n              <range-slider\n                label="Day of Year"\n                property="dayOfYear">\n              </range-slider>\n            </div>\n          </div>\n          <div class="radio-button"\n            v-bind:class="{ active: renderMode == \'day\' }">\n            <label>\n              <input type="radio" name="render-mode"\n                value="day" v-model="renderMode">\n              Day\n            </label>\n          </div>\n          <div class="radio-button"\n            v-bind:class="{ active: renderMode == \'night\' }">\n            <label>\n              <input type="radio" name="render-mode"\n                value="night" v-model="renderMode">\n              Night\n            </label>\n          </div>\n          <div class="radio-button"\n            v-bind:class="{ active: renderMode == \'elevation\' }">\n            <label>\n              <input type="radio" name="render-mode"\n                value="elevation" v-model="renderMode">\n              Elevation\n            </label>\n          </div>\n        </div>\n      </div>\n    ',watch:{$data:{handler:function(){n.updated()},deep:!0}}}))}Object.defineProperty(n,"__esModule",{value:!0}),n["default"]=o;var r=e("vue"),s=a(r)}),require.register("js/controlRange.js",function(n,e,t){"use strict";function a(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(n,"__esModule",{value:!0});var o=function(){function n(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}return function(e,t,a){return t&&n(e.prototype,t),a&&n(e,a),e}}(),r=function(){function n(e,t,o){var r=!(arguments.length<=3||void 0===arguments[3])&&arguments[3];a(this,n),this.value=e,this.min=t,this.max=o,this.wrap=r}return o(n,[{key:"changeBy",value:function(n){this.changeTo(this.value+n)}},{key:"changeTo",value:function(n){this.wrap?this.setWrap(n):this.setClamp(n)}},{key:"setClamp",value:function(n){this.value=_.clamp(n,this.min,this.max)}},{key:"setWrap",value:function(n){if(n>this.max){var e=n%this.max;n=this.min+e}else n<this.min&&(n=this.max-(this.min-n));this.value=n}}]),n}();n["default"]=r}),require.register("js/controller.js",function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{"default":n}}function o(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(n,"__esModule",{value:!0});var r=function(){function n(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}return function(e,t,a){return t&&n(e.prototype,t),a&&n(e,a),e}}(),s=e("vue"),i=a(s),l=e("moment"),c=(a(l),e("numeral")),d=a(c),f=e("./scene"),u=a(f),m=e("./renderer"),v=a(m),_=e("./camera"),p=a(_),h=e("./performanceStats"),g=a(h),b=e("./components/rangeSlider"),x=a(b),L=e("./components/renderModes"),y=a(L),N=e("./components/debugPanel"),F=a(N),w=function(){function n(e){var t=this;o(this,n),this.scene=new u["default"](e),this.renderer=new v["default"](e,this.scene),this.camera=new p["default"](e),this.performanceStats=new g["default"];var a=function(){return""},r=function(n){return(0,d["default"])(n.value).format("0.00")+"Â°"},s=function(){return t.scene.calculatedMoment().format("h:mm a")+" UTC"},l=function(){return t.scene.calculatedMoment().format("YYYY-MM-DD")},c={latitude:{data:this.camera.latitude,formatted:r},longitude:{data:this.camera.longitude,formatted:r},zoom:{data:this.camera.zoom,formatted:a},hourOfDay:{data:this.scene.hourOfDay,formatted:s},dayOfYear:{data:this.scene.dayOfYear,formatted:l}};(0,x["default"])(this,c),(0,y["default"])(this,this.scene),(0,F["default"])(this.performanceStats),this.vue=new i["default"]({el:".map-container"}),this.updateQueued=!1,this.updated(),window.addEventListener("resize",function(){t.updated()}),window.addEventListener("texture-loaded",function(){t.updated()})}return r(n,[{key:"updated",value:function(){var n=this;this.updateQueued||(this.updateQueued=!0,window.requestAnimationFrame(function(){n.renderFrame(),n.updateQueued=!1}))}},{key:"renderFrame",value:function(){this.renderer.render(window.performance.now(),this.scene,this.camera,this.renderer),this.performanceStats.countFrame()}}]),n}();n["default"]=w}),require.register("js/coordinates.js",function(n,e,t){"use strict";function a(n){return n/1e3/86400+2440587.5}function o(n){var e=a(n)-2451545,t=357.529+.98560028*e,o=280.459+.98564736*e,s=o+1.915*Math.sin((0,r.toRadians)(t))+.02*Math.sin((0,r.toRadians)(2*t)),i=23.439-3.6e-7*e,l=Math.cos((0,r.toRadians)(i))*Math.sin((0,r.toRadians)(s)),c=Math.cos((0,r.toRadians)(s)),d=Math.atan2(l,c),f=Math.asin(Math.sin((0,r.toRadians)(i))*Math.sin((0,r.toRadians)(s))),u=18.697374558+24.06570982441908*e,m=u/24*Math.PI*2-d;return{hourAngle:m,declination:f}}Object.defineProperty(n,"__esModule",{value:!0}),n["default"]=o;var r=e("./utils")}),require.register("js/performanceStats.js",function(n,e,t){"use strict";function a(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(n,"__esModule",{value:!0});var o=function(){function n(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}return function(e,t,a){return t&&n(e.prototype,t),a&&n(e,a),e}}(),r=function(){function n(){a(this,n),this.fps=0,this.frames=0,this.totalFrames=0,this.updated=0}return o(n,[{key:"countFrame",value:function(){var n=window.performance.now();this.frames+=1,this.totalFrames+=1,n-this.updated>200&&(this.fps=this.frames/(n-this.updated)*1e3,this.updated=n,this.frames=0)}}]),n}();n["default"]=r}),require.register("js/renderer.js",function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{"default":n}}function o(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(n,"__esModule",{value:!0});var r=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(n[a]=t[a])}return n},s=function(){function n(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}return function(e,t,a){return t&&n(e.prototype,t),a&&n(e,a),e}}(),i=e("twgl.js"),l=a(i),c=e("../shaders/globe.vert.glsl"),d=a(c),f=e("../shaders/dayAndNight.frag.glsl"),u=a(f),m=e("../shaders/day.frag.glsl"),v=a(m),_=e("../shaders/night.frag.glsl"),p=a(_),h=e("../shaders/elevation.frag.glsl"),g=a(h),b=l["default"].m4,x=function(){function n(e,t){o(this,n),this.gl=e,e.clearColor(0,0,0,0),this.derivatives=e.getExtension("OES_standard_derivatives"),this.anisotropic=e.getExtension("EXT_texture_filter_anisotropic"),this.uniforms={};for(name in t.textures){var a=t.textures[name];this.setupGlobeTexture(e,a),this.uniforms[name]=a}this.programs={dayAndNight:l["default"].createProgramInfo(e,[d["default"],u["default"]]),day:l["default"].createProgramInfo(e,[d["default"],v["default"]]),night:l["default"].createProgramInfo(e,[d["default"],p["default"]]),elevation:l["default"].createProgramInfo(e,[d["default"],g["default"]])},e.enable(e.DEPTH_TEST),e.enable(e.CULL_FACE)}return s(n,[{key:"setupGlobeTexture",value:function(n,e){n.bindTexture(n.TEXTURE_2D,e),this.anisotropic&&n.texParameterf(n.TEXTURE_2D,this.anisotropic.TEXTURE_MAX_ANISOTROPY_EXT,16),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.REPEAT),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.LINEAR_MIPMAP_LINEAR)}},{key:"render",value:function(n,e,t){var a=this.gl;this.updateCanvasSize(a),a.clear(a.COLOR_BUFFER_BIT|a.DEPTH_BUFFER_BIT);var o=b.identity(),s=e.getSunVector();r(this.uniforms,t.getRenderValues(a),{model:o,time:n,lightDirection:b.transformPoint(s,[-1,0,0])});var i=this.programs[e.renderMode];a.useProgram(i.program),l["default"].setBuffersAndAttributes(a,i,e.globeBuffer),l["default"].setUniforms(i,this.uniforms),a.drawElements(a.TRIANGLES,e.globeBuffer.numElements,a.UNSIGNED_SHORT,0)}},{key:"updateCanvasSize",value:function(n){var e=n.canvas.parentNode.offsetWidth,t=n.canvas.parentNode.offsetHeight;if(e+"px"!=n.canvas.style.width||t+"px"!=n.canvas.style.height){n.canvas.style.width=e+"px",n.canvas.style.height=t+"px";var a=window.devicePixelRatio||1;n.canvas.width=Math.floor(e*a),n.canvas.height=Math.floor(t*a),n.viewport(0,0,n.canvas.width,n.canvas.height)}}}]),n}();n["default"]=x}),require.register("js/scene.js",function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{"default":n}}function o(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(n,"__esModule",{value:!0});var r=function(){function n(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}return function(e,t,a){return t&&n(e.prototype,t),a&&n(e,a),e}}(),s=e("twgl.js"),i=a(s),l=e("moment"),c=a(l),d=e("./coordinates.js"),f=a(d),u=i["default"].m4,m=function(){function n(e){o(this,n),this.hourOfDay={value:12,min:.001,max:23.999},this.dayOfYear={value:182,min:1,max:365},this.globeBuffer=i["default"].primitives.createSphereBufferInfo(e,1,75,75),this.renderMode="dayAndNight",this.textures=i["default"].createTextures(e,{diffuseMap:{format:e.RGB,internalFormat:e.RGB,type:e.UNSIGNED_SHORT_5_6_5,src:"data/color-4096.jpg"},topographyMap:{format:e.LUMINANCE,internalFormat:e.LUMINANCE,src:"data/topo-bathy-4096.jpg"},landmaskMap:{src:"data/landmask-4096.png",format:e.LUMINANCE,internalFormat:e.LUMINANCE},lightsMap:{src:"data/lights-4096.png",format:e.LUMINANCE,internalFormat:e.LUMINANCE}},function(){window.dispatchEvent(new Event("texture-loaded"))})}return r(n,[{key:"calculatedMoment",value:function(){return(0,c["default"])("2016-01-01T00:00:00.000Z").utcOffset(0).dayOfYear(this.dayOfYear.value).add(60*this.hourOfDay.value*60,"seconds")}},{key:"getSunVector",value:function(){var n=this.calculatedMoment(),e=(0,f["default"])(_.toInteger(n.format("x"))),t=u.identity();return t=u.rotateY(t,-e.hourAngle),t=u.rotateZ(t,-e.declination)}}]),n}();n["default"]=m}),require.register("js/utils.js",function(n,e,t){"use strict";function a(n){return n/180*Math.PI}Object.defineProperty(n,"__esModule",{value:!0}),n.toRadians=a}),require.register("shaders/day.frag.glsl",function(n,e,t){t.exports='#extension GL_OES_standard_derivatives : enable\nprecision highp float;\n#define GLSLIFY 1\n\nconst float gamma_5_0 = 2.2;\n\nfloat toLinear_5_1(float v) {\n  return pow(v, gamma_5_0);\n}\n\nvec2 toLinear_5_1(vec2 v) {\n  return pow(v, vec2(gamma_5_0));\n}\n\nvec3 toLinear_5_1(vec3 v) {\n  return pow(v, vec3(gamma_5_0));\n}\n\nvec4 toLinear_5_1(vec4 v) {\n  return vec4(toLinear_5_1(v.rgb), v.a);\n}\n\n\n\nconst float gamma_4_2 = 2.2;\n\nfloat toGamma_4_3(float v) {\n  return pow(v, 1.0 / gamma_4_2);\n}\n\nvec2 toGamma_4_3(vec2 v) {\n  return pow(v, vec2(1.0 / gamma_4_2));\n}\n\nvec3 toGamma_4_3(vec3 v) {\n  return pow(v, vec3(1.0 / gamma_4_2));\n}\n\nvec4 toGamma_4_3(vec4 v) {\n  return vec4(toGamma_4_3(v.rgb), v.a);\n}\n\n\n\n// Based on https://github.com/vorg/pragmatic-pbr/blob/master/local_modules/glsl-tonemap-uncharted2/index.glsl\nfloat A_1_4 = 0.15;\nfloat B_1_5 = 0.50;\nfloat C_1_6 = 0.10;\nfloat D_1_7 = 0.20;\nfloat E_1_8 = 0.02;\nfloat F_1_9 = 0.30;\nfloat W_1_10 = 11.2;\n\nvec3 Uncharted2Tonemap_1_11(vec3 x) {\n   return ((x * (A_1_4 * x + C_1_6 * B_1_5) + D_1_7 * E_1_8) / (x * (A_1_4 * x + B_1_5) + D_1_7 * F_1_9)) - E_1_8 / F_1_9;\n}\n\n// Based on Filmic Tonemapping Operators http://filmicgames.com/archives/75\nvec3 tonemap_1_12(vec3 color) {\n    float ExposureBias = 2.0;\n    vec3 curr = Uncharted2Tonemap_1_11(ExposureBias * color);\n\n    vec3 whiteScale = 1.0 / Uncharted2Tonemap_1_11(vec3(W_1_10));\n    return curr * whiteScale;\n}\n\n\n\n// Set camera exposure based on angle between sun and eye\n\nfloat exposure_2_13(vec3 eye, vec3 L) {\n  return mix(\n    1.5,\n    300.0,\n    pow((1.0 - dot(normalize(eye), L)) / 2.0, 10.0)\n  );\n}\n\n\n\n/*\nModified from https://github.com/wdas/brdf/blob/master/src/brdfs/disney.brdf\n\nOriginal license notice:\n# Copyright Disney Enterprises, Inc.  All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the "License");\n# you may not use this file except in compliance with the License\n# and the following modification to it: Section 6 Trademarks.\n# deleted and replaced with:\n#\n# 6. Trademarks. This License does not grant permission to use the\n# trade names, trademarks, service marks, or product names of the\n# Licensor and its affiliates, except as required for reproducing\n# the content of the NOTICE file.\n#\n# You may obtain a copy of the License at\n# http://www.apache.org/licenses/LICENSE-2.0\n*/\n\nfloat specularTint_3_14 = 0.0;\nfloat anisotropic_3_15 = 0.0;\nfloat sheen_3_16 = 0.0;\nfloat sheenTint_3_17 = 0.5;\nfloat clearcoat_3_18 = 0.0;\nfloat clearcoatGloss_3_19 = 1.0;\n\nconst float PI_3_20 = 3.14159265358979323846;\n\nfloat sqr_3_21(float x) { return x*x; }\n\nfloat SchlickFresnel_3_22(float u) {\n  float m = clamp(1.0 - u, 0.0, 1.0);\n  float m2 = m * m;\n  return m2 * m2 * m; // pow(m, 5)\n}\n\nfloat GTR1_3_23(float NdotH, float a) {\n  if (a >= 1.0) return 1.0 / PI_3_20;\n  float a2 = a * a;\n  float t = 1.0 + (a2 - 1.0) * NdotH * NdotH;\n  return (a2 - 1.0) / (PI_3_20 * log(a2) * t);\n}\n\nfloat GTR2_3_24(float NdotH, float a) {\n  float a2 = a * a;\n  float t = 1.0 + (a2 - 1.0) * NdotH * NdotH;\n  return a2 / (PI_3_20 * t * t);\n}\n\nfloat GTR2_aniso_3_25(float NdotH, float HdotX, float HdotY, float ax, float ay) {\n  return 1.0 / (\n    PI_3_20 * ax * ay *\n    sqr_3_21(sqr_3_21(HdotX / ax) + sqr_3_21(HdotY / ay) + NdotH * NdotH)\n  );\n}\n\nfloat smithG_GGX_3_26(float Ndotv, float alphaG) {\n  float a = alphaG * alphaG;\n  float b = Ndotv * Ndotv;\n  return 1.0 / (Ndotv + sqrt(a + b - a * b));\n}\n\nvec3 mon2lin_3_27(vec3 x) {\n  return vec3(pow(x[0], 2.2), pow(x[1], 2.2), pow(x[2], 2.2));\n}\n\nvec3 brdf_3_28(\n  vec3 baseColor,\n  float metallic,\n  float subsurface,\n  float specular,\n  float roughness,\n  vec3 L, vec3 V, vec3 N\n) {\n  float NdotL = dot(N, L);\n  float NdotV = dot(N, V);\n\n  vec3 H = normalize(L + V);\n  float NdotH = dot(N, H);\n  float LdotH = dot(L, H);\n\n  vec3 Cdlin = mon2lin_3_27(baseColor);\n  float Cdlum = 0.3 * Cdlin[0] + 0.6 * Cdlin[1]  + 0.1 * Cdlin[2]; // luminance approx.\n\n  vec3 Ctint = Cdlum > 0.0 ? Cdlin / Cdlum : vec3(1.0); // normalize lum. to isolate hue+sat\n  vec3 Cspec0 = mix(specular * .08 * mix(vec3(1.0), Ctint, specularTint_3_14), Cdlin, metallic);\n  vec3 Csheen = mix(vec3(1.0), Ctint, sheenTint_3_17);\n\n  // Diffuse fresnel - go from 1 at normal incidence to .5 at grazing\n  // and mix in diffuse retro-reflection based on roughness\n  float FL = SchlickFresnel_3_22(NdotL), FV = SchlickFresnel_3_22(NdotV);\n  float Fd90 = 0.5 + 2.0 * LdotH * LdotH * roughness;\n  float Fd = mix(1.0, Fd90, FL) * mix(1.0, Fd90, FV);\n\n  // Based on Hanrahan-Krueger brdf approximation of isotropic bssrdf\n  // 1.25 scale is used to (roughly) preserve albedo\n  // Fss90 used to "flatten" retroreflection based on roughness\n  float Fss90 = LdotH * LdotH * roughness;\n  float Fss = mix(1.0, Fss90, FL) * mix(1.0, Fss90, FV);\n  float ss = 1.25 * (Fss * (1.0 / (NdotL + NdotV) - 0.5) + 0.5);\n\n  // specular\n  float Ds = GTR2_3_24(NdotH, max(0.001, sqr_3_21(roughness)));\n  float FH = SchlickFresnel_3_22(LdotH);\n  vec3 Fs = mix(Cspec0, vec3(1.0), FH);\n  float roughg = sqr_3_21(roughness * 0.5 + 0.5);\n  float Gs = smithG_GGX_3_26(NdotL, roughg) * smithG_GGX_3_26(NdotV, roughg);\n\n  // sheen\n  vec3 Fsheen = FH * sheen_3_16 * Csheen;\n\n  // clearcoat (ior = 1.5 -> F0 = 0.04)\n  float Dr = GTR1_3_23(NdotH, mix(0.1, 0.001, clearcoatGloss_3_19));\n  float Fr = mix(0.04, 1.0, FH);\n  float Gr = smithG_GGX_3_26(NdotL, 0.25) * smithG_GGX_3_26(NdotV, 0.25);\n\n  return ((1.0/PI_3_20) * mix(Fd, ss, subsurface) * Cdlin + Fsheen)\n    * (1.0 - metallic) +\n    Gs * Fs * Ds +\n    0.25 * clearcoat_3_18 * Gr * Fr * Dr;\n}\n\n\n\n\nuniform sampler2D topographyMap;\nuniform sampler2D diffuseMap;\nuniform sampler2D landmaskMap;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\n\nvoid main() {\n  vec3 constantLight = vNormal;\n  vec3 V = vNormal;\n\n  float landness = texture2D(landmaskMap, vUv).r;\n  float oceanDepth = 1.0 - texture2D(topographyMap, vUv).r;\n\n  vec3 oceanColor = mix(\n    vec3(0.0, 0.0, 0.25),\n    vec3(0.0, 0.0, 0.35),\n    oceanDepth\n  );\n\n  vec3 diffuseColor = mix(\n    oceanColor,\n    toLinear_5_1(texture2D(diffuseMap, vUv).rgb),\n    landness\n  );\n\n  vec3 N = vNormal;\n  vec3 L = normalize(constantLight);\n  vec3 H = normalize(L + V);\n\n  float roughness = mix(\n    mix(0.75, 0.55, oceanDepth),\n    (1.0 - diffuseColor.r * 0.5),\n    step(0.5, landness)\n  );\n\n  vec3 color = vec3(0.0);\n  if (dot(vNormal, L) > 0.0) {\n    vec3 lightColor = vec3(10.0);\n\n    color = lightColor * brdf_3_28(\n      diffuseColor,\n      0.0, //metallic\n      0.5, //subsurface\n      0.0, //specular\n      roughness, //roughness\n      L, V, N\n    );\n  }\n\n  vec3 tonemapped = tonemap_1_12(color * 1.25);\n  gl_FragColor = vec4(toGamma_4_3(tonemapped), 1.0);\n}\n'}),require.register("shaders/dayAndNight.frag.glsl",function(n,e,t){t.exports='#extension GL_OES_standard_derivatives : enable\nprecision highp float;\n#define GLSLIFY 1\n\nconst float gamma_9_0 = 2.2;\n\nfloat toLinear_9_1(float v) {\n  return pow(v, gamma_9_0);\n}\n\nvec2 toLinear_9_1(vec2 v) {\n  return pow(v, vec2(gamma_9_0));\n}\n\nvec3 toLinear_9_1(vec3 v) {\n  return pow(v, vec3(gamma_9_0));\n}\n\nvec4 toLinear_9_1(vec4 v) {\n  return vec4(toLinear_9_1(v.rgb), v.a);\n}\n\n\n\nconst float gamma_10_2 = 2.2;\n\nfloat toGamma_10_3(float v) {\n  return pow(v, 1.0 / gamma_10_2);\n}\n\nvec2 toGamma_10_3(vec2 v) {\n  return pow(v, vec2(1.0 / gamma_10_2));\n}\n\nvec3 toGamma_10_3(vec3 v) {\n  return pow(v, vec3(1.0 / gamma_10_2));\n}\n\nvec4 toGamma_10_3(vec4 v) {\n  return vec4(toGamma_10_3(v.rgb), v.a);\n}\n\n\n\n// Based on https://docs.unrealengine.com/latest/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf\n\nvec2 heightDerivative_1_4(vec2 texST, sampler2D map) {\n    vec2 TexDx = dFdx(texST);\n    vec2 TexDy = dFdy(texST);\n    vec2 STll = texST;\n    vec2 STlr = texST + TexDx;\n    vec2 STul = texST + TexDy;\n    float Hll = texture2D(map, STll).x;\n    float Hlr = texture2D(map, STlr).x;\n    float Hul = texture2D(map, STul).x;\n    float dBs = Hlr - Hll;\n    float dBt = Hul - Hll;\n    return vec2(dBs, dBt);\n}\n\n\n\n// Based on https://docs.unrealengine.com/latest/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf\n\nvec3 perturbNormal_2_5(vec3 surf_pos, vec3 surf_norm, vec2 dHdxy) {\n  // Calling derivatives per-component to address android bug:\n  // http://stackoverflow.com/questions/20272272/\n  vec3 vSigmaX = vec3(dFdx(surf_pos.x), dFdx(surf_pos.y), dFdx(surf_pos.z));\n  vec3 vSigmaY = vec3(dFdy(surf_pos.x), dFdy(surf_pos.y), dFdy(surf_pos.z));\n  vec3 vN = vec3(normalize(surf_norm)); // normalized\n  vec3 R1 = cross(vSigmaY, vN);\n  vec3 R2 = cross(vN, vSigmaX);\n\n  float fDet = dot(vSigmaX, R1);\n  vec3 vGrad = sign(fDet) * (dHdxy.x * R1 + dHdxy.y * R2);\n  return normalize(abs(fDet) * surf_norm - vGrad);\n}\n\n\n\n// Based on https://github.com/vorg/pragmatic-pbr/blob/master/local_modules/glsl-tonemap-uncharted2/index.glsl\nfloat A_3_6 = 0.15;\nfloat B_3_7 = 0.50;\nfloat C_3_8 = 0.10;\nfloat D_3_9 = 0.20;\nfloat E_3_10 = 0.02;\nfloat F_3_11 = 0.30;\nfloat W_3_12 = 11.2;\n\nvec3 Uncharted2Tonemap_3_13(vec3 x) {\n   return ((x * (A_3_6 * x + C_3_8 * B_3_7) + D_3_9 * E_3_10) / (x * (A_3_6 * x + B_3_7) + D_3_9 * F_3_11)) - E_3_10 / F_3_11;\n}\n\n// Based on Filmic Tonemapping Operators http://filmicgames.com/archives/75\nvec3 tonemap_3_14(vec3 color) {\n    float ExposureBias = 2.0;\n    vec3 curr = Uncharted2Tonemap_3_13(ExposureBias * color);\n\n    vec3 whiteScale = 1.0 / Uncharted2Tonemap_3_13(vec3(W_3_12));\n    return curr * whiteScale;\n}\n\n\n\n// Set camera exposure based on angle between sun and eye\n\nfloat exposure_4_15(vec3 eye, vec3 L) {\n  return mix(\n    1.5,\n    300.0,\n    pow((1.0 - dot(normalize(eye), L)) / 2.0, 10.0)\n  );\n}\n\n\n\n// Scale bump map effect to produce relatively even relief\n// shading across surface. Goal is to avoid too much shading\n// at glancing angles and too little shading in the center.\n//\n// Also, invert bumps for oceans since the ocean height map\n// is inverted and allow for an additional bump scale factor with\n// `oceanFactor`. This allows ocean floor rendering to show\n// full bumps vs ocean surface rendering being flat.\n\nfloat terrainBumpScale_5_16(\n  float landness,\n  float oceanFactor,\n  float vNdotL,\n  float vNdotV,\n  vec3 vEye,\n  vec3 vPosition\n) {\n  float shadowStart = 0.25;\n  float bumpFalloff = clamp(vNdotL / shadowStart, 0.0, 0.5);\n\n  float bumpScale = mix(\n    0.002,\n    0.02,\n    vNdotL * vNdotL * vNdotV\n  ) * bumpFalloff;\n\n  if (landness < 0.5) {\n    bumpScale *= -oceanFactor;\n  }\n\n  return bumpScale;\n}\n\n\n\nvec3 atmosphere_6_17(float NdotL, float NdotV) {\n  return (\n    max(pow(NdotL, 2.0), 0.0) *\n    pow(1.0 - NdotV, 12.0)\n  ) * vec3(0.1, 0.1, 1.0) * 20.0;\n}\n\n\n\nvec3 nightAmbient_7_18(\n  float NdotL,\n  vec3 diffuseColor,\n  sampler2D lightsMap,\n  vec2 vUv\n) {\n  return 0.01 * (\n    texture2D(lightsMap, vUv).r * vec3(0.8, 0.8, 0.5) +\n    0.3 * vec3(0.1, 0.1, 1.0) * diffuseColor\n  ) * clamp((-NdotL + 0.01) * 2.0, 0.0, 1.0);\n}\n\n\n\n/*\nModified from https://github.com/wdas/brdf/blob/master/src/brdfs/disney.brdf\n\nOriginal license notice:\n# Copyright Disney Enterprises, Inc.  All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the "License");\n# you may not use this file except in compliance with the License\n# and the following modification to it: Section 6 Trademarks.\n# deleted and replaced with:\n#\n# 6. Trademarks. This License does not grant permission to use the\n# trade names, trademarks, service marks, or product names of the\n# Licensor and its affiliates, except as required for reproducing\n# the content of the NOTICE file.\n#\n# You may obtain a copy of the License at\n# http://www.apache.org/licenses/LICENSE-2.0\n*/\n\nfloat specularTint_8_19 = 0.0;\nfloat anisotropic_8_20 = 0.0;\nfloat sheen_8_21 = 0.0;\nfloat sheenTint_8_22 = 0.5;\nfloat clearcoat_8_23 = 0.0;\nfloat clearcoatGloss_8_24 = 1.0;\n\nconst float PI_8_25 = 3.14159265358979323846;\n\nfloat sqr_8_26(float x) { return x*x; }\n\nfloat SchlickFresnel_8_27(float u) {\n  float m = clamp(1.0 - u, 0.0, 1.0);\n  float m2 = m * m;\n  return m2 * m2 * m; // pow(m, 5)\n}\n\nfloat GTR1_8_28(float NdotH, float a) {\n  if (a >= 1.0) return 1.0 / PI_8_25;\n  float a2 = a * a;\n  float t = 1.0 + (a2 - 1.0) * NdotH * NdotH;\n  return (a2 - 1.0) / (PI_8_25 * log(a2) * t);\n}\n\nfloat GTR2_8_29(float NdotH, float a) {\n  float a2 = a * a;\n  float t = 1.0 + (a2 - 1.0) * NdotH * NdotH;\n  return a2 / (PI_8_25 * t * t);\n}\n\nfloat GTR2_aniso_8_30(float NdotH, float HdotX, float HdotY, float ax, float ay) {\n  return 1.0 / (\n    PI_8_25 * ax * ay *\n    sqr_8_26(sqr_8_26(HdotX / ax) + sqr_8_26(HdotY / ay) + NdotH * NdotH)\n  );\n}\n\nfloat smithG_GGX_8_31(float Ndotv, float alphaG) {\n  float a = alphaG * alphaG;\n  float b = Ndotv * Ndotv;\n  return 1.0 / (Ndotv + sqrt(a + b - a * b));\n}\n\nvec3 mon2lin_8_32(vec3 x) {\n  return vec3(pow(x[0], 2.2), pow(x[1], 2.2), pow(x[2], 2.2));\n}\n\nvec3 brdf_8_33(\n  vec3 baseColor,\n  float metallic,\n  float subsurface,\n  float specular,\n  float roughness,\n  vec3 L, vec3 V, vec3 N\n) {\n  float NdotL = dot(N, L);\n  float NdotV = dot(N, V);\n\n  vec3 H = normalize(L + V);\n  float NdotH = dot(N, H);\n  float LdotH = dot(L, H);\n\n  vec3 Cdlin = mon2lin_8_32(baseColor);\n  float Cdlum = 0.3 * Cdlin[0] + 0.6 * Cdlin[1]  + 0.1 * Cdlin[2]; // luminance approx.\n\n  vec3 Ctint = Cdlum > 0.0 ? Cdlin / Cdlum : vec3(1.0); // normalize lum. to isolate hue+sat\n  vec3 Cspec0 = mix(specular * .08 * mix(vec3(1.0), Ctint, specularTint_8_19), Cdlin, metallic);\n  vec3 Csheen = mix(vec3(1.0), Ctint, sheenTint_8_22);\n\n  // Diffuse fresnel - go from 1 at normal incidence to .5 at grazing\n  // and mix in diffuse retro-reflection based on roughness\n  float FL = SchlickFresnel_8_27(NdotL), FV = SchlickFresnel_8_27(NdotV);\n  float Fd90 = 0.5 + 2.0 * LdotH * LdotH * roughness;\n  float Fd = mix(1.0, Fd90, FL) * mix(1.0, Fd90, FV);\n\n  // Based on Hanrahan-Krueger brdf approximation of isotropic bssrdf\n  // 1.25 scale is used to (roughly) preserve albedo\n  // Fss90 used to "flatten" retroreflection based on roughness\n  float Fss90 = LdotH * LdotH * roughness;\n  float Fss = mix(1.0, Fss90, FL) * mix(1.0, Fss90, FV);\n  float ss = 1.25 * (Fss * (1.0 / (NdotL + NdotV) - 0.5) + 0.5);\n\n  // specular\n  float Ds = GTR2_8_29(NdotH, max(0.001, sqr_8_26(roughness)));\n  float FH = SchlickFresnel_8_27(LdotH);\n  vec3 Fs = mix(Cspec0, vec3(1.0), FH);\n  float roughg = sqr_8_26(roughness * 0.5 + 0.5);\n  float Gs = smithG_GGX_8_31(NdotL, roughg) * smithG_GGX_8_31(NdotV, roughg);\n\n  // sheen\n  vec3 Fsheen = FH * sheen_8_21 * Csheen;\n\n  // clearcoat (ior = 1.5 -> F0 = 0.04)\n  float Dr = GTR1_8_28(NdotH, mix(0.1, 0.001, clearcoatGloss_8_24));\n  float Fr = mix(0.04, 1.0, FH);\n  float Gr = smithG_GGX_8_31(NdotL, 0.25) * smithG_GGX_8_31(NdotV, 0.25);\n\n  return ((1.0/PI_8_25) * mix(Fd, ss, subsurface) * Cdlin + Fsheen)\n    * (1.0 - metallic) +\n    Gs * Fs * Ds +\n    0.25 * clearcoat_8_23 * Gr * Fr * Dr;\n}\n\n\n\n\nuniform sampler2D topographyMap;\nuniform sampler2D diffuseMap;\nuniform sampler2D landmaskMap;\nuniform sampler2D lightsMap;\nuniform vec3 lightDirection;\nuniform vec3 eye;\n\nvarying vec2 vUv;\nvarying vec3 vPosition;\nvarying vec3 vNormal;\n\nvoid main() {\n  vec3 V = normalize(eye - vPosition);\n  float vNdotL = dot(vNormal, lightDirection);\n  float vNdotL_clamped = clamp(vNdotL, 0.0, 1.0);\n  float vNdotV = dot(vNormal, V);\n  float vNdotV_clamped = clamp(vNdotV, 0.0, 1.0);\n\n  float landness = texture2D(landmaskMap, vUv).r;\n  float oceanDepth = 1.0 - texture2D(topographyMap, vUv).r;\n\n  vec2 dHdxy = heightDerivative_1_4(vUv, topographyMap) *\n    terrainBumpScale_5_16(landness, 0.0, vNdotL, vNdotV, eye, vPosition);\n\n  vec3 oceanColor = mix(\n    vec3(0.0, 0.0, 0.3),\n    vec3(0.0, 0.0, 0.35),\n    oceanDepth\n  );\n\n  vec3 diffuseColor = mix(\n    oceanColor,\n    toLinear_9_1(texture2D(diffuseMap, vUv).rgb),\n    landness\n  );\n\n  vec3 N = perturbNormal_2_5(normalize(vPosition), vNormal, dHdxy);\n  vec3 L = normalize(lightDirection);\n  vec3 H = normalize(L + V);\n\n  float roughness = mix(\n    mix(0.75, 0.55, oceanDepth),\n    (1.0 - diffuseColor.r * 0.5),\n    step(0.5, landness)\n  );\n\n  vec3 color = nightAmbient_7_18(vNdotL, diffuseColor, lightsMap, vUv);\n  if (dot(vNormal, L) > 0.0) {\n    vec3 lightColor = vec3(10.0);\n\n    // Accurate would just be NdotL, pow makes falloff more gradual\n    float incidence = pow(dot(N, L), 1.5);\n\n    color = lightColor * incidence * brdf_8_33(\n      diffuseColor,\n      0.0, //metallic\n      0.5, //subsurface\n      0.3, //specular\n      roughness, //roughness\n      L, V, N\n    );\n\n    color += atmosphere_6_17(vNdotL_clamped, vNdotV_clamped);\n  }\n\n  vec3 tonemapped = tonemap_3_14(color * exposure_4_15(eye, L));\n  gl_FragColor = vec4(toGamma_10_3(tonemapped), 1.0);\n}\n';
}),require.register("shaders/elevation.frag.glsl",function(n,e,t){t.exports='#extension GL_OES_standard_derivatives : enable\nprecision highp float;\n#define GLSLIFY 1\n\nconst float gamma_10_0 = 2.2;\n\nfloat toLinear_10_1(float v) {\n  return pow(v, gamma_10_0);\n}\n\nvec2 toLinear_10_1(vec2 v) {\n  return pow(v, vec2(gamma_10_0));\n}\n\nvec3 toLinear_10_1(vec3 v) {\n  return pow(v, vec3(gamma_10_0));\n}\n\nvec4 toLinear_10_1(vec4 v) {\n  return vec4(toLinear_10_1(v.rgb), v.a);\n}\n\n\n\nconst float gamma_9_2 = 2.2;\n\nfloat toGamma_9_3(float v) {\n  return pow(v, 1.0 / gamma_9_2);\n}\n\nvec2 toGamma_9_3(vec2 v) {\n  return pow(v, vec2(1.0 / gamma_9_2));\n}\n\nvec3 toGamma_9_3(vec3 v) {\n  return pow(v, vec3(1.0 / gamma_9_2));\n}\n\nvec4 toGamma_9_3(vec4 v) {\n  return vec4(toGamma_9_3(v.rgb), v.a);\n}\n\n\n\n// Based on https://docs.unrealengine.com/latest/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf\n\nvec2 heightDerivative_2_4(vec2 texST, sampler2D map) {\n    vec2 TexDx = dFdx(texST);\n    vec2 TexDy = dFdy(texST);\n    vec2 STll = texST;\n    vec2 STlr = texST + TexDx;\n    vec2 STul = texST + TexDy;\n    float Hll = texture2D(map, STll).x;\n    float Hlr = texture2D(map, STlr).x;\n    float Hul = texture2D(map, STul).x;\n    float dBs = Hlr - Hll;\n    float dBt = Hul - Hll;\n    return vec2(dBs, dBt);\n}\n\n\n\n// Based on https://docs.unrealengine.com/latest/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf\n\nvec3 perturbNormal_1_5(vec3 surf_pos, vec3 surf_norm, vec2 dHdxy) {\n  // Calling derivatives per-component to address android bug:\n  // http://stackoverflow.com/questions/20272272/\n  vec3 vSigmaX = vec3(dFdx(surf_pos.x), dFdx(surf_pos.y), dFdx(surf_pos.z));\n  vec3 vSigmaY = vec3(dFdy(surf_pos.x), dFdy(surf_pos.y), dFdy(surf_pos.z));\n  vec3 vN = vec3(normalize(surf_norm)); // normalized\n  vec3 R1 = cross(vSigmaY, vN);\n  vec3 R2 = cross(vN, vSigmaX);\n\n  float fDet = dot(vSigmaX, R1);\n  vec3 vGrad = sign(fDet) * (dHdxy.x * R1 + dHdxy.y * R2);\n  return normalize(abs(fDet) * surf_norm - vGrad);\n}\n\n\n\n// Based on https://github.com/vorg/pragmatic-pbr/blob/master/local_modules/glsl-tonemap-uncharted2/index.glsl\nfloat A_3_6 = 0.15;\nfloat B_3_7 = 0.50;\nfloat C_3_8 = 0.10;\nfloat D_3_9 = 0.20;\nfloat E_3_10 = 0.02;\nfloat F_3_11 = 0.30;\nfloat W_3_12 = 11.2;\n\nvec3 Uncharted2Tonemap_3_13(vec3 x) {\n   return ((x * (A_3_6 * x + C_3_8 * B_3_7) + D_3_9 * E_3_10) / (x * (A_3_6 * x + B_3_7) + D_3_9 * F_3_11)) - E_3_10 / F_3_11;\n}\n\n// Based on Filmic Tonemapping Operators http://filmicgames.com/archives/75\nvec3 tonemap_3_14(vec3 color) {\n    float ExposureBias = 2.0;\n    vec3 curr = Uncharted2Tonemap_3_13(ExposureBias * color);\n\n    vec3 whiteScale = 1.0 / Uncharted2Tonemap_3_13(vec3(W_3_12));\n    return curr * whiteScale;\n}\n\n\n\n// Set camera exposure based on angle between sun and eye\n\nfloat exposure_4_15(vec3 eye, vec3 L) {\n  return mix(\n    1.5,\n    300.0,\n    pow((1.0 - dot(normalize(eye), L)) / 2.0, 10.0)\n  );\n}\n\n\n\n// Scale bump map effect to produce relatively even relief\n// shading across surface. Goal is to avoid too much shading\n// at glancing angles and too little shading in the center.\n//\n// Also, invert bumps for oceans since the ocean height map\n// is inverted and allow for an additional bump scale factor with\n// `oceanFactor`. This allows ocean floor rendering to show\n// full bumps vs ocean surface rendering being flat.\n\nfloat terrainBumpScale_5_16(\n  float landness,\n  float oceanFactor,\n  float vNdotL,\n  float vNdotV,\n  vec3 vEye,\n  vec3 vPosition\n) {\n  float shadowStart = 0.25;\n  float bumpFalloff = clamp(vNdotL / shadowStart, 0.0, 0.5);\n\n  float bumpScale = mix(\n    0.002,\n    0.02,\n    vNdotL * vNdotL * vNdotV\n  ) * bumpFalloff;\n\n  if (landness < 0.5) {\n    bumpScale *= -oceanFactor;\n  }\n\n  return bumpScale;\n}\n\n\n\nvec3 atmosphere_6_17(float NdotL, float NdotV) {\n  return (\n    max(pow(NdotL, 2.0), 0.0) *\n    pow(1.0 - NdotV, 12.0)\n  ) * vec3(0.1, 0.1, 1.0) * 20.0;\n}\n\n\n\nvec3 nightAmbient_7_18(\n  float NdotL,\n  vec3 diffuseColor,\n  sampler2D lightsMap,\n  vec2 vUv\n) {\n  return 0.01 * (\n    texture2D(lightsMap, vUv).r * vec3(0.8, 0.8, 0.5) +\n    0.3 * vec3(0.1, 0.1, 1.0) * diffuseColor\n  ) * clamp((-NdotL + 0.01) * 2.0, 0.0, 1.0);\n}\n\n\n\n/*\nModified from https://github.com/wdas/brdf/blob/master/src/brdfs/disney.brdf\n\nOriginal license notice:\n# Copyright Disney Enterprises, Inc.  All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the "License");\n# you may not use this file except in compliance with the License\n# and the following modification to it: Section 6 Trademarks.\n# deleted and replaced with:\n#\n# 6. Trademarks. This License does not grant permission to use the\n# trade names, trademarks, service marks, or product names of the\n# Licensor and its affiliates, except as required for reproducing\n# the content of the NOTICE file.\n#\n# You may obtain a copy of the License at\n# http://www.apache.org/licenses/LICENSE-2.0\n*/\n\nfloat specularTint_8_19 = 0.0;\nfloat anisotropic_8_20 = 0.0;\nfloat sheen_8_21 = 0.0;\nfloat sheenTint_8_22 = 0.5;\nfloat clearcoat_8_23 = 0.0;\nfloat clearcoatGloss_8_24 = 1.0;\n\nconst float PI_8_25 = 3.14159265358979323846;\n\nfloat sqr_8_26(float x) { return x*x; }\n\nfloat SchlickFresnel_8_27(float u) {\n  float m = clamp(1.0 - u, 0.0, 1.0);\n  float m2 = m * m;\n  return m2 * m2 * m; // pow(m, 5)\n}\n\nfloat GTR1_8_28(float NdotH, float a) {\n  if (a >= 1.0) return 1.0 / PI_8_25;\n  float a2 = a * a;\n  float t = 1.0 + (a2 - 1.0) * NdotH * NdotH;\n  return (a2 - 1.0) / (PI_8_25 * log(a2) * t);\n}\n\nfloat GTR2_8_29(float NdotH, float a) {\n  float a2 = a * a;\n  float t = 1.0 + (a2 - 1.0) * NdotH * NdotH;\n  return a2 / (PI_8_25 * t * t);\n}\n\nfloat GTR2_aniso_8_30(float NdotH, float HdotX, float HdotY, float ax, float ay) {\n  return 1.0 / (\n    PI_8_25 * ax * ay *\n    sqr_8_26(sqr_8_26(HdotX / ax) + sqr_8_26(HdotY / ay) + NdotH * NdotH)\n  );\n}\n\nfloat smithG_GGX_8_31(float Ndotv, float alphaG) {\n  float a = alphaG * alphaG;\n  float b = Ndotv * Ndotv;\n  return 1.0 / (Ndotv + sqrt(a + b - a * b));\n}\n\nvec3 mon2lin_8_32(vec3 x) {\n  return vec3(pow(x[0], 2.2), pow(x[1], 2.2), pow(x[2], 2.2));\n}\n\nvec3 brdf_8_33(\n  vec3 baseColor,\n  float metallic,\n  float subsurface,\n  float specular,\n  float roughness,\n  vec3 L, vec3 V, vec3 N\n) {\n  float NdotL = dot(N, L);\n  float NdotV = dot(N, V);\n\n  vec3 H = normalize(L + V);\n  float NdotH = dot(N, H);\n  float LdotH = dot(L, H);\n\n  vec3 Cdlin = mon2lin_8_32(baseColor);\n  float Cdlum = 0.3 * Cdlin[0] + 0.6 * Cdlin[1]  + 0.1 * Cdlin[2]; // luminance approx.\n\n  vec3 Ctint = Cdlum > 0.0 ? Cdlin / Cdlum : vec3(1.0); // normalize lum. to isolate hue+sat\n  vec3 Cspec0 = mix(specular * .08 * mix(vec3(1.0), Ctint, specularTint_8_19), Cdlin, metallic);\n  vec3 Csheen = mix(vec3(1.0), Ctint, sheenTint_8_22);\n\n  // Diffuse fresnel - go from 1 at normal incidence to .5 at grazing\n  // and mix in diffuse retro-reflection based on roughness\n  float FL = SchlickFresnel_8_27(NdotL), FV = SchlickFresnel_8_27(NdotV);\n  float Fd90 = 0.5 + 2.0 * LdotH * LdotH * roughness;\n  float Fd = mix(1.0, Fd90, FL) * mix(1.0, Fd90, FV);\n\n  // Based on Hanrahan-Krueger brdf approximation of isotropic bssrdf\n  // 1.25 scale is used to (roughly) preserve albedo\n  // Fss90 used to "flatten" retroreflection based on roughness\n  float Fss90 = LdotH * LdotH * roughness;\n  float Fss = mix(1.0, Fss90, FL) * mix(1.0, Fss90, FV);\n  float ss = 1.25 * (Fss * (1.0 / (NdotL + NdotV) - 0.5) + 0.5);\n\n  // specular\n  float Ds = GTR2_8_29(NdotH, max(0.001, sqr_8_26(roughness)));\n  float FH = SchlickFresnel_8_27(LdotH);\n  vec3 Fs = mix(Cspec0, vec3(1.0), FH);\n  float roughg = sqr_8_26(roughness * 0.5 + 0.5);\n  float Gs = smithG_GGX_8_31(NdotL, roughg) * smithG_GGX_8_31(NdotV, roughg);\n\n  // sheen\n  vec3 Fsheen = FH * sheen_8_21 * Csheen;\n\n  // clearcoat (ior = 1.5 -> F0 = 0.04)\n  float Dr = GTR1_8_28(NdotH, mix(0.1, 0.001, clearcoatGloss_8_24));\n  float Fr = mix(0.04, 1.0, FH);\n  float Gr = smithG_GGX_8_31(NdotL, 0.25) * smithG_GGX_8_31(NdotV, 0.25);\n\n  return ((1.0/PI_8_25) * mix(Fd, ss, subsurface) * Cdlin + Fsheen)\n    * (1.0 - metallic) +\n    Gs * Fs * Ds +\n    0.25 * clearcoat_8_23 * Gr * Fr * Dr;\n}\n\n\n\n\nuniform sampler2D topographyMap;\nuniform sampler2D diffuseMap;\nuniform sampler2D landmaskMap;\nuniform sampler2D lightsMap;\nuniform vec3 lightDirection;\nuniform vec3 eye;\n\nvarying vec2 vUv;\nvarying vec3 vPosition;\nvarying vec3 vNormal;\n\nvoid main() {\n  vec3 constantLight = vNormal;\n  vec3 V = vNormal;\n\n  float landness = texture2D(landmaskMap, vUv).r;\n  float elevation = texture2D(topographyMap, vUv).r;\n\n  float highestPoint = 8848.0;\n  float lowestPoint = 11034.0;\n  float seaLevel = lowestPoint / (highestPoint + lowestPoint);\n\n  float steps = 10.0;\n  vec3 diffuseColor = mix(\n    mix(\n      vec3(seaLevel),\n      vec3(0.0),\n      floor(elevation * steps) / steps\n    ),\n    mix(\n      vec3(seaLevel),\n      vec3(1.0),\n      floor(elevation * steps) / steps\n    ),\n    landness\n  );\n\n  // Outline the transition from land to sea\n  diffuseColor = mix(\n    diffuseColor,\n    vec3(0.0, 0.0, 0.5),\n    pow(1.0 - abs(landness - 0.5) * 2.0, 1.0)\n  );\n\n  vec3 N = vNormal;\n  vec3 L = normalize(constantLight);\n  vec3 H = normalize(L + V);\n\n  vec3 color = vec3(0.0);\n  if (dot(vNormal, L) > 0.0) {\n    vec3 lightColor = vec3(20.0);\n\n    color = lightColor * brdf_8_33(\n      diffuseColor,\n      0.0, //metallic\n      0.5, //subsurface\n      0.3, //specular\n      0.99, //roughness\n      L, V, N\n    );\n  }\n\n  vec3 tonemapped = tonemap_3_14(color * 0.5);\n  gl_FragColor = vec4(toGamma_9_3(tonemapped), 1.0);\n}\n'}),require.register("shaders/functions/atmosphere.glsl",function(n,e,t){t.exports="#define GLSLIFY 1\nvec3 atmosphere(float NdotL, float NdotV) {\n  return (\n    max(pow(NdotL, 2.0), 0.0) *\n    pow(1.0 - NdotV, 12.0)\n  ) * vec3(0.1, 0.1, 1.0) * 20.0;\n}\n\n\n"}),require.register("shaders/functions/brdf.glsl",function(n,e,t){t.exports='#define GLSLIFY 1\n/*\nModified from https://github.com/wdas/brdf/blob/master/src/brdfs/disney.brdf\n\nOriginal license notice:\n# Copyright Disney Enterprises, Inc.  All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the "License");\n# you may not use this file except in compliance with the License\n# and the following modification to it: Section 6 Trademarks.\n# deleted and replaced with:\n#\n# 6. Trademarks. This License does not grant permission to use the\n# trade names, trademarks, service marks, or product names of the\n# Licensor and its affiliates, except as required for reproducing\n# the content of the NOTICE file.\n#\n# You may obtain a copy of the License at\n# http://www.apache.org/licenses/LICENSE-2.0\n*/\n\nfloat specularTint = 0.0;\nfloat anisotropic = 0.0;\nfloat sheen = 0.0;\nfloat sheenTint = 0.5;\nfloat clearcoat = 0.0;\nfloat clearcoatGloss = 1.0;\n\nconst float PI = 3.14159265358979323846;\n\nfloat sqr(float x) { return x*x; }\n\nfloat SchlickFresnel(float u) {\n  float m = clamp(1.0 - u, 0.0, 1.0);\n  float m2 = m * m;\n  return m2 * m2 * m; // pow(m, 5)\n}\n\nfloat GTR1(float NdotH, float a) {\n  if (a >= 1.0) return 1.0 / PI;\n  float a2 = a * a;\n  float t = 1.0 + (a2 - 1.0) * NdotH * NdotH;\n  return (a2 - 1.0) / (PI * log(a2) * t);\n}\n\nfloat GTR2(float NdotH, float a) {\n  float a2 = a * a;\n  float t = 1.0 + (a2 - 1.0) * NdotH * NdotH;\n  return a2 / (PI * t * t);\n}\n\nfloat GTR2_aniso(float NdotH, float HdotX, float HdotY, float ax, float ay) {\n  return 1.0 / (\n    PI * ax * ay *\n    sqr(sqr(HdotX / ax) + sqr(HdotY / ay) + NdotH * NdotH)\n  );\n}\n\nfloat smithG_GGX(float Ndotv, float alphaG) {\n  float a = alphaG * alphaG;\n  float b = Ndotv * Ndotv;\n  return 1.0 / (Ndotv + sqrt(a + b - a * b));\n}\n\nvec3 mon2lin(vec3 x) {\n  return vec3(pow(x[0], 2.2), pow(x[1], 2.2), pow(x[2], 2.2));\n}\n\nvec3 brdf(\n  vec3 baseColor,\n  float metallic,\n  float subsurface,\n  float specular,\n  float roughness,\n  vec3 L, vec3 V, vec3 N\n) {\n  float NdotL = dot(N, L);\n  float NdotV = dot(N, V);\n\n  vec3 H = normalize(L + V);\n  float NdotH = dot(N, H);\n  float LdotH = dot(L, H);\n\n  vec3 Cdlin = mon2lin(baseColor);\n  float Cdlum = 0.3 * Cdlin[0] + 0.6 * Cdlin[1]  + 0.1 * Cdlin[2]; // luminance approx.\n\n  vec3 Ctint = Cdlum > 0.0 ? Cdlin / Cdlum : vec3(1.0); // normalize lum. to isolate hue+sat\n  vec3 Cspec0 = mix(specular * .08 * mix(vec3(1.0), Ctint, specularTint), Cdlin, metallic);\n  vec3 Csheen = mix(vec3(1.0), Ctint, sheenTint);\n\n  // Diffuse fresnel - go from 1 at normal incidence to .5 at grazing\n  // and mix in diffuse retro-reflection based on roughness\n  float FL = SchlickFresnel(NdotL), FV = SchlickFresnel(NdotV);\n  float Fd90 = 0.5 + 2.0 * LdotH * LdotH * roughness;\n  float Fd = mix(1.0, Fd90, FL) * mix(1.0, Fd90, FV);\n\n  // Based on Hanrahan-Krueger brdf approximation of isotropic bssrdf\n  // 1.25 scale is used to (roughly) preserve albedo\n  // Fss90 used to "flatten" retroreflection based on roughness\n  float Fss90 = LdotH * LdotH * roughness;\n  float Fss = mix(1.0, Fss90, FL) * mix(1.0, Fss90, FV);\n  float ss = 1.25 * (Fss * (1.0 / (NdotL + NdotV) - 0.5) + 0.5);\n\n  // specular\n  float Ds = GTR2(NdotH, max(0.001, sqr(roughness)));\n  float FH = SchlickFresnel(LdotH);\n  vec3 Fs = mix(Cspec0, vec3(1.0), FH);\n  float roughg = sqr(roughness * 0.5 + 0.5);\n  float Gs = smithG_GGX(NdotL, roughg) * smithG_GGX(NdotV, roughg);\n\n  // sheen\n  vec3 Fsheen = FH * sheen * Csheen;\n\n  // clearcoat (ior = 1.5 -> F0 = 0.04)\n  float Dr = GTR1(NdotH, mix(0.1, 0.001, clearcoatGloss));\n  float Fr = mix(0.04, 1.0, FH);\n  float Gr = smithG_GGX(NdotL, 0.25) * smithG_GGX(NdotV, 0.25);\n\n  return ((1.0/PI) * mix(Fd, ss, subsurface) * Cdlin + Fsheen)\n    * (1.0 - metallic) +\n    Gs * Fs * Ds +\n    0.25 * clearcoat * Gr * Fr * Dr;\n}\n\n\n'}),require.register("shaders/functions/exposure.glsl",function(n,e,t){t.exports="#define GLSLIFY 1\n// Set camera exposure based on angle between sun and eye\n\nfloat exposure(vec3 eye, vec3 L) {\n  return mix(\n    1.5,\n    300.0,\n    pow((1.0 - dot(normalize(eye), L)) / 2.0, 10.0)\n  );\n}\n\n\n"}),require.register("shaders/functions/heightDerivative.glsl",function(n,e,t){t.exports="#define GLSLIFY 1\n// Based on https://docs.unrealengine.com/latest/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf\n\nvec2 heightDerivative(vec2 texST, sampler2D map) {\n    vec2 TexDx = dFdx(texST);\n    vec2 TexDy = dFdy(texST);\n    vec2 STll = texST;\n    vec2 STlr = texST + TexDx;\n    vec2 STul = texST + TexDy;\n    float Hll = texture2D(map, STll).x;\n    float Hlr = texture2D(map, STlr).x;\n    float Hul = texture2D(map, STul).x;\n    float dBs = Hlr - Hll;\n    float dBt = Hul - Hll;\n    return vec2(dBs, dBt);\n}\n\n\n"}),require.register("shaders/functions/isNan.glsl",function(n,e,t){t.exports="#define GLSLIFY 1\n// Hack isNan for debugging since WebGL doesn't define it\n\nbool isNan(float val) {\n  return (val <= 0.0 || 0.0 <= val) ? false : true;\n}\n\n\n"}),require.register("shaders/functions/nightAmbient.glsl",function(n,e,t){t.exports="#define GLSLIFY 1\nvec3 nightAmbient(\n  float NdotL,\n  vec3 diffuseColor,\n  sampler2D lightsMap,\n  vec2 vUv\n) {\n  return 0.01 * (\n    texture2D(lightsMap, vUv).r * vec3(0.8, 0.8, 0.5) +\n    0.3 * vec3(0.1, 0.1, 1.0) * diffuseColor\n  ) * clamp((-NdotL + 0.01) * 2.0, 0.0, 1.0);\n}\n\n\n"}),require.register("shaders/functions/perturbNormal.glsl",function(n,e,t){t.exports="#define GLSLIFY 1\n// Based on https://docs.unrealengine.com/latest/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf\n\nvec3 perturbNormal(vec3 surf_pos, vec3 surf_norm, vec2 dHdxy) {\n  // Calling derivatives per-component to address android bug:\n  // http://stackoverflow.com/questions/20272272/\n  vec3 vSigmaX = vec3(dFdx(surf_pos.x), dFdx(surf_pos.y), dFdx(surf_pos.z));\n  vec3 vSigmaY = vec3(dFdy(surf_pos.x), dFdy(surf_pos.y), dFdy(surf_pos.z));\n  vec3 vN = vec3(normalize(surf_norm)); // normalized\n  vec3 R1 = cross(vSigmaY, vN);\n  vec3 R2 = cross(vN, vSigmaX);\n\n  float fDet = dot(vSigmaX, R1);\n  vec3 vGrad = sign(fDet) * (dHdxy.x * R1 + dHdxy.y * R2);\n  return normalize(abs(fDet) * surf_norm - vGrad);\n}\n\n\n"}),require.register("shaders/functions/terrainBumpScale.glsl",function(n,e,t){t.exports="#define GLSLIFY 1\n// Scale bump map effect to produce relatively even relief\n// shading across surface. Goal is to avoid too much shading\n// at glancing angles and too little shading in the center.\n//\n// Also, invert bumps for oceans since the ocean height map\n// is inverted and allow for an additional bump scale factor with\n// `oceanFactor`. This allows ocean floor rendering to show\n// full bumps vs ocean surface rendering being flat.\n\nfloat terrainBumpScale(\n  float landness,\n  float oceanFactor,\n  float vNdotL,\n  float vNdotV,\n  vec3 vEye,\n  vec3 vPosition\n) {\n  float shadowStart = 0.25;\n  float bumpFalloff = clamp(vNdotL / shadowStart, 0.0, 0.5);\n\n  float bumpScale = mix(\n    0.002,\n    0.02,\n    vNdotL * vNdotL * vNdotV\n  ) * bumpFalloff;\n\n  if (landness < 0.5) {\n    bumpScale *= -oceanFactor;\n  }\n\n  return bumpScale;\n}\n\n\n"}),require.register("shaders/functions/tonemap.glsl",function(n,e,t){t.exports="#define GLSLIFY 1\n// Based on https://github.com/vorg/pragmatic-pbr/blob/master/local_modules/glsl-tonemap-uncharted2/index.glsl\nfloat A = 0.15;\nfloat B = 0.50;\nfloat C = 0.10;\nfloat D = 0.20;\nfloat E = 0.02;\nfloat F = 0.30;\nfloat W = 11.2;\n\nvec3 Uncharted2Tonemap(vec3 x) {\n   return ((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - E / F;\n}\n\n// Based on Filmic Tonemapping Operators http://filmicgames.com/archives/75\nvec3 tonemap(vec3 color) {\n    float ExposureBias = 2.0;\n    vec3 curr = Uncharted2Tonemap(ExposureBias * color);\n\n    vec3 whiteScale = 1.0 / Uncharted2Tonemap(vec3(W));\n    return curr * whiteScale;\n}\n\n\n"}),require.register("shaders/globe.vert.glsl",function(n,e,t){t.exports="precision highp float;\n#define GLSLIFY 1\n\nfloat transpose_1_0(float m) {\n  return m;\n}\n\nmat2 transpose_1_0(mat2 m) {\n  return mat2(m[0][0], m[1][0],\n              m[0][1], m[1][1]);\n}\n\nmat3 transpose_1_0(mat3 m) {\n  return mat3(m[0][0], m[1][0], m[2][0],\n              m[0][1], m[1][1], m[2][1],\n              m[0][2], m[1][2], m[2][2]);\n}\n\nmat4 transpose_1_0(mat4 m) {\n  return mat4(m[0][0], m[1][0], m[2][0], m[3][0],\n              m[0][1], m[1][1], m[2][1], m[3][1],\n              m[0][2], m[1][2], m[2][2], m[3][2],\n              m[0][3], m[1][3], m[2][3], m[3][3]);\n}\n\n\nfloat inverse_2_1(float m) {\n  return 1.0 / m;\n}\n\nmat2 inverse_2_1(mat2 m) {\n  return mat2(m[1][1],-m[0][1],\n             -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\n\nmat3 inverse_2_1(mat3 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nmat4 inverse_2_1(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\n\n\nattribute vec3 position;\nattribute vec2 texcoord;\n\nuniform sampler2D topographyMap;\n\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 projection;\n\nvarying vec2 vUv;\nvarying vec3 vPosition;\nvarying vec3 vNormal;\n\nvoid main(void) {\n  mat4 modelView = view * model;\n  vUv = texcoord;\n\n  float scale = 1.0 + (\n    texture2D(topographyMap, vUv).r\n  ) * 0.0;\n\n  vec3 spherePosition = scale * position;\n\n  gl_Position = projection * modelView * vec4(spherePosition, 1.0);\n  vPosition = vec3(model * vec4(spherePosition, 1.0));\n\n  mat3 normalMatrix = transpose_1_0(inverse_2_1(mat3(model)));\n  vNormal = normalize(normalMatrix * spherePosition);\n}\n"}),require.register("shaders/night.frag.glsl",function(n,e,t){t.exports="#extension GL_OES_standard_derivatives : enable\nprecision highp float;\n#define GLSLIFY 1\n\nconst float gamma_4_0 = 2.2;\n\nfloat toLinear_4_1(float v) {\n  return pow(v, gamma_4_0);\n}\n\nvec2 toLinear_4_1(vec2 v) {\n  return pow(v, vec2(gamma_4_0));\n}\n\nvec3 toLinear_4_1(vec3 v) {\n  return pow(v, vec3(gamma_4_0));\n}\n\nvec4 toLinear_4_1(vec4 v) {\n  return vec4(toLinear_4_1(v.rgb), v.a);\n}\n\n\n\nconst float gamma_5_2 = 2.2;\n\nfloat toGamma_5_3(float v) {\n  return pow(v, 1.0 / gamma_5_2);\n}\n\nvec2 toGamma_5_3(vec2 v) {\n  return pow(v, vec2(1.0 / gamma_5_2));\n}\n\nvec3 toGamma_5_3(vec3 v) {\n  return pow(v, vec3(1.0 / gamma_5_2));\n}\n\nvec4 toGamma_5_3(vec4 v) {\n  return vec4(toGamma_5_3(v.rgb), v.a);\n}\n\n\n\n// Based on https://github.com/vorg/pragmatic-pbr/blob/master/local_modules/glsl-tonemap-uncharted2/index.glsl\nfloat A_1_4 = 0.15;\nfloat B_1_5 = 0.50;\nfloat C_1_6 = 0.10;\nfloat D_1_7 = 0.20;\nfloat E_1_8 = 0.02;\nfloat F_1_9 = 0.30;\nfloat W_1_10 = 11.2;\n\nvec3 Uncharted2Tonemap_1_11(vec3 x) {\n   return ((x * (A_1_4 * x + C_1_6 * B_1_5) + D_1_7 * E_1_8) / (x * (A_1_4 * x + B_1_5) + D_1_7 * F_1_9)) - E_1_8 / F_1_9;\n}\n\n// Based on Filmic Tonemapping Operators http://filmicgames.com/archives/75\nvec3 tonemap_1_12(vec3 color) {\n    float ExposureBias = 2.0;\n    vec3 curr = Uncharted2Tonemap_1_11(ExposureBias * color);\n\n    vec3 whiteScale = 1.0 / Uncharted2Tonemap_1_11(vec3(W_1_10));\n    return curr * whiteScale;\n}\n\n\n\n// Set camera exposure based on angle between sun and eye\n\nfloat exposure_2_13(vec3 eye, vec3 L) {\n  return mix(\n    1.5,\n    300.0,\n    pow((1.0 - dot(normalize(eye), L)) / 2.0, 10.0)\n  );\n}\n\n\n\nvec3 nightAmbient_3_14(\n  float NdotL,\n  vec3 diffuseColor,\n  sampler2D lightsMap,\n  vec2 vUv\n) {\n  return 0.01 * (\n    texture2D(lightsMap, vUv).r * vec3(0.8, 0.8, 0.5) +\n    0.3 * vec3(0.1, 0.1, 1.0) * diffuseColor\n  ) * clamp((-NdotL + 0.01) * 2.0, 0.0, 1.0);\n}\n\n\n\n\nuniform sampler2D topographyMap;\nuniform sampler2D diffuseMap;\nuniform sampler2D landmaskMap;\nuniform sampler2D lightsMap;\nuniform vec3 eye;\n\nvarying vec2 vUv;\nvarying vec3 vPosition;\nvarying vec3 vNormal;\n\nvoid main() {\n  float landness = texture2D(landmaskMap, vUv).r;\n  float oceanDepth = 1.0 - texture2D(topographyMap, vUv).r;\n\n  vec3 oceanColor = mix(\n    vec3(0.0, 0.0, 0.3),\n    vec3(0.0, 0.0, 0.35),\n    oceanDepth\n  );\n\n  vec3 diffuseColor = mix(\n    oceanColor,\n    toLinear_4_1(texture2D(diffuseMap, vUv).rgb),\n    landness\n  );\n\n  vec3 color = nightAmbient_3_14(-1.0, diffuseColor, lightsMap, vUv);\n  vec3 tonemapped = tonemap_1_12(color * 150.0);\n  gl_FragColor = vec4(toGamma_5_3(tonemapped), 1.0);\n}\n"}),require.alias("buffer/index.js","buffer"),require.alias("process/browser.js","process"),n=require("process"),require.register("___globals___",function(n,e,t){})}(),require("___globals___");