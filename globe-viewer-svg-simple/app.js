!function(){"use strict";var e="undefined"==typeof window?global:window;if("function"!=typeof e.require){var n={},t={},a={},o={}.hasOwnProperty,r=/^\.\.?(\/|$)/,s=function(e,n){for(var t,a=[],o=(r.test(n)?e+"/"+n:n).split("/"),s=0,i=o.length;s<i;s++)t=o[s],".."===t?a.pop():"."!==t&&""!==t&&a.push(t);return a.join("/")},i=function(e){return e.split("/").slice(0,-1).join("/")},l=function(n){return function(t){var a=s(i(n),t);return e.require(a,n)}},c=function(e,n){var a=null;a=_&&_.createHot(e);var o={id:e,exports:{},hot:a};return t[e]=o,n(o.exports,l(e),o),o.exports},u=function(e){return a[e]?u(a[e]):e},d=function(e,n){return u(s(i(e),n))},f=function(e,a){null==a&&(a="/");var r=u(e);if(o.call(t,r))return t[r].exports;if(o.call(n,r))return c(r,n[r]);throw new Error("Cannot find module '"+e+"' from '"+a+"'")};f.alias=function(e,n){a[n]=e};var v=/\.[^.\/]+$/,m=/\/index(\.[^\/]+)?$/,h=function(e){if(v.test(e)){var n=e.replace(v,"");o.call(a,n)&&a[n].replace(v,"")!==n+"/index"||(a[n]=e)}if(m.test(e)){var t=e.replace(m,"");o.call(a,t)||(a[t]=e)}};f.register=f.define=function(e,a){if("object"==typeof e)for(var r in e)o.call(e,r)&&f.register(r,e[r]);else n[e]=a,delete t[e],h(e)},f.list=function(){var e=[];for(var t in n)o.call(n,t)&&e.push(t);return e};var _=e._hmr&&new e._hmr(d,f,n,t);f._cache=t,f.hmr=_&&_.wrap,f.brunch=!0,e.require=f}}(),function(){var e;window;require.register("initialize.js",function(e,n,t){"use strict";function a(e){return e&&e.__esModule?e:{"default":e}}function o(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n["default"]=e,n}var r=n("d3"),s=o(r),i=n("twgl.js"),l=a(i),c=n("js/controller"),u=a(c);document.addEventListener("DOMContentLoaded",function(){var e=l["default"].getWebGLContext(document.querySelector(".map-canvas canvas")),n=document.querySelector(".map-canvas");s.json("data/vectors.json",function(t,a){new u["default"](e,n,a)})})}),require.register("js/bordersLayer.js",function(e,n,t){"use strict";function a(e){return e&&e.__esModule?e:{"default":e}}function o(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n["default"]=e,n}function r(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(e,"__esModule",{value:!0});var s=function(){function e(e,n){for(var t=0;t<n.length;t++){var a=n[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}return function(n,t,a){return t&&e(n.prototype,t),a&&e(n,a),n}}(),i=n("d3"),l=(o(i),n("topojson")),c=o(l),u=n("lodash"),d=(a(u),n("./utils")),f=function(){function e(n,t,a){r(this,e),this.options={countries:{enabled:!1}},this.layerCanvas=a,this.countries=c.feature(t,t.objects.countries),this.draw()}return s(e,[{key:"draw",value:function(){var e=this.layerCanvas.ctx;e.fillStyle="#000",e.fillRect(0,0,this.layerCanvas.width,this.layerCanvas.height),this.options.countries.enabled&&(e.beginPath(),this.layerCanvas.path(this.countries),e.lineWidth=1*this.layerCanvas.scale,e.strokeStyle="#fff",e.stroke()),(0,d.dispatchEvent)("borders-updated")}}]),e}();e["default"]=f}),require.register("js/camera.js",function(e,n,t){"use strict";function a(e){return e&&e.__esModule?e:{"default":e}}function o(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(e,"__esModule",{value:!0});var r=function(){function e(e,n){for(var t=0;t<n.length;t++){var a=n[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}return function(n,t,a){return t&&e(n.prototype,t),a&&e(n,a),n}}(),s=n("lodash"),i=a(s),l=n("hammerjs"),c=(a(l),n("twgl.js")),u=a(c),d=n("./controlRange"),f=a(d),v=n("./utils"),m=u["default"].m4,h=function(){function e(n,t){var a=this;o(this,e),this.gl=n,this.map=t,this.fov=50,this.longitude=new f["default"](0,(-180),180,(!0)),this.latitude=new f["default"](0,(-90),90),this.zoom=new f["default"](.5,0,1),this.dragging=!1,this.dragStart=void 0,this.mousePosition=void 0,this.hammer=new Hammer(t),this.hammer.get("pinch").set({enable:!0}),document.addEventListener("mousemove",function(e){a.handleMouseMove(e)}),t.addEventListener("mousedown",function(){a.dragging=!0}),document.addEventListener("selectstart",function(e){a.dragging===!0&&e.preventDefault()}),document.addEventListener("mouseup",function(){a.dragging=!1}),t.addEventListener("scroll",function(){return!1}),this.hammer.on("pan",function(e){return"mouse"!=e.pointerType&&a.handlePan(8*e.velocityX,8*e.velocityY),!1}),this.hammer.on("pinchstart",function(e){a.lastZoom=a.zoom.value,a.pinching=!0}),this.hammer.on("pinchend",function(e){a.pinching=!1}),this.hammer.on("pinch",function(e){a.pinching&&a.zoom.changeTo(a.lastZoom+.5*(e.scale-1))}),window.addEventListener("wheel",function(e){var n=.001*-e.deltaY;1===e.mozInputSource&&1===e.deltaMode&&(n*=50),t.contains(e.target)&&(a.zoom.changeBy(n),e.preventDefault())})}return r(e,[{key:"handleMouseMove",value:function(e){var n={x:e.screenX,y:e.screenY};if(void 0!==this.mousePosition&&this.dragging){var t=n.x-this.mousePosition.x,a=n.y-this.mousePosition.y;this.handlePan(.3*t,.3*a),e.stopPropagation()}this.mousePosition=n}},{key:"handlePan",value:function(e,n){var t=1-.8*this.zoom.value;this.longitude.changeBy(-e*t),this.latitude.changeBy(n*t)}},{key:"getDistance",value:function(){return 4.5-3*this.zoom.value}},{key:"getRenderValues",value:function(e){var n=e.canvas.width/e.canvas.height,t=(0,v.toRadians)(30)/i["default"].clamp(n,0,1),a=m.perspective(t,n,.01,10),o=[0,0,-this.getDistance()],r=m.identity();m.rotateY(r,(0,v.toRadians)(this.longitude.value+180),r),m.rotateX(r,(0,v.toRadians)(this.latitude.value),r),o=m.transformPoint(r,o);var s=m.transformPoint(r,[0,1,0]),l=[0,0,0],c=m.inverse(m.lookAt(o,l,s));return{view:c,projection:a,eye:o,aspect:n,fov:t}}}]),e}();e["default"]=h}),require.register("js/components/checkboxOption.js",function(e,n,t){"use strict";function a(e){return e&&e.__esModule?e:{"default":e}}function o(e,n){s["default"].component("checkbox-option",s["default"].extend({data:function(){return n[this.property].data},props:["label","property"],template:'\n      <label v-bind:class="[\'checkbox-option\', { active: enabled }]">\n        <input type="checkbox" v-model="enabled">\n        {{label}}\n      </label>\n    ',watch:{enabled:{handler:function(){var t=this;window.requestAnimationFrame(function(){window.requestAnimationFrame(function(){e.layerUpdated(n[t.property].layer)})})}}}}))}Object.defineProperty(e,"__esModule",{value:!0}),e["default"]=o;var r=n("vue/dist/vue.js"),s=a(r),i=n("lodash");a(i)}),require.register("js/components/rangeSlider.js",function(e,n,t){"use strict";function a(e){return e&&e.__esModule?e:{"default":e}}function o(e,n){s["default"].component("range-slider",s["default"].extend({beforeCreate:function(){this.updateFormatted=function(e){e.formatted=n[e.property].formatted(e)},this.throttleFormatted=l["default"].throttle(this.updateFormatted,50)},created:function(){this.updateFormatted(this)},data:function(){return l["default"].extend(n[this.property].data,{formatted:""})},props:["label","property","vertical"],template:"\n      <div v-bind:class=\"['range-slider', 'range-control', { vertical: vertical }]\">\n        <div class=\"top-row\">\n          <label>{{label}}</label>\n          <span>{{formatted}}</span>\n        </div>\n        <div class=\"slider\">\n          <input type='range'\n            :min='min'\n            :max='max'\n            step=\"any\"\n            v-model.number=\"value\">\n        </div>\n      </div>\n    ",watch:{value:{handler:function(){this.throttleFormatted(this),e.updated()}}}}))}Object.defineProperty(e,"__esModule",{value:!0}),e["default"]=o;var r=n("vue/dist/vue.js"),s=a(r),i=n("lodash"),l=a(i)}),require.register("js/components/renderModes.js",function(e,n,t){"use strict";function a(e){return e&&e.__esModule?e:{"default":e}}function o(e,n){s["default"].component("render-modes",s["default"].extend({data:function(){return n},computed:{},props:[],template:'\n      <div class="render-modes">\n        <div class="radio-buttons">\n          <div class="radio-button"\n            v-bind:class="{ active: renderMode == \'dayAndNight\' }">\n            <label>\n              <input type="radio" name="render-mode"\n                value="dayAndNight" v-model="renderMode">\n              Day and Night\n            </label>\n            <div v-show="renderMode == \'dayAndNight\'" class="sub-group">\n              <range-slider\n                label="Hour of Day"\n                property="hourOfDay">\n              </range-slider>\n              <range-slider\n                label="Day of Year"\n                property="dayOfYear">\n              </range-slider>\n            </div>\n          </div>\n          <div class="radio-button"\n            v-bind:class="{ active: renderMode == \'day\' }">\n            <label>\n              <input type="radio" name="render-mode"\n                value="day" v-model="renderMode">\n              Day\n            </label>\n          </div>\n          <div class="radio-button"\n            v-bind:class="{ active: renderMode == \'night\' }">\n            <label>\n              <input type="radio" name="render-mode"\n                value="night" v-model="renderMode">\n              Night\n            </label>\n          </div>\n          <div class="radio-button"\n            v-bind:class="{ active: renderMode == \'elevation\' }">\n            <label>\n              <input type="radio" name="render-mode"\n                value="elevation" v-model="renderMode">\n              Elevation\n            </label>\n            <div v-show="renderMode == \'elevation\'" class="sub-group">\n              <range-slider\n                label="Elevation Scale"\n                property="elevationScale">\n              </range-slider>\n            </div>\n          </div>\n        </div>\n      </div>\n    ',watch:{renderMode:{handler:function(){e.updated()}}}}))}Object.defineProperty(e,"__esModule",{value:!0}),e["default"]=o;var r=n("vue/dist/vue.js"),s=a(r)}),require.register("js/controlRange.js",function(e,n,t){"use strict";function a(e){return e&&e.__esModule?e:{"default":e}}function o(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(e,"__esModule",{value:!0});var r=function(){function e(e,n){for(var t=0;t<n.length;t++){var a=n[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}return function(n,t,a){return t&&e(n.prototype,t),a&&e(n,a),n}}(),s=n("lodash"),i=a(s),l=function(){function e(n,t,a){var r=!(arguments.length<=3||void 0===arguments[3])&&arguments[3];o(this,e),this.value=n,this.min=t,this.max=a,this.wrap=r}return r(e,[{key:"changeBy",value:function(e){this.changeTo(this.value+e)}},{key:"changeTo",value:function(e){this.wrap?this.setWrap(e):this.setClamp(e)}},{key:"setClamp",value:function(e){this.value=i["default"].clamp(e,this.min,this.max)}},{key:"setWrap",value:function(e){if(e>this.max){var n=e%this.max;e=this.min+n}else e<this.min&&(e=this.max-(this.min-e));this.value=e}}]),e}();e["default"]=l}),require.register("js/controller.js",function(e,n,t){"use strict";function a(e){return e&&e.__esModule?e:{"default":e}}function o(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(e,"__esModule",{value:!0});var r=function(){function e(e,n){for(var t=0;t<n.length;t++){var a=n[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}return function(n,t,a){return t&&e(n.prototype,t),a&&e(n,a),n}}(),s=n("vue/dist/vue.js"),i=a(s),l=n("moment"),c=(a(l),n("numeral")),u=a(c),d=n("lodash"),f=a(d),v=n("stats.js"),m=a(v),h=n("./scene"),_=a(h),p=n("./renderer"),x=a(p),g=n("./camera"),b=a(g),y=n("./layerCanvas"),w=a(y),L=n("./landMaskLayer"),N=a(L),F=n("./svgLayer"),C=a(F),S=n("./bordersLayer"),D=a(S),T=n("./components/rangeSlider"),G=a(T),H=n("./components/checkboxOption"),M=a(H),E=n("./components/renderModes"),R=a(E),z=function(){function e(n,t,a){var r=this;o(this,e),this.layerCanvas=new w["default"](n),this.layers={landmask:new N["default"](n,a,this.layerCanvas),borders:new D["default"](n,a,this.layerCanvas)},this.scene=new _["default"](n,this.layerCanvas,this.layers),this.renderer=new x["default"](n,this.scene),this.camera=new b["default"](n,t),this.svg=new C["default"](n,a,this.camera);var s=function(){return""},l=function(e){return(0,u["default"])(e.value).format("0.00")+"°"},c=function(){return r.scene.calculatedMoment().format("h:mm a")+" UTC"},d=function(){return r.scene.calculatedMoment().format("YYYY-MM-DD")},v=function(e){return 1===e.value?"(Realistic) 1x":(0,u["default"])(e.value).format("0.00")+"X"},m={latitude:{data:this.camera.latitude,formatted:l},longitude:{data:this.camera.longitude,formatted:l},zoom:{data:this.camera.zoom,formatted:s},hourOfDay:{data:this.scene.hourOfDay,formatted:c},dayOfYear:{data:this.scene.dayOfYear,formatted:d},elevationScale:{data:this.scene.elevationScale,formatted:v},rivers:{data:this.layers.landmask.options.rivers,layer:"landmask"},countries:{data:this.layers.borders.options.countries,layer:"borders"}};(0,G["default"])(this,m),(0,M["default"])(this,m),(0,R["default"])(this,this.scene),this.vue=new i["default"]({el:".map-controls"}),this.updateQueued=!1,f["default"].each(this.layers,function(e,n){f["default"].defer(function(){r.layerUpdated(n)})}),window.addEventListener("resize",function(){r.updated()}),window.addEventListener("texture-loaded",function(){r.updated()})}return r(e,[{key:"enableStats",value:function(){this.stats=new m["default"],this.stats.showPanel(0),this.stats.dom.style.left="auto",this.stats.dom.style.right="0",document.body.appendChild(this.stats.dom)}},{key:"layerUpdated",value:function(e){this.layers[e].draw()}},{key:"updated",value:function(){var e=this;this.updateQueued||(this.updateQueued=!0,window.requestAnimationFrame(function(){if(e.renderFrame(),e.updateQueued=!1,!e.loaded){e.loaded=!0;var n=document.querySelector(".loading");n.parentNode.removeChild(n)}}))}},{key:"renderFrame",value:function(){this.stats&&this.stats.begin(),this.renderer.render(window.performance.now(),this.scene,this.camera,this.renderer),this.svg.draw(),this.stats&&this.stats.end()}}]),e}();e["default"]=z}),require.register("js/coordinates.js",function(e,n,t){"use strict";function a(e){return e/1e3/86400+2440587.5}function o(e){var n=a(e)-2451545,t=357.529+.98560028*n,o=280.459+.98564736*n,s=o+1.915*Math.sin((0,r.toRadians)(t))+.02*Math.sin((0,r.toRadians)(2*t)),i=23.439-3.6e-7*n,l=Math.cos((0,r.toRadians)(i))*Math.sin((0,r.toRadians)(s)),c=Math.cos((0,r.toRadians)(s)),u=Math.atan2(l,c),d=Math.asin(Math.sin((0,r.toRadians)(i))*Math.sin((0,r.toRadians)(s))),f=18.697374558+24.06570982441908*n,v=f/24*Math.PI*2-u;return{hourAngle:v,declination:d}}Object.defineProperty(e,"__esModule",{value:!0}),e["default"]=o;var r=n("./utils")}),require.register("js/landMaskLayer.js",function(e,n,t){"use strict";function a(e){return e&&e.__esModule?e:{"default":e}}function o(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n["default"]=e,n}function r(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(e,"__esModule",{value:!0});var s=function(){function e(e,n){for(var t=0;t<n.length;t++){var a=n[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}return function(n,t,a){return t&&e(n.prototype,t),a&&e(n,a),n}}(),i=n("d3"),l=(o(i),n("topojson")),c=o(l),u=n("lodash"),d=(a(u),n("./utils")),f=function(){function e(n,t,a){r(this,e),this.options={rivers:{enabled:!1}},this.layerCanvas=a,this.land=c.feature(t,t.objects.land),this.lakes=c.feature(t,t.objects.lakes),this.rivers=c.feature(t,t.objects.rivers)}return s(e,[{key:"draw",value:function(){var e=this.layerCanvas.ctx;e.fillStyle="#000",e.fillRect(0,0,this.layerCanvas.width,this.layerCanvas.height),e.beginPath(),this.layerCanvas.path(this.land),e.fillStyle="#fff",e.fill(),e.lineWidth=1*this.scale,e.strokeStyle="#fff",e.stroke(),e.beginPath(),this.layerCanvas.path(this.lakes),e.fillStyle="#000",e.fill(),e.lineWidth=1*this.layerCanvas.scale,e.strokeStyle="#000",e.stroke(),this.options.rivers.enabled&&(e.beginPath(),this.layerCanvas.path(this.rivers),e.lineWidth=1*this.layerCanvas.scale,e.strokeStyle="#000",e.stroke()),(0,d.dispatchEvent)("landmask-updated")}}]),e}();e["default"]=f}),require.register("js/layerCanvas.js",function(e,n,t){"use strict";function a(e){return e&&e.__esModule?e:{"default":e}}function o(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n["default"]=e,n}function r(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(e,"__esModule",{value:!0});var s=n("d3"),i=o(s),l=n("lodash"),c=(a(l),function u(e){r(this,u),e.getParameter(e.MAX_TEXTURE_SIZE)>=8192?(this.width=8192,this.height=4096,this.scale=1):(this.width=4096,this.height=2048,this.scale=.5),this.projection=i.geoEquirectangular().scale(this.height/Math.PI).translate([this.width/2,this.height/2]),this.canvas=i.select(document.createElement("canvas")).attr("width",this.width).attr("height",this.height),this.ctx=this.canvas.node().getContext("2d"),this.path=i.geoPath().projection(this.projection).context(this.ctx)});e["default"]=c}),require.register("js/octahedronSphere.js",function(e,n,t){"use strict";function a(e){return e&&e.__esModule?e:{"default":e}}function o(e){for(var n=new Float32Array(d["default"].flatten([[0,1,0],[0,0,-1],[-1,0,0],[0,1,0],[-1,0,0],[0,0,1],[0,1,0],[0,0,1],[1,0,0],[0,1,0],[1,0,0],[0,0,-1],[0,-1,0],[-1,0,0],[0,0,-1],[0,-1,0],[0,0,1],[-1,0,0],[0,-1,0],[1,0,0],[0,0,1],[0,-1,0],[0,0,-1],[1,0,0]])),t=[new f.Vec3Array(n)],a=0;a<e;a++){for(var o=t[a],i=new f.Vec3Array(new Float32Array(4*o.data.length)),l=0;l<o.length;l+=3)r(o,i,l);t.push(i)}for(var c=t[t.length-1],u=new f.Vec2Array(new Float32Array(2*c.length)),v=0;v<c.length;v+=3)s(u,c,v);var m=0,h=new Int16Array(c.length),_=new f.Vec3Array(new Float32Array(c.data.length)),p=new f.Vec2Array(new Float32Array(u.data.length)),x={},g=0;for(g;g<c.length;g++){var b=c.get(g),y=u.get(g),w=[b[0],b[1],b[2],y[0],y[1]].join(","),L=x[w];void 0===L?(x[w]=m,_.set(m,b),p.set(m,y),h[g]=m,m+=1):h[g]=L}return{indices:h.subarray(0,g),position:_.data.subarray(0,3*m),texcoord:p.data.subarray(0,2*m),elevation:new Float32Array(m)}}function r(e,n,t){var a=e.get(t),o=e.get(t+1),r=e.get(t+2),s=Array.prototype.slice.call(v.normalize(v.add(a,o))),i=Array.prototype.slice.call(v.normalize(v.add(o,r))),l=Array.prototype.slice.call(v.normalize(v.add(r,a)));n.setRange(4*t,[a,s,l,s,i,l,s,o,i,l,i,r])}function s(e,n,t){var a=i(n.get(t)),o=i(n.get(t+1)),r=i(n.get(t+2)),s=Math.min(a[0],o[0],r[0]),l=Math.max(a[0],o[0],r[0]);l-s>.5&&(a[0]=1==a[0]?0:a[0],o[0]=1==o[0]?0:o[0],r[0]=1==r[0]?0:r[0]),e.setRange(t,[a,o,r])}function i(e){return[Math.atan2(e[0],e[2])/(2*Math.PI)+.5,1-(Math.asin(e[1])/Math.PI+.5)]}Object.defineProperty(e,"__esModule",{value:!0}),e["default"]=o;var l=n("twgl.js"),c=a(l),u=n("lodash"),d=a(u),f=n("./vectorArray"),v=c["default"].v3}),require.register("js/renderer.js",function(e,n,t){"use strict";function a(e){return e&&e.__esModule?e:{"default":e}}function o(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(e,"__esModule",{value:!0});var r=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e},s=function(){function e(e,n){for(var t=0;t<n.length;t++){var a=n[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}return function(n,t,a){return t&&e(n.prototype,t),a&&e(n,a),n}}(),i=n("twgl.js"),l=a(i),c=n("../shaders/globe.vert.glsl"),u=a(c),d=n("../shaders/dayAndNight.frag.glsl"),f=a(d),v=n("../shaders/day.frag.glsl"),m=a(v),h=n("../shaders/night.frag.glsl"),_=a(h),p=n("../shaders/elevation.frag.glsl"),x=a(p),g=l["default"].m4,b=function(){function e(n,t){var a=this;o(this,e),this.gl=n,n.clearColor(0,0,0,0),this.derivatives=n.getExtension("OES_standard_derivatives"),this.anisotropic=n.getExtension("EXT_texture_filter_anisotropic"),this.uniforms={};for(name in t.textures){var r=t.textures[name];this.setupGlobeTexture(n,r),this.uniforms[name]=r}this.programs={dayAndNight:l["default"].createProgramInfo(n,[u["default"],f["default"]]),day:l["default"].createProgramInfo(n,[u["default"],m["default"]]),night:l["default"].createProgramInfo(n,[u["default"],_["default"]]),elevation:l["default"].createProgramInfo(n,[u["default"],x["default"]])},n.enable(n.DEPTH_TEST),n.enable(n.CULL_FACE),window.addEventListener("texture-loaded",function(e){a.uniforms[e.detail.texture+"Size"]=new Float32Array([e.detail.width,e.detail.height])}),this.updateCanvasSize(n),window.addEventListener("resize",function(){a.updateCanvasSize(n)})}return s(e,[{key:"setupGlobeTexture",value:function(e,n){e.bindTexture(e.TEXTURE_2D,n),this.anisotropic&&e.texParameterf(e.TEXTURE_2D,this.anisotropic.TEXTURE_MAX_ANISOTROPY_EXT,16),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.REPEAT),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR_MIPMAP_LINEAR)}},{key:"render",value:function(e,n,t){var a=this.gl;a.clear(a.COLOR_BUFFER_BIT|a.DEPTH_BUFFER_BIT);var o=g.identity(),s=n.getSunVector();r(this.uniforms,t.getRenderValues(a),n.getElevationScales(),{model:o,time:e,lightDirection:g.transformPoint(s,[-1,0,0])});var i=this.programs[n.renderMode];a.useProgram(i.program),l["default"].setBuffersAndAttributes(a,i,n.globeBuffer),l["default"].setUniforms(i,this.uniforms),a.drawElements(a.TRIANGLES,n.globeBuffer.numElements,a.UNSIGNED_SHORT,0)}},{key:"updateCanvasSize",value:function(e){var n=e.canvas.parentNode.offsetWidth,t=e.canvas.parentNode.offsetHeight;if(n+"px"!=e.canvas.style.width||t+"px"!=e.canvas.style.height){e.canvas.style.width=n+"px",e.canvas.style.height=t+"px";var a=window.devicePixelRatio||1;a>1&&n>1500&&(a-=.5),e.canvas.width=Math.floor(n*a),e.canvas.height=Math.floor(t*a),e.viewport(0,0,e.canvas.width,e.canvas.height)}}}]),e}();e["default"]=b}),require.register("js/scene.js",function(e,n,t){"use strict";function a(e){return e&&e.__esModule?e:{"default":e}}function o(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(e,"__esModule",{value:!0});var r=function(){function e(e,n){for(var t=0;t<n.length;t++){var a=n[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}return function(n,t,a){return t&&e(n.prototype,t),a&&e(n,a),n}}(),s=n("twgl.js"),i=a(s),l=n("moment"),c=a(l),u=n("lodash"),d=a(u),f=n("./utils"),v=n("./controlRange"),m=a(v),h=n("./octahedronSphere"),_=a(h),p=n("./coordinates.js"),x=a(p),g=i["default"].m4,b=function(){function e(n,t,a){var r=this;o(this,e),this.gl=n,this.layerCanvas=t,this.layers=a,this.hourOfDay=new m["default"](12,.001,23.999),this.dayOfYear=new m["default"](182,1,365),this.elevationScale=new m["default"](10,1,30),this.sphere=(0,_["default"])(6),this.globeBuffer=i["default"].createBufferInfoFromArrays(n,{indices:{numComponents:3,data:this.sphere.indices},position:{numComponents:3,data:this.sphere.position},texcoord:{numComponents:2,data:this.sphere.texcoord},elevation:{numComponents:1,data:this.sphere.elevation}}),this.renderMode="dayAndNight",this.fillInElevations(),this.initTextures(),window.addEventListener("landmask-updated",function(){r.updateLayerTexture("landmask")}),window.addEventListener("borders-updated",function(){r.updateLayerTexture("borders")})}return r(e,[{key:"updateLayerTexture",value:function(e){var n=this.layerCanvas.canvas.node();i["default"].setTextureFromElement(this.gl,this.textures[e+"Map"],n),(0,f.dispatchEvent)("texture-loaded",{texture:e+"Map",width:n.width,height:n.height})}},{key:"initTextures",value:function(){var e={diffuseMap:{format:this.gl.RGB,internalFormat:this.gl.RGB,src:"data/color-4096.jpg",color:[0,0,0,1]},topographyMap:{format:this.gl.LUMINANCE,internalFormat:this.gl.LUMINANCE,src:"data/topo-bathy-4096.jpg",color:[0,0,0,1]},landmaskMap:{format:this.gl.LUMINANCE,internalFormat:this.gl.LUMINANCE,width:2,height:2},bordersMap:{format:this.gl.LUMINANCE,internalFormat:this.gl.LUMINANCE,width:2,height:2},lightsMap:{src:"data/lights-4096.png",format:this.gl.LUMINANCE,internalFormat:this.gl.LUMINANCE,color:[0,0,0,1]}};for(var n in e)(0,f.dispatchEvent)("texture-loaded",{texture:n,width:1,height:1});this.textures=i["default"].createTextures(this.gl,e,function(e,n,t){for(var a in t)(0,f.dispatchEvent)("texture-loaded",{texture:a,width:t[a].width,height:t[a].height})})}},{key:"calculatedMoment",value:function(){return(0,c["default"])("2016-01-01T00:00:00.000Z").utcOffset(0).dayOfYear(this.dayOfYear.value).add(60*this.hourOfDay.value*60,"seconds")}},{key:"getSunVector",value:function(){var e=this.calculatedMoment(),n=(0,x["default"])(d["default"].toInteger(e.format("x"))),t=g.identity();return t=g.rotateY(t,Math.PI/2-n.hourAngle),t=g.rotateZ(t,-n.declination)}},{key:"getElevationScales",value:function(){var e=20068/6371e3,n=e,t=0;return"elevation"===this.renderMode&&(n=this.elevationScale.value*e,t=this.elevationScale.value*e),{oceanElevationScale:t,landElevationScale:n}}},{key:"fillInElevations",value:function(){var e=this,n=new Image;n.onload=function(){var t=document.createElement("canvas");t.width=n.width,t.height=n.height;var a=t.getContext("2d");a.drawImage(n,0,0,n.width,n.height);for(var o=a.getImageData(0,0,n.width,n.height).data,r=n.width-1,s=n.height-1,l=0;l<e.sphere.elevation.length;l++){var c=e.sphere.texcoord[2*l],u=e.sphere.texcoord[2*l+1],f=d["default"].clamp(d["default"].floor((1==c?0:c)*r),0,r),v=d["default"].clamp(d["default"].floor((1==u?0:u)*s),0,s),m=o[4*[f+v*n.width]];e.sphere.elevation[l]=m/255-.5}i["default"].setAttribInfoBufferFromArray(e.gl,e.globeBuffer.attribs.elevation,e.sphere.elevation)},n.src="data/topo-bathy-128.jpg"}}]),e}();e["default"]=b}),require.register("js/svgLayer.js",function(e,n,t){"use strict";function a(e){return e&&e.__esModule?e:{"default":e}}function o(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n["default"]=e,n}function r(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(e,"__esModule",{value:!0});var s=function(){function e(e,n){for(var t=0;t<n.length;t++){var a=n[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}return function(n,t,a){return t&&e(n.prototype,t),a&&e(n,a),n}}(),i=n("d3"),l=o(i),c=n("d3-geo"),u=o(c),d=n("d3-geo-projection"),f=o(d),v=n("topojson"),m=o(v),h=n("lodash"),_=(a(h),n("twgl.js")),p=a(_),x=p["default"].m4,g=function(){function e(n,t,a){var o=this;r(this,e),this.gl=n,this.camera=a,this.options={countries:{enabled:!0}},this.countries=m.feature(t,t.objects.countries),this.svg=l.select(".map-canvas").append("svg").attr("class","svg-layer"),this.projection=f.geoSatellite(),this.graticule=u.geoGraticule().extent([[-93,27],[-47+1e-6,57+1e-6]]).step([3,3]),this.path=u.geoPath().projection(this.projection),this.countryPaths=this.svg.selectAll(".country").data(this.countries.features).enter().insert("path").attr("class","country").attr("d",this.path),window.addEventListener("resize",function(){o.resize()}),this.resize(),this.draw()}return s(e,[{key:"draw",value:function(){var e=this.camera.getDistance(),n=this.camera.getRenderValues(this.gl),t=x.transformPoint(n.projection,[0,.75,-(e-1)])[1];this.projection.distance(e).scale(this.height*t*2/3).translate([this.width/2,this.height/2]).rotate([-this.camera.longitude.value,-this.camera.latitude.value,0]).clipAngle(180*Math.acos(1/e)/Math.PI-1e-6),this.countryPaths.attr("d",this.path)}},{key:"resize",value:function(){this.width=this.gl.canvas.parentNode.offsetWidth,this.height=this.gl.canvas.parentNode.offsetHeight,this.svg.attr("width",this.width).attr("height",this.height),this.draw()}}]),e}();e["default"]=g}),require.register("js/utils.js",function(e,n,t){"use strict";function a(e){return e&&e.__esModule?e:{"default":e}}function o(e){return e/180*Math.PI}function r(e,n){var t=document.createEvent("CustomEvent");t.initCustomEvent(e,!1,!1,n||{}),window.dispatchEvent(t)}Object.defineProperty(e,"__esModule",{value:!0}),e.toRadians=o,e.dispatchEvent=r;var s=n("platform"),i=(a(s),n("lodash"));a(i)}),require.register("js/vectorArray.js",function(e,n,t){"use strict";function a(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(e,"__esModule",{value:!0});var o=function(){function e(e,n){for(var t=0;t<n.length;t++){var a=n[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}return function(n,t,a){return t&&e(n.prototype,t),a&&e(n,a),n}}();e.Vec2Array=function(){function e(n){a(this,e),this.data=n,this.length=n.length/2}return o(e,[{key:"get",value:function(e){var n=2*e;return[this.data[n],this.data[n+1]]}},{key:"setRange",value:function(e,n){for(var t=0;t<n.length;t++)this.set(e+t,n[t])}},{key:"set",value:function(e,n){this.data[2*e]=n[0],this.data[2*e+1]=n[1]}}]),e}(),e.Vec3Array=function(){function e(n){a(this,e),this.data=n,this.length=n.length/3}return o(e,[{key:"get",value:function(e){var n=3*e;return[this.data[n],this.data[n+1],this.data[n+2]]}},{key:"setRange",value:function(e,n){for(var t=0;t<n.length;t++)this.set(e+t,n[t])}},{key:"set",value:function(e,n){this.data[3*e]=n[0],this.data[3*e+1]=n[1],this.data[3*e+2]=n[2]}}]),e}()}),require.register("shaders/day.frag.glsl",function(e,n,t){t.exports='#extension GL_OES_standard_derivatives : enable\nprecision highp float;\n#define GLSLIFY 1\n\nconst float gamma_5_0 = 2.2;\n\nfloat toLinear_5_1(float v) {\n  return pow(v, gamma_5_0);\n}\n\nvec2 toLinear_5_1(vec2 v) {\n  return pow(v, vec2(gamma_5_0));\n}\n\nvec3 toLinear_5_1(vec3 v) {\n  return pow(v, vec3(gamma_5_0));\n}\n\nvec4 toLinear_5_1(vec4 v) {\n  return vec4(toLinear_5_1(v.rgb), v.a);\n}\n\n\n\nconst float gamma_6_2 = 2.2;\n\nfloat toGamma_6_3(float v) {\n  return pow(v, 1.0 / gamma_6_2);\n}\n\nvec2 toGamma_6_3(vec2 v) {\n  return pow(v, vec2(1.0 / gamma_6_2));\n}\n\nvec3 toGamma_6_3(vec3 v) {\n  return pow(v, vec3(1.0 / gamma_6_2));\n}\n\nvec4 toGamma_6_3(vec4 v) {\n  return vec4(toGamma_6_3(v.rgb), v.a);\n}\n\n\n\n// Based on https://github.com/vorg/pragmatic-pbr/blob/master/local_modules/glsl-tonemap-uncharted2/index.glsl\nfloat A_1_4 = 0.15;\nfloat B_1_5 = 0.50;\nfloat C_1_6 = 0.10;\nfloat D_1_7 = 0.20;\nfloat E_1_8 = 0.02;\nfloat F_1_9 = 0.30;\nfloat W_1_10 = 11.2;\n\nvec3 Uncharted2Tonemap_1_11(vec3 x) {\n   return ((x * (A_1_4 * x + C_1_6 * B_1_5) + D_1_7 * E_1_8) / (x * (A_1_4 * x + B_1_5) + D_1_7 * F_1_9)) - E_1_8 / F_1_9;\n}\n\n// Based on Filmic Tonemapping Operators http://filmicgames.com/archives/75\nvec3 tonemap_1_12(vec3 color) {\n    float ExposureBias = 2.0;\n    vec3 curr = Uncharted2Tonemap_1_11(ExposureBias * color);\n\n    vec3 whiteScale = 1.0 / Uncharted2Tonemap_1_11(vec3(W_1_10));\n    return curr * whiteScale;\n}\n\n\n\n// Set camera exposure based on angle between sun and eye\n\nfloat exposure_2_13(vec3 eye, vec3 L) {\n  return mix(\n    1.5,\n    300.0,\n    pow((1.0 - dot(normalize(eye), L)) / 2.0, 10.0)\n  );\n}\n\n\n\n/*\nModified from https://github.com/wdas/brdf/blob/master/src/brdfs/disney.brdf\n\nOriginal license notice:\n# Copyright Disney Enterprises, Inc.  All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the "License");\n# you may not use this file except in compliance with the License\n# and the following modification to it: Section 6 Trademarks.\n# deleted and replaced with:\n#\n# 6. Trademarks. This License does not grant permission to use the\n# trade names, trademarks, service marks, or product names of the\n# Licensor and its affiliates, except as required for reproducing\n# the content of the NOTICE file.\n#\n# You may obtain a copy of the License at\n# http://www.apache.org/licenses/LICENSE-2.0\n*/\n\nfloat specularTint_3_14 = 0.0;\nfloat anisotropic_3_15 = 0.0;\nfloat sheen_3_16 = 0.0;\nfloat sheenTint_3_17 = 0.5;\nfloat clearcoat_3_18 = 0.0;\nfloat clearcoatGloss_3_19 = 1.0;\n\nconst float PI_3_20 = 3.14159265358979323846;\n\nfloat sqr_3_21(float x) { return x*x; }\n\nfloat SchlickFresnel_3_22(float u) {\n  float m = clamp(1.0 - u, 0.0, 1.0);\n  float m2 = m * m;\n  return m2 * m2 * m; // pow(m, 5)\n}\n\nfloat GTR1_3_23(float NdotH, float a) {\n  if (a >= 1.0) return 1.0 / PI_3_20;\n  float a2 = a * a;\n  float t = 1.0 + (a2 - 1.0) * NdotH * NdotH;\n  return (a2 - 1.0) / (PI_3_20 * log(a2) * t);\n}\n\nfloat GTR2_3_24(float NdotH, float a) {\n  float a2 = a * a;\n  float t = 1.0 + (a2 - 1.0) * NdotH * NdotH;\n  return a2 / (PI_3_20 * t * t);\n}\n\nfloat GTR2_aniso_3_25(float NdotH, float HdotX, float HdotY, float ax, float ay) {\n  return 1.0 / (\n    PI_3_20 * ax * ay *\n    sqr_3_21(sqr_3_21(HdotX / ax) + sqr_3_21(HdotY / ay) + NdotH * NdotH)\n  );\n}\n\nfloat smithG_GGX_3_26(float Ndotv, float alphaG) {\n  float a = alphaG * alphaG;\n  float b = Ndotv * Ndotv;\n  return 1.0 / (Ndotv + sqrt(a + b - a * b));\n}\n\nvec3 mon2lin_3_27(vec3 x) {\n  return vec3(pow(x[0], 2.2), pow(x[1], 2.2), pow(x[2], 2.2));\n}\n\nvec3 brdf_3_28(\n  vec3 baseColor,\n  float metallic,\n  float subsurface,\n  float specular,\n  float roughness,\n  vec3 L, vec3 V, vec3 N\n) {\n  float NdotL = dot(N, L);\n  float NdotV = dot(N, V);\n\n  vec3 H = normalize(L + V);\n  float NdotH = dot(N, H);\n  float LdotH = dot(L, H);\n\n  vec3 Cdlin = mon2lin_3_27(baseColor);\n  float Cdlum = 0.3 * Cdlin[0] + 0.6 * Cdlin[1]  + 0.1 * Cdlin[2]; // luminance approx.\n\n  vec3 Ctint = Cdlum > 0.0 ? Cdlin / Cdlum : vec3(1.0); // normalize lum. to isolate hue+sat\n  vec3 Cspec0 = mix(specular * .08 * mix(vec3(1.0), Ctint, specularTint_3_14), Cdlin, metallic);\n  vec3 Csheen = mix(vec3(1.0), Ctint, sheenTint_3_17);\n\n  // Diffuse fresnel - go from 1 at normal incidence to .5 at grazing\n  // and mix in diffuse retro-reflection based on roughness\n  float FL = SchlickFresnel_3_22(NdotL), FV = SchlickFresnel_3_22(NdotV);\n  float Fd90 = 0.5 + 2.0 * LdotH * LdotH * roughness;\n  float Fd = mix(1.0, Fd90, FL) * mix(1.0, Fd90, FV);\n\n  // Based on Hanrahan-Krueger brdf approximation of isotropic bssrdf\n  // 1.25 scale is used to (roughly) preserve albedo\n  // Fss90 used to "flatten" retroreflection based on roughness\n  float Fss90 = LdotH * LdotH * roughness;\n  float Fss = mix(1.0, Fss90, FL) * mix(1.0, Fss90, FV);\n  float ss = 1.25 * (Fss * (1.0 / (NdotL + NdotV) - 0.5) + 0.5);\n\n  // specular\n  float Ds = GTR2_3_24(NdotH, max(0.001, sqr_3_21(roughness)));\n  float FH = SchlickFresnel_3_22(LdotH);\n  vec3 Fs = mix(Cspec0, vec3(1.0), FH);\n  float roughg = sqr_3_21(roughness * 0.5 + 0.5);\n  float Gs = smithG_GGX_3_26(NdotL, roughg) * smithG_GGX_3_26(NdotV, roughg);\n\n  // sheen\n  vec3 Fsheen = FH * sheen_3_16 * Csheen;\n\n  // clearcoat (ior = 1.5 -> F0 = 0.04)\n  float Dr = GTR1_3_23(NdotH, mix(0.1, 0.001, clearcoatGloss_3_19));\n  float Fr = mix(0.04, 1.0, FH);\n  float Gr = smithG_GGX_3_26(NdotL, 0.25) * smithG_GGX_3_26(NdotV, 0.25);\n\n  return ((1.0/PI_3_20) * mix(Fd, ss, subsurface) * Cdlin + Fsheen)\n    * (1.0 - metallic) +\n    Gs * Fs * Ds +\n    0.25 * clearcoat_3_18 * Gr * Fr * Dr;\n}\n\n\n\n// Based on:\n// http://stackoverflow.com/questions/13501081/efficient-bicubic-filtering-code-in-glsl\n\nvec4 cubic_4_29(float v) {\n  vec4 n = vec4(1.0, 2.0, 3.0, 4.0) - v;\n  vec4 s = n * n * n;\n  float x = s.x;\n  float y = s.y - 4.0 * s.x;\n  float z = s.z - 4.0 * s.y + 6.0 * s.x;\n  float w = 6.0 - x - y - z;\n  return vec4(x, y, z, w);\n}\n\nvec4 texture2DCubic_4_30(\n  sampler2D tex,\n  vec2 uv,\n  vec2 textureResolution\n) {\n  vec2 texcoord = uv * textureResolution;\n  texcoord -= vec2(0.5);\n  float fx = fract(texcoord.x);\n  float fy = fract(texcoord.y);\n  texcoord.x -= fx;\n  texcoord.y -= fy;\n\n  vec4 xcubic = cubic_4_29(fx);\n  vec4 ycubic = cubic_4_29(fy);\n\n  vec4 c = vec4(\n    texcoord.x - 0.5,\n    texcoord.x + 1.5,\n    texcoord.y - 0.5,\n    texcoord.y + 1.5\n  );\n\n  vec4 s = vec4(\n    xcubic.x + xcubic.y,\n    xcubic.z + xcubic.w,\n    ycubic.x + ycubic.y,\n    ycubic.z + ycubic.w\n  );\n\n  vec4 offset = c + vec4(\n    xcubic.y,\n    xcubic.w,\n    ycubic.y,\n    ycubic.w\n  ) / s;\n\n  vec4 sample0 = texture2D(tex,\n    vec2(offset.x, offset.z) / textureResolution);\n\n  vec4 sample1 = texture2D(tex,\n    vec2(offset.y, offset.z) / textureResolution);\n\n  vec4 sample2 = texture2D(tex,\n    vec2(offset.x, offset.w) / textureResolution);\n\n  vec4 sample3 = texture2D(tex,\n    vec2(offset.y, offset.w) / textureResolution);\n\n  float sx = s.x / (s.x + s.y);\n  float sy = s.z / (s.z + s.w);\n\n  return mix(\n    mix(sample3, sample2, sx),\n    mix(sample1, sample0, sx),\n    sy\n  );\n}\n\n\n\n\nuniform sampler2D topographyMap;\nuniform sampler2D diffuseMap;\nuniform sampler2D landmaskMap;\nuniform sampler2D bordersMap;\nuniform vec2 bordersMapSize;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\n\nvoid main() {\n  vec3 constantLight = vNormal;\n  vec3 V = vNormal;\n\n  float landness = texture2D(landmaskMap, vUv, -0.25).r;\n  float countryBorder = texture2D(bordersMap, vUv, -0.25).r;\n  float oceanDepth = (0.5 - texture2D(topographyMap, vUv).r) * 2.0;\n\n  vec3 oceanColor = mix(\n    vec3(0.1, 0.15, 0.45),\n    vec3(0.1, 0.15, 0.35),\n    oceanDepth\n  );\n\n  vec3 diffuseColor = mix(\n    oceanColor,\n    toLinear_5_1(texture2D(diffuseMap, vUv).rgb),\n    landness\n  );\n\n  vec3 N = vNormal;\n  vec3 L = normalize(constantLight);\n  vec3 H = normalize(L + V);\n\n  float roughness = mix(\n    mix(0.75, 0.55, oceanDepth),\n    (1.0 - diffuseColor.r * 0.5),\n    landness\n  );\n\n  vec3 color = vec3(0.0);\n  if (dot(vNormal, L) > 0.0) {\n    vec3 lightColor = vec3(10.0);\n\n    color = lightColor * brdf_3_28(\n      diffuseColor,\n      0.0, //metallic\n      0.5, //subsurface\n      0.0, //specular\n      roughness, //roughness\n      L, V, N\n    );\n  }\n\n  vec3 shaded = toGamma_6_3(tonemap_1_12(color * 1.0));\n  vec3 final = shaded + countryBorder;\n  gl_FragColor = vec4(final, 1.0);\n}\n';
}),require.register("shaders/dayAndNight.frag.glsl",function(e,n,t){t.exports='#extension GL_OES_standard_derivatives : enable\nprecision highp float;\n#define GLSLIFY 1\n\nconst float gamma_10_0 = 2.2;\n\nfloat toLinear_10_1(float v) {\n  return pow(v, gamma_10_0);\n}\n\nvec2 toLinear_10_1(vec2 v) {\n  return pow(v, vec2(gamma_10_0));\n}\n\nvec3 toLinear_10_1(vec3 v) {\n  return pow(v, vec3(gamma_10_0));\n}\n\nvec4 toLinear_10_1(vec4 v) {\n  return vec4(toLinear_10_1(v.rgb), v.a);\n}\n\n\n\nconst float gamma_11_2 = 2.2;\n\nfloat toGamma_11_3(float v) {\n  return pow(v, 1.0 / gamma_11_2);\n}\n\nvec2 toGamma_11_3(vec2 v) {\n  return pow(v, vec2(1.0 / gamma_11_2));\n}\n\nvec3 toGamma_11_3(vec3 v) {\n  return pow(v, vec3(1.0 / gamma_11_2));\n}\n\nvec4 toGamma_11_3(vec4 v) {\n  return vec4(toGamma_11_3(v.rgb), v.a);\n}\n\n\n\n\n// Based on:\n// http://stackoverflow.com/questions/13501081/efficient-bicubic-filtering-code-in-glsl\n\nvec4 cubic_9_4(float v) {\n  vec4 n = vec4(1.0, 2.0, 3.0, 4.0) - v;\n  vec4 s = n * n * n;\n  float x = s.x;\n  float y = s.y - 4.0 * s.x;\n  float z = s.z - 4.0 * s.y + 6.0 * s.x;\n  float w = 6.0 - x - y - z;\n  return vec4(x, y, z, w);\n}\n\nvec4 texture2DCubic_9_5(\n  sampler2D tex,\n  vec2 uv,\n  vec2 textureResolution\n) {\n  vec2 texcoord = uv * textureResolution;\n  texcoord -= vec2(0.5);\n  float fx = fract(texcoord.x);\n  float fy = fract(texcoord.y);\n  texcoord.x -= fx;\n  texcoord.y -= fy;\n\n  vec4 xcubic = cubic_9_4(fx);\n  vec4 ycubic = cubic_9_4(fy);\n\n  vec4 c = vec4(\n    texcoord.x - 0.5,\n    texcoord.x + 1.5,\n    texcoord.y - 0.5,\n    texcoord.y + 1.5\n  );\n\n  vec4 s = vec4(\n    xcubic.x + xcubic.y,\n    xcubic.z + xcubic.w,\n    ycubic.x + ycubic.y,\n    ycubic.z + ycubic.w\n  );\n\n  vec4 offset = c + vec4(\n    xcubic.y,\n    xcubic.w,\n    ycubic.y,\n    ycubic.w\n  ) / s;\n\n  vec4 sample0 = texture2D(tex,\n    vec2(offset.x, offset.z) / textureResolution);\n\n  vec4 sample1 = texture2D(tex,\n    vec2(offset.y, offset.z) / textureResolution);\n\n  vec4 sample2 = texture2D(tex,\n    vec2(offset.x, offset.w) / textureResolution);\n\n  vec4 sample3 = texture2D(tex,\n    vec2(offset.y, offset.w) / textureResolution);\n\n  float sx = s.x / (s.x + s.y);\n  float sy = s.z / (s.z + s.w);\n\n  return mix(\n    mix(sample3, sample2, sx),\n    mix(sample1, sample0, sx),\n    sy\n  );\n}\n\n\n\n\n// Based on https://docs.unrealengine.com/latest/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf\n\nvec2 heightDerivative_1_6(\n  vec2 texST,\n  sampler2D map,\n  vec2 textureResolution\n) {\n  vec2 TexDx = dFdx(texST);\n  vec2 TexDy = dFdy(texST);\n  vec2 STll = texST;\n  vec2 STlr = texST + TexDx;\n  vec2 STul = texST + TexDy;\n  float Hll = texture2DCubic_9_5(map, STll, textureResolution).x;\n  float Hlr = texture2DCubic_9_5(map, STlr, textureResolution).x;\n  float Hul = texture2DCubic_9_5(map, STul, textureResolution).x;\n  float dBs = Hlr - Hll;\n  float dBt = Hul - Hll;\n  return vec2(dBs, dBt);\n}\n\n\n\n// Based on https://docs.unrealengine.com/latest/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf\n\nvec3 perturbNormal_2_7(vec3 surf_pos, vec3 surf_norm, vec2 dHdxy) {\n  // Calling derivatives per-component to address android bug:\n  // http://stackoverflow.com/questions/20272272/\n  vec3 vSigmaX = vec3(dFdx(surf_pos.x), dFdx(surf_pos.y), dFdx(surf_pos.z));\n  vec3 vSigmaY = vec3(dFdy(surf_pos.x), dFdy(surf_pos.y), dFdy(surf_pos.z));\n  vec3 vN = vec3(normalize(surf_norm)); // normalized\n  vec3 R1 = cross(vSigmaY, vN);\n  vec3 R2 = cross(vN, vSigmaX);\n\n  float fDet = dot(vSigmaX, R1);\n  vec3 vGrad = sign(fDet) * (dHdxy.x * R1 + dHdxy.y * R2);\n  return normalize(abs(fDet) * surf_norm - vGrad);\n}\n\n\n\n// Based on https://github.com/vorg/pragmatic-pbr/blob/master/local_modules/glsl-tonemap-uncharted2/index.glsl\nfloat A_3_8 = 0.15;\nfloat B_3_9 = 0.50;\nfloat C_3_10 = 0.10;\nfloat D_3_11 = 0.20;\nfloat E_3_12 = 0.02;\nfloat F_3_13 = 0.30;\nfloat W_3_14 = 11.2;\n\nvec3 Uncharted2Tonemap_3_15(vec3 x) {\n   return ((x * (A_3_8 * x + C_3_10 * B_3_9) + D_3_11 * E_3_12) / (x * (A_3_8 * x + B_3_9) + D_3_11 * F_3_13)) - E_3_12 / F_3_13;\n}\n\n// Based on Filmic Tonemapping Operators http://filmicgames.com/archives/75\nvec3 tonemap_3_16(vec3 color) {\n    float ExposureBias = 2.0;\n    vec3 curr = Uncharted2Tonemap_3_15(ExposureBias * color);\n\n    vec3 whiteScale = 1.0 / Uncharted2Tonemap_3_15(vec3(W_3_14));\n    return curr * whiteScale;\n}\n\n\n\n// Set camera exposure based on angle between sun and eye\n\nfloat exposure_4_17(vec3 eye, vec3 L) {\n  return mix(\n    1.5,\n    300.0,\n    pow((1.0 - dot(normalize(eye), L)) / 2.0, 10.0)\n  );\n}\n\n\n\n// Scale bump map effect to produce relatively even relief\n// shading across surface. Goal is to avoid too much shading\n// at glancing angles and too little shading in the center.\n//\n// Also, allow for an additional bump scale factor with\n// `oceanFactor`. This allows ocean floor rendering to show\n// full bumps vs ocean surface rendering being flat.\n\nfloat terrainBumpScale_6_18(\n  float landness,\n  float oceanFactor,\n  float vNdotL,\n  float vNdotV,\n  vec3 vEye,\n  vec3 vPosition\n) {\n  float shadowStart = 0.25;\n  float bumpFalloff = clamp(vNdotL / shadowStart, 0.0, 0.5);\n\n  float bumpScale = mix(\n    0.005,\n    0.05,\n    vNdotL * vNdotL * vNdotV\n  ) * bumpFalloff;\n\n  if (landness < 0.5) {\n    bumpScale *= -oceanFactor;\n  }\n\n  return bumpScale;\n}\n\n\n\nvec3 atmosphere_5_19(float NdotL, float NdotV, vec3 color) {\n  return (\n    max(pow(NdotL, 2.0), 0.0) *\n    pow(1.0 - NdotV, 12.0)\n  ) * color;\n}\n\n\n\nvec3 nightAmbient_7_20(\n  float NdotL,\n  vec3 diffuseColor,\n  float nightLightAmount,\n  vec2 vUv\n) {\n  return 0.01 * (\n    nightLightAmount * vec3(1.0, 1.0, 0.8) +\n    0.1 * vec3(0.1, 0.1, 1.0) * diffuseColor\n  ) * clamp((-NdotL + 0.01) * 2.0, 0.0, 1.0);\n}\n\n\n\n/*\nModified from https://github.com/wdas/brdf/blob/master/src/brdfs/disney.brdf\n\nOriginal license notice:\n# Copyright Disney Enterprises, Inc.  All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the "License");\n# you may not use this file except in compliance with the License\n# and the following modification to it: Section 6 Trademarks.\n# deleted and replaced with:\n#\n# 6. Trademarks. This License does not grant permission to use the\n# trade names, trademarks, service marks, or product names of the\n# Licensor and its affiliates, except as required for reproducing\n# the content of the NOTICE file.\n#\n# You may obtain a copy of the License at\n# http://www.apache.org/licenses/LICENSE-2.0\n*/\n\nfloat specularTint_8_21 = 0.0;\nfloat anisotropic_8_22 = 0.0;\nfloat sheen_8_23 = 0.0;\nfloat sheenTint_8_24 = 0.5;\nfloat clearcoat_8_25 = 0.0;\nfloat clearcoatGloss_8_26 = 1.0;\n\nconst float PI_8_27 = 3.14159265358979323846;\n\nfloat sqr_8_28(float x) { return x*x; }\n\nfloat SchlickFresnel_8_29(float u) {\n  float m = clamp(1.0 - u, 0.0, 1.0);\n  float m2 = m * m;\n  return m2 * m2 * m; // pow(m, 5)\n}\n\nfloat GTR1_8_30(float NdotH, float a) {\n  if (a >= 1.0) return 1.0 / PI_8_27;\n  float a2 = a * a;\n  float t = 1.0 + (a2 - 1.0) * NdotH * NdotH;\n  return (a2 - 1.0) / (PI_8_27 * log(a2) * t);\n}\n\nfloat GTR2_8_31(float NdotH, float a) {\n  float a2 = a * a;\n  float t = 1.0 + (a2 - 1.0) * NdotH * NdotH;\n  return a2 / (PI_8_27 * t * t);\n}\n\nfloat GTR2_aniso_8_32(float NdotH, float HdotX, float HdotY, float ax, float ay) {\n  return 1.0 / (\n    PI_8_27 * ax * ay *\n    sqr_8_28(sqr_8_28(HdotX / ax) + sqr_8_28(HdotY / ay) + NdotH * NdotH)\n  );\n}\n\nfloat smithG_GGX_8_33(float Ndotv, float alphaG) {\n  float a = alphaG * alphaG;\n  float b = Ndotv * Ndotv;\n  return 1.0 / (Ndotv + sqrt(a + b - a * b));\n}\n\nvec3 mon2lin_8_34(vec3 x) {\n  return vec3(pow(x[0], 2.2), pow(x[1], 2.2), pow(x[2], 2.2));\n}\n\nvec3 brdf_8_35(\n  vec3 baseColor,\n  float metallic,\n  float subsurface,\n  float specular,\n  float roughness,\n  vec3 L, vec3 V, vec3 N\n) {\n  float NdotL = dot(N, L);\n  float NdotV = dot(N, V);\n\n  vec3 H = normalize(L + V);\n  float NdotH = dot(N, H);\n  float LdotH = dot(L, H);\n\n  vec3 Cdlin = mon2lin_8_34(baseColor);\n  float Cdlum = 0.3 * Cdlin[0] + 0.6 * Cdlin[1]  + 0.1 * Cdlin[2]; // luminance approx.\n\n  vec3 Ctint = Cdlum > 0.0 ? Cdlin / Cdlum : vec3(1.0); // normalize lum. to isolate hue+sat\n  vec3 Cspec0 = mix(specular * .08 * mix(vec3(1.0), Ctint, specularTint_8_21), Cdlin, metallic);\n  vec3 Csheen = mix(vec3(1.0), Ctint, sheenTint_8_24);\n\n  // Diffuse fresnel - go from 1 at normal incidence to .5 at grazing\n  // and mix in diffuse retro-reflection based on roughness\n  float FL = SchlickFresnel_8_29(NdotL), FV = SchlickFresnel_8_29(NdotV);\n  float Fd90 = 0.5 + 2.0 * LdotH * LdotH * roughness;\n  float Fd = mix(1.0, Fd90, FL) * mix(1.0, Fd90, FV);\n\n  // Based on Hanrahan-Krueger brdf approximation of isotropic bssrdf\n  // 1.25 scale is used to (roughly) preserve albedo\n  // Fss90 used to "flatten" retroreflection based on roughness\n  float Fss90 = LdotH * LdotH * roughness;\n  float Fss = mix(1.0, Fss90, FL) * mix(1.0, Fss90, FV);\n  float ss = 1.25 * (Fss * (1.0 / (NdotL + NdotV) - 0.5) + 0.5);\n\n  // specular\n  float Ds = GTR2_8_31(NdotH, max(0.001, sqr_8_28(roughness)));\n  float FH = SchlickFresnel_8_29(LdotH);\n  vec3 Fs = mix(Cspec0, vec3(1.0), FH);\n  float roughg = sqr_8_28(roughness * 0.5 + 0.5);\n  float Gs = smithG_GGX_8_33(NdotL, roughg) * smithG_GGX_8_33(NdotV, roughg);\n\n  // sheen\n  vec3 Fsheen = FH * sheen_8_23 * Csheen;\n\n  // clearcoat (ior = 1.5 -> F0 = 0.04)\n  float Dr = GTR1_8_30(NdotH, mix(0.1, 0.001, clearcoatGloss_8_26));\n  float Fr = mix(0.04, 1.0, FH);\n  float Gr = smithG_GGX_8_33(NdotL, 0.25) * smithG_GGX_8_33(NdotV, 0.25);\n\n  return ((1.0/PI_8_27) * mix(Fd, ss, subsurface) * Cdlin + Fsheen)\n    * (1.0 - metallic) +\n    Gs * Fs * Ds +\n    0.25 * clearcoat_8_25 * Gr * Fr * Dr;\n}\n\n\n\n\n\nuniform sampler2D topographyMap;\nuniform vec2 topographyMapSize;\nuniform sampler2D diffuseMap;\nuniform sampler2D landmaskMap;\nuniform sampler2D bordersMap;\nuniform vec2 bordersMapSize;\nuniform sampler2D lightsMap;\nuniform vec3 lightDirection;\nuniform vec3 eye;\n\nvarying vec2 vUv;\nvarying vec3 vPosition;\nvarying vec3 vNormal;\n\nvoid main() {\n  vec3 V = normalize(eye - vPosition);\n  float vNdotL = dot(vNormal, lightDirection);\n  float vNdotL_clamped = clamp(vNdotL, 0.0, 1.0);\n  float vNdotV = dot(vNormal, V);\n  float vNdotV_clamped = clamp(vNdotV, 0.0, 1.0);\n\n  float landness = texture2D(landmaskMap, vUv, -0.25).r;\n  float countryBorder = texture2D(bordersMap, vUv, -0.25).r;\n  float oceanDepth = (0.5 - texture2D(topographyMap, vUv).r) * 2.0;\n\n  vec2 dHdxy = heightDerivative_1_6(\n    vUv,\n    topographyMap,\n    topographyMapSize\n  );\n\n  dHdxy *= terrainBumpScale_6_18(\n    landness,\n    0.0,\n    vNdotL,\n    vNdotV,\n    eye,\n    vPosition\n  );\n\n  vec3 oceanColor = mix(\n    vec3(0.0, 0.0, 0.35),\n    vec3(0.0, 0.0, 0.3),\n    oceanDepth\n  );\n\n  vec3 diffuseColor = mix(\n    oceanColor,\n    toLinear_10_1(texture2D(diffuseMap, vUv).rgb),\n    landness\n  );\n\n  vec3 N = perturbNormal_2_7(normalize(vPosition), vNormal, dHdxy);\n  vec3 L = normalize(lightDirection);\n  vec3 H = normalize(L + V);\n\n  float roughness = mix(\n    mix(0.6, 0.8, oceanDepth),\n    (1.0 - diffuseColor.r * 0.5),\n    smoothstep(0.25, 0.75, landness)\n  );\n\n  vec3 color = nightAmbient_7_20(\n    vNdotL,\n    diffuseColor,\n    texture2D(lightsMap, vUv).x,\n    vUv\n  );\n\n  if (dot(vNormal, L) > 0.0) {\n    vec3 lightColor = vec3(8.0);\n\n    float incidence = pow(dot(N, L), 1.5);\n\n    color = lightColor * incidence * brdf_8_35(\n      diffuseColor,\n      0.0, //metallic\n      0.5, //subsurface\n      0.3, //specular\n      roughness, //roughness\n      L, V, N\n    );\n\n    color += atmosphere_5_19(\n      vNdotL_clamped,\n      vNdotV_clamped,\n      vec3(0.1, 0.1, 1.0) * 20.0\n    );\n  }\n\n  vec3 shaded = toGamma_11_3(tonemap_3_16(color * exposure_4_17(eye, L)));\n  vec3 final = shaded + countryBorder;\n  gl_FragColor = vec4(final, 1.0);\n}\n'}),require.register("shaders/elevation.frag.glsl",function(e,n,t){t.exports='#extension GL_OES_standard_derivatives : enable\nprecision highp float;\n#define GLSLIFY 1\n\nconst float gamma_10_0 = 2.2;\n\nfloat toLinear_10_1(float v) {\n  return pow(v, gamma_10_0);\n}\n\nvec2 toLinear_10_1(vec2 v) {\n  return pow(v, vec2(gamma_10_0));\n}\n\nvec3 toLinear_10_1(vec3 v) {\n  return pow(v, vec3(gamma_10_0));\n}\n\nvec4 toLinear_10_1(vec4 v) {\n  return vec4(toLinear_10_1(v.rgb), v.a);\n}\n\n\n\nconst float gamma_11_2 = 2.2;\n\nfloat toGamma_11_3(float v) {\n  return pow(v, 1.0 / gamma_11_2);\n}\n\nvec2 toGamma_11_3(vec2 v) {\n  return pow(v, vec2(1.0 / gamma_11_2));\n}\n\nvec3 toGamma_11_3(vec3 v) {\n  return pow(v, vec3(1.0 / gamma_11_2));\n}\n\nvec4 toGamma_11_3(vec4 v) {\n  return vec4(toGamma_11_3(v.rgb), v.a);\n}\n\n\n\n\n// Based on:\n// http://stackoverflow.com/questions/13501081/efficient-bicubic-filtering-code-in-glsl\n\nvec4 cubic_9_4(float v) {\n  vec4 n = vec4(1.0, 2.0, 3.0, 4.0) - v;\n  vec4 s = n * n * n;\n  float x = s.x;\n  float y = s.y - 4.0 * s.x;\n  float z = s.z - 4.0 * s.y + 6.0 * s.x;\n  float w = 6.0 - x - y - z;\n  return vec4(x, y, z, w);\n}\n\nvec4 texture2DCubic_9_5(\n  sampler2D tex,\n  vec2 uv,\n  vec2 textureResolution\n) {\n  vec2 texcoord = uv * textureResolution;\n  texcoord -= vec2(0.5);\n  float fx = fract(texcoord.x);\n  float fy = fract(texcoord.y);\n  texcoord.x -= fx;\n  texcoord.y -= fy;\n\n  vec4 xcubic = cubic_9_4(fx);\n  vec4 ycubic = cubic_9_4(fy);\n\n  vec4 c = vec4(\n    texcoord.x - 0.5,\n    texcoord.x + 1.5,\n    texcoord.y - 0.5,\n    texcoord.y + 1.5\n  );\n\n  vec4 s = vec4(\n    xcubic.x + xcubic.y,\n    xcubic.z + xcubic.w,\n    ycubic.x + ycubic.y,\n    ycubic.z + ycubic.w\n  );\n\n  vec4 offset = c + vec4(\n    xcubic.y,\n    xcubic.w,\n    ycubic.y,\n    ycubic.w\n  ) / s;\n\n  vec4 sample0 = texture2D(tex,\n    vec2(offset.x, offset.z) / textureResolution);\n\n  vec4 sample1 = texture2D(tex,\n    vec2(offset.y, offset.z) / textureResolution);\n\n  vec4 sample2 = texture2D(tex,\n    vec2(offset.x, offset.w) / textureResolution);\n\n  vec4 sample3 = texture2D(tex,\n    vec2(offset.y, offset.w) / textureResolution);\n\n  float sx = s.x / (s.x + s.y);\n  float sy = s.z / (s.z + s.w);\n\n  return mix(\n    mix(sample3, sample2, sx),\n    mix(sample1, sample0, sx),\n    sy\n  );\n}\n\n\n\n\n// Based on https://docs.unrealengine.com/latest/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf\n\nvec2 heightDerivative_1_6(\n  vec2 texST,\n  sampler2D map,\n  vec2 textureResolution\n) {\n  vec2 TexDx = dFdx(texST);\n  vec2 TexDy = dFdy(texST);\n  vec2 STll = texST;\n  vec2 STlr = texST + TexDx;\n  vec2 STul = texST + TexDy;\n  float Hll = texture2DCubic_9_5(map, STll, textureResolution).x;\n  float Hlr = texture2DCubic_9_5(map, STlr, textureResolution).x;\n  float Hul = texture2DCubic_9_5(map, STul, textureResolution).x;\n  float dBs = Hlr - Hll;\n  float dBt = Hul - Hll;\n  return vec2(dBs, dBt);\n}\n\n\n\n// Based on https://docs.unrealengine.com/latest/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf\n\nvec3 perturbNormal_2_7(vec3 surf_pos, vec3 surf_norm, vec2 dHdxy) {\n  // Calling derivatives per-component to address android bug:\n  // http://stackoverflow.com/questions/20272272/\n  vec3 vSigmaX = vec3(dFdx(surf_pos.x), dFdx(surf_pos.y), dFdx(surf_pos.z));\n  vec3 vSigmaY = vec3(dFdy(surf_pos.x), dFdy(surf_pos.y), dFdy(surf_pos.z));\n  vec3 vN = vec3(normalize(surf_norm)); // normalized\n  vec3 R1 = cross(vSigmaY, vN);\n  vec3 R2 = cross(vN, vSigmaX);\n\n  float fDet = dot(vSigmaX, R1);\n  vec3 vGrad = sign(fDet) * (dHdxy.x * R1 + dHdxy.y * R2);\n  return normalize(abs(fDet) * surf_norm - vGrad);\n}\n\n\n\n// Based on https://github.com/vorg/pragmatic-pbr/blob/master/local_modules/glsl-tonemap-uncharted2/index.glsl\nfloat A_3_8 = 0.15;\nfloat B_3_9 = 0.50;\nfloat C_3_10 = 0.10;\nfloat D_3_11 = 0.20;\nfloat E_3_12 = 0.02;\nfloat F_3_13 = 0.30;\nfloat W_3_14 = 11.2;\n\nvec3 Uncharted2Tonemap_3_15(vec3 x) {\n   return ((x * (A_3_8 * x + C_3_10 * B_3_9) + D_3_11 * E_3_12) / (x * (A_3_8 * x + B_3_9) + D_3_11 * F_3_13)) - E_3_12 / F_3_13;\n}\n\n// Based on Filmic Tonemapping Operators http://filmicgames.com/archives/75\nvec3 tonemap_3_16(vec3 color) {\n    float ExposureBias = 2.0;\n    vec3 curr = Uncharted2Tonemap_3_15(ExposureBias * color);\n\n    vec3 whiteScale = 1.0 / Uncharted2Tonemap_3_15(vec3(W_3_14));\n    return curr * whiteScale;\n}\n\n\n\n// Set camera exposure based on angle between sun and eye\n\nfloat exposure_4_17(vec3 eye, vec3 L) {\n  return mix(\n    1.5,\n    300.0,\n    pow((1.0 - dot(normalize(eye), L)) / 2.0, 10.0)\n  );\n}\n\n\n\n// Scale bump map effect to produce relatively even relief\n// shading across surface. Goal is to avoid too much shading\n// at glancing angles and too little shading in the center.\n//\n// Also, allow for an additional bump scale factor with\n// `oceanFactor`. This allows ocean floor rendering to show\n// full bumps vs ocean surface rendering being flat.\n\nfloat terrainBumpScale_5_18(\n  float landness,\n  float oceanFactor,\n  float vNdotL,\n  float vNdotV,\n  vec3 vEye,\n  vec3 vPosition\n) {\n  float shadowStart = 0.25;\n  float bumpFalloff = clamp(vNdotL / shadowStart, 0.0, 0.5);\n\n  float bumpScale = mix(\n    0.005,\n    0.05,\n    vNdotL * vNdotL * vNdotV\n  ) * bumpFalloff;\n\n  if (landness < 0.5) {\n    bumpScale *= -oceanFactor;\n  }\n\n  return bumpScale;\n}\n\n\n\nvec3 atmosphere_6_19(float NdotL, float NdotV, vec3 color) {\n  return (\n    max(pow(NdotL, 2.0), 0.0) *\n    pow(1.0 - NdotV, 12.0)\n  ) * color;\n}\n\n\n\nvec3 nightAmbient_7_20(\n  float NdotL,\n  vec3 diffuseColor,\n  float nightLightAmount,\n  vec2 vUv\n) {\n  return 0.01 * (\n    nightLightAmount * vec3(1.0, 1.0, 0.8) +\n    0.1 * vec3(0.1, 0.1, 1.0) * diffuseColor\n  ) * clamp((-NdotL + 0.01) * 2.0, 0.0, 1.0);\n}\n\n\n\n/*\nModified from https://github.com/wdas/brdf/blob/master/src/brdfs/disney.brdf\n\nOriginal license notice:\n# Copyright Disney Enterprises, Inc.  All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the "License");\n# you may not use this file except in compliance with the License\n# and the following modification to it: Section 6 Trademarks.\n# deleted and replaced with:\n#\n# 6. Trademarks. This License does not grant permission to use the\n# trade names, trademarks, service marks, or product names of the\n# Licensor and its affiliates, except as required for reproducing\n# the content of the NOTICE file.\n#\n# You may obtain a copy of the License at\n# http://www.apache.org/licenses/LICENSE-2.0\n*/\n\nfloat specularTint_8_21 = 0.0;\nfloat anisotropic_8_22 = 0.0;\nfloat sheen_8_23 = 0.0;\nfloat sheenTint_8_24 = 0.5;\nfloat clearcoat_8_25 = 0.0;\nfloat clearcoatGloss_8_26 = 1.0;\n\nconst float PI_8_27 = 3.14159265358979323846;\n\nfloat sqr_8_28(float x) { return x*x; }\n\nfloat SchlickFresnel_8_29(float u) {\n  float m = clamp(1.0 - u, 0.0, 1.0);\n  float m2 = m * m;\n  return m2 * m2 * m; // pow(m, 5)\n}\n\nfloat GTR1_8_30(float NdotH, float a) {\n  if (a >= 1.0) return 1.0 / PI_8_27;\n  float a2 = a * a;\n  float t = 1.0 + (a2 - 1.0) * NdotH * NdotH;\n  return (a2 - 1.0) / (PI_8_27 * log(a2) * t);\n}\n\nfloat GTR2_8_31(float NdotH, float a) {\n  float a2 = a * a;\n  float t = 1.0 + (a2 - 1.0) * NdotH * NdotH;\n  return a2 / (PI_8_27 * t * t);\n}\n\nfloat GTR2_aniso_8_32(float NdotH, float HdotX, float HdotY, float ax, float ay) {\n  return 1.0 / (\n    PI_8_27 * ax * ay *\n    sqr_8_28(sqr_8_28(HdotX / ax) + sqr_8_28(HdotY / ay) + NdotH * NdotH)\n  );\n}\n\nfloat smithG_GGX_8_33(float Ndotv, float alphaG) {\n  float a = alphaG * alphaG;\n  float b = Ndotv * Ndotv;\n  return 1.0 / (Ndotv + sqrt(a + b - a * b));\n}\n\nvec3 mon2lin_8_34(vec3 x) {\n  return vec3(pow(x[0], 2.2), pow(x[1], 2.2), pow(x[2], 2.2));\n}\n\nvec3 brdf_8_35(\n  vec3 baseColor,\n  float metallic,\n  float subsurface,\n  float specular,\n  float roughness,\n  vec3 L, vec3 V, vec3 N\n) {\n  float NdotL = dot(N, L);\n  float NdotV = dot(N, V);\n\n  vec3 H = normalize(L + V);\n  float NdotH = dot(N, H);\n  float LdotH = dot(L, H);\n\n  vec3 Cdlin = mon2lin_8_34(baseColor);\n  float Cdlum = 0.3 * Cdlin[0] + 0.6 * Cdlin[1]  + 0.1 * Cdlin[2]; // luminance approx.\n\n  vec3 Ctint = Cdlum > 0.0 ? Cdlin / Cdlum : vec3(1.0); // normalize lum. to isolate hue+sat\n  vec3 Cspec0 = mix(specular * .08 * mix(vec3(1.0), Ctint, specularTint_8_21), Cdlin, metallic);\n  vec3 Csheen = mix(vec3(1.0), Ctint, sheenTint_8_24);\n\n  // Diffuse fresnel - go from 1 at normal incidence to .5 at grazing\n  // and mix in diffuse retro-reflection based on roughness\n  float FL = SchlickFresnel_8_29(NdotL), FV = SchlickFresnel_8_29(NdotV);\n  float Fd90 = 0.5 + 2.0 * LdotH * LdotH * roughness;\n  float Fd = mix(1.0, Fd90, FL) * mix(1.0, Fd90, FV);\n\n  // Based on Hanrahan-Krueger brdf approximation of isotropic bssrdf\n  // 1.25 scale is used to (roughly) preserve albedo\n  // Fss90 used to "flatten" retroreflection based on roughness\n  float Fss90 = LdotH * LdotH * roughness;\n  float Fss = mix(1.0, Fss90, FL) * mix(1.0, Fss90, FV);\n  float ss = 1.25 * (Fss * (1.0 / (NdotL + NdotV) - 0.5) + 0.5);\n\n  // specular\n  float Ds = GTR2_8_31(NdotH, max(0.001, sqr_8_28(roughness)));\n  float FH = SchlickFresnel_8_29(LdotH);\n  vec3 Fs = mix(Cspec0, vec3(1.0), FH);\n  float roughg = sqr_8_28(roughness * 0.5 + 0.5);\n  float Gs = smithG_GGX_8_33(NdotL, roughg) * smithG_GGX_8_33(NdotV, roughg);\n\n  // sheen\n  vec3 Fsheen = FH * sheen_8_23 * Csheen;\n\n  // clearcoat (ior = 1.5 -> F0 = 0.04)\n  float Dr = GTR1_8_30(NdotH, mix(0.1, 0.001, clearcoatGloss_8_26));\n  float Fr = mix(0.04, 1.0, FH);\n  float Gr = smithG_GGX_8_33(NdotL, 0.25) * smithG_GGX_8_33(NdotV, 0.25);\n\n  return ((1.0/PI_8_27) * mix(Fd, ss, subsurface) * Cdlin + Fsheen)\n    * (1.0 - metallic) +\n    Gs * Fs * Ds +\n    0.25 * clearcoat_8_25 * Gr * Fr * Dr;\n}\n\n\n\n\nuniform sampler2D topographyMap;\nuniform sampler2D diffuseMap;\nuniform sampler2D landmaskMap;\nuniform sampler2D bordersMap;\nuniform sampler2D lightsMap;\nuniform vec3 lightDirection;\nuniform vec3 eye;\n\nvarying vec2 vUv;\nvarying vec3 vPosition;\nvarying vec3 vNormal;\n\nvoid main() {\n  vec3 constantLight = vNormal;\n  vec3 V = vNormal;\n\n  float landness = texture2D(landmaskMap, vUv, -0.25).r;\n  float countryBorder = texture2D(bordersMap, vUv, -0.25).r;\n  float elevation = texture2D(topographyMap, vUv).r;\n\n  float steps = 16.0;\n  vec3 diffuseColor = vec3(1.0, 0.75, 0.5) *\n    floor((elevation / 0.9) * steps) / steps;\n\n  if (landness < 0.5) {\n    diffuseColor =vec3(0.25, 0.5, 1.0) *\n    floor((elevation / 0.9) * steps) / steps;\n  }\n\n  // Outline the transition from land to sea\n  diffuseColor = mix(\n    diffuseColor,\n    vec3(0.0, 0.0, 0.5),\n    pow(1.0 - abs(landness - 0.5) * 2.0, 1.0)\n  );\n\n  vec3 N = vNormal;\n  vec3 L = normalize(constantLight);\n  vec3 H = normalize(L + V);\n\n  vec3 color = vec3(0.0);\n  if (dot(vNormal, L) > 0.0) {\n    vec3 lightColor = vec3(20.0);\n\n    color = lightColor * brdf_8_35(\n      diffuseColor,\n      0.0, //metallic\n      0.5, //subsurface\n      0.3, //specular\n      0.99, //roughness\n      L, V, N\n    );\n\n    color += atmosphere_6_19(\n      dot(vNormal, L),\n      dot(vNormal, normalize(eye - vPosition)),\n      vec3(5.0)\n    );\n  }\n\n  vec3 shaded = toGamma_11_3(tonemap_3_16(color * 0.5));\n  vec3 final = shaded + countryBorder;\n  gl_FragColor = vec4(final, 1.0);\n}\n'}),require.register("shaders/functions/atmosphere.glsl",function(e,n,t){t.exports="#define GLSLIFY 1\nvec3 atmosphere(float NdotL, float NdotV, vec3 color) {\n  return (\n    max(pow(NdotL, 2.0), 0.0) *\n    pow(1.0 - NdotV, 12.0)\n  ) * color;\n}\n\n\n"}),require.register("shaders/functions/brdf.glsl",function(e,n,t){t.exports='#define GLSLIFY 1\n/*\nModified from https://github.com/wdas/brdf/blob/master/src/brdfs/disney.brdf\n\nOriginal license notice:\n# Copyright Disney Enterprises, Inc.  All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the "License");\n# you may not use this file except in compliance with the License\n# and the following modification to it: Section 6 Trademarks.\n# deleted and replaced with:\n#\n# 6. Trademarks. This License does not grant permission to use the\n# trade names, trademarks, service marks, or product names of the\n# Licensor and its affiliates, except as required for reproducing\n# the content of the NOTICE file.\n#\n# You may obtain a copy of the License at\n# http://www.apache.org/licenses/LICENSE-2.0\n*/\n\nfloat specularTint = 0.0;\nfloat anisotropic = 0.0;\nfloat sheen = 0.0;\nfloat sheenTint = 0.5;\nfloat clearcoat = 0.0;\nfloat clearcoatGloss = 1.0;\n\nconst float PI = 3.14159265358979323846;\n\nfloat sqr(float x) { return x*x; }\n\nfloat SchlickFresnel(float u) {\n  float m = clamp(1.0 - u, 0.0, 1.0);\n  float m2 = m * m;\n  return m2 * m2 * m; // pow(m, 5)\n}\n\nfloat GTR1(float NdotH, float a) {\n  if (a >= 1.0) return 1.0 / PI;\n  float a2 = a * a;\n  float t = 1.0 + (a2 - 1.0) * NdotH * NdotH;\n  return (a2 - 1.0) / (PI * log(a2) * t);\n}\n\nfloat GTR2(float NdotH, float a) {\n  float a2 = a * a;\n  float t = 1.0 + (a2 - 1.0) * NdotH * NdotH;\n  return a2 / (PI * t * t);\n}\n\nfloat GTR2_aniso(float NdotH, float HdotX, float HdotY, float ax, float ay) {\n  return 1.0 / (\n    PI * ax * ay *\n    sqr(sqr(HdotX / ax) + sqr(HdotY / ay) + NdotH * NdotH)\n  );\n}\n\nfloat smithG_GGX(float Ndotv, float alphaG) {\n  float a = alphaG * alphaG;\n  float b = Ndotv * Ndotv;\n  return 1.0 / (Ndotv + sqrt(a + b - a * b));\n}\n\nvec3 mon2lin(vec3 x) {\n  return vec3(pow(x[0], 2.2), pow(x[1], 2.2), pow(x[2], 2.2));\n}\n\nvec3 brdf(\n  vec3 baseColor,\n  float metallic,\n  float subsurface,\n  float specular,\n  float roughness,\n  vec3 L, vec3 V, vec3 N\n) {\n  float NdotL = dot(N, L);\n  float NdotV = dot(N, V);\n\n  vec3 H = normalize(L + V);\n  float NdotH = dot(N, H);\n  float LdotH = dot(L, H);\n\n  vec3 Cdlin = mon2lin(baseColor);\n  float Cdlum = 0.3 * Cdlin[0] + 0.6 * Cdlin[1]  + 0.1 * Cdlin[2]; // luminance approx.\n\n  vec3 Ctint = Cdlum > 0.0 ? Cdlin / Cdlum : vec3(1.0); // normalize lum. to isolate hue+sat\n  vec3 Cspec0 = mix(specular * .08 * mix(vec3(1.0), Ctint, specularTint), Cdlin, metallic);\n  vec3 Csheen = mix(vec3(1.0), Ctint, sheenTint);\n\n  // Diffuse fresnel - go from 1 at normal incidence to .5 at grazing\n  // and mix in diffuse retro-reflection based on roughness\n  float FL = SchlickFresnel(NdotL), FV = SchlickFresnel(NdotV);\n  float Fd90 = 0.5 + 2.0 * LdotH * LdotH * roughness;\n  float Fd = mix(1.0, Fd90, FL) * mix(1.0, Fd90, FV);\n\n  // Based on Hanrahan-Krueger brdf approximation of isotropic bssrdf\n  // 1.25 scale is used to (roughly) preserve albedo\n  // Fss90 used to "flatten" retroreflection based on roughness\n  float Fss90 = LdotH * LdotH * roughness;\n  float Fss = mix(1.0, Fss90, FL) * mix(1.0, Fss90, FV);\n  float ss = 1.25 * (Fss * (1.0 / (NdotL + NdotV) - 0.5) + 0.5);\n\n  // specular\n  float Ds = GTR2(NdotH, max(0.001, sqr(roughness)));\n  float FH = SchlickFresnel(LdotH);\n  vec3 Fs = mix(Cspec0, vec3(1.0), FH);\n  float roughg = sqr(roughness * 0.5 + 0.5);\n  float Gs = smithG_GGX(NdotL, roughg) * smithG_GGX(NdotV, roughg);\n\n  // sheen\n  vec3 Fsheen = FH * sheen * Csheen;\n\n  // clearcoat (ior = 1.5 -> F0 = 0.04)\n  float Dr = GTR1(NdotH, mix(0.1, 0.001, clearcoatGloss));\n  float Fr = mix(0.04, 1.0, FH);\n  float Gr = smithG_GGX(NdotL, 0.25) * smithG_GGX(NdotV, 0.25);\n\n  return ((1.0/PI) * mix(Fd, ss, subsurface) * Cdlin + Fsheen)\n    * (1.0 - metallic) +\n    Gs * Fs * Ds +\n    0.25 * clearcoat * Gr * Fr * Dr;\n}\n\n\n'}),require.register("shaders/functions/exposure.glsl",function(e,n,t){t.exports="#define GLSLIFY 1\n// Set camera exposure based on angle between sun and eye\n\nfloat exposure(vec3 eye, vec3 L) {\n  return mix(\n    1.5,\n    300.0,\n    pow((1.0 - dot(normalize(eye), L)) / 2.0, 10.0)\n  );\n}\n\n\n"}),require.register("shaders/functions/heightDerivative.glsl",function(e,n,t){t.exports="#define GLSLIFY 1\n// Based on:\n// http://stackoverflow.com/questions/13501081/efficient-bicubic-filtering-code-in-glsl\n\nvec4 cubic_1_0(float v) {\n  vec4 n = vec4(1.0, 2.0, 3.0, 4.0) - v;\n  vec4 s = n * n * n;\n  float x = s.x;\n  float y = s.y - 4.0 * s.x;\n  float z = s.z - 4.0 * s.y + 6.0 * s.x;\n  float w = 6.0 - x - y - z;\n  return vec4(x, y, z, w);\n}\n\nvec4 texture2DCubic_1_1(\n  sampler2D tex,\n  vec2 uv,\n  vec2 textureResolution\n) {\n  vec2 texcoord = uv * textureResolution;\n  texcoord -= vec2(0.5);\n  float fx = fract(texcoord.x);\n  float fy = fract(texcoord.y);\n  texcoord.x -= fx;\n  texcoord.y -= fy;\n\n  vec4 xcubic = cubic_1_0(fx);\n  vec4 ycubic = cubic_1_0(fy);\n\n  vec4 c = vec4(\n    texcoord.x - 0.5,\n    texcoord.x + 1.5,\n    texcoord.y - 0.5,\n    texcoord.y + 1.5\n  );\n\n  vec4 s = vec4(\n    xcubic.x + xcubic.y,\n    xcubic.z + xcubic.w,\n    ycubic.x + ycubic.y,\n    ycubic.z + ycubic.w\n  );\n\n  vec4 offset = c + vec4(\n    xcubic.y,\n    xcubic.w,\n    ycubic.y,\n    ycubic.w\n  ) / s;\n\n  vec4 sample0 = texture2D(tex,\n    vec2(offset.x, offset.z) / textureResolution);\n\n  vec4 sample1 = texture2D(tex,\n    vec2(offset.y, offset.z) / textureResolution);\n\n  vec4 sample2 = texture2D(tex,\n    vec2(offset.x, offset.w) / textureResolution);\n\n  vec4 sample3 = texture2D(tex,\n    vec2(offset.y, offset.w) / textureResolution);\n\n  float sx = s.x / (s.x + s.y);\n  float sy = s.z / (s.z + s.w);\n\n  return mix(\n    mix(sample3, sample2, sx),\n    mix(sample1, sample0, sx),\n    sy\n  );\n}\n\n\n\n\n// Based on https://docs.unrealengine.com/latest/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf\n\nvec2 heightDerivative(\n  vec2 texST,\n  sampler2D map,\n  vec2 textureResolution\n) {\n  vec2 TexDx = dFdx(texST);\n  vec2 TexDy = dFdy(texST);\n  vec2 STll = texST;\n  vec2 STlr = texST + TexDx;\n  vec2 STul = texST + TexDy;\n  float Hll = texture2DCubic_1_1(map, STll, textureResolution).x;\n  float Hlr = texture2DCubic_1_1(map, STlr, textureResolution).x;\n  float Hul = texture2DCubic_1_1(map, STul, textureResolution).x;\n  float dBs = Hlr - Hll;\n  float dBt = Hul - Hll;\n  return vec2(dBs, dBt);\n}\n\n\n"}),require.register("shaders/functions/isNan.glsl",function(e,n,t){t.exports="#define GLSLIFY 1\n// Hack isNan for debugging since WebGL doesn't define it\n\nbool isNan(float val) {\n  return (val <= 0.0 || 0.0 <= val) ? false : true;\n}\n\n\n"}),require.register("shaders/functions/nightAmbient.glsl",function(e,n,t){t.exports="#define GLSLIFY 1\nvec3 nightAmbient(\n  float NdotL,\n  vec3 diffuseColor,\n  float nightLightAmount,\n  vec2 vUv\n) {\n  return 0.01 * (\n    nightLightAmount * vec3(1.0, 1.0, 0.8) +\n    0.1 * vec3(0.1, 0.1, 1.0) * diffuseColor\n  ) * clamp((-NdotL + 0.01) * 2.0, 0.0, 1.0);\n}\n\n\n"}),require.register("shaders/functions/perturbNormal.glsl",function(e,n,t){t.exports="#define GLSLIFY 1\n// Based on https://docs.unrealengine.com/latest/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf\n\nvec3 perturbNormal(vec3 surf_pos, vec3 surf_norm, vec2 dHdxy) {\n  // Calling derivatives per-component to address android bug:\n  // http://stackoverflow.com/questions/20272272/\n  vec3 vSigmaX = vec3(dFdx(surf_pos.x), dFdx(surf_pos.y), dFdx(surf_pos.z));\n  vec3 vSigmaY = vec3(dFdy(surf_pos.x), dFdy(surf_pos.y), dFdy(surf_pos.z));\n  vec3 vN = vec3(normalize(surf_norm)); // normalized\n  vec3 R1 = cross(vSigmaY, vN);\n  vec3 R2 = cross(vN, vSigmaX);\n\n  float fDet = dot(vSigmaX, R1);\n  vec3 vGrad = sign(fDet) * (dHdxy.x * R1 + dHdxy.y * R2);\n  return normalize(abs(fDet) * surf_norm - vGrad);\n}\n\n\n";
}),require.register("shaders/functions/terrainBumpScale.glsl",function(e,n,t){t.exports="#define GLSLIFY 1\n// Scale bump map effect to produce relatively even relief\n// shading across surface. Goal is to avoid too much shading\n// at glancing angles and too little shading in the center.\n//\n// Also, allow for an additional bump scale factor with\n// `oceanFactor`. This allows ocean floor rendering to show\n// full bumps vs ocean surface rendering being flat.\n\nfloat terrainBumpScale(\n  float landness,\n  float oceanFactor,\n  float vNdotL,\n  float vNdotV,\n  vec3 vEye,\n  vec3 vPosition\n) {\n  float shadowStart = 0.25;\n  float bumpFalloff = clamp(vNdotL / shadowStart, 0.0, 0.5);\n\n  float bumpScale = mix(\n    0.005,\n    0.05,\n    vNdotL * vNdotL * vNdotV\n  ) * bumpFalloff;\n\n  if (landness < 0.5) {\n    bumpScale *= -oceanFactor;\n  }\n\n  return bumpScale;\n}\n\n\n"}),require.register("shaders/functions/texture2DCubic.glsl",function(e,n,t){t.exports="#define GLSLIFY 1\n// Based on:\n// http://stackoverflow.com/questions/13501081/efficient-bicubic-filtering-code-in-glsl\n\nvec4 cubic(float v) {\n  vec4 n = vec4(1.0, 2.0, 3.0, 4.0) - v;\n  vec4 s = n * n * n;\n  float x = s.x;\n  float y = s.y - 4.0 * s.x;\n  float z = s.z - 4.0 * s.y + 6.0 * s.x;\n  float w = 6.0 - x - y - z;\n  return vec4(x, y, z, w);\n}\n\nvec4 texture2DCubic(\n  sampler2D tex,\n  vec2 uv,\n  vec2 textureResolution\n) {\n  vec2 texcoord = uv * textureResolution;\n  texcoord -= vec2(0.5);\n  float fx = fract(texcoord.x);\n  float fy = fract(texcoord.y);\n  texcoord.x -= fx;\n  texcoord.y -= fy;\n\n  vec4 xcubic = cubic(fx);\n  vec4 ycubic = cubic(fy);\n\n  vec4 c = vec4(\n    texcoord.x - 0.5,\n    texcoord.x + 1.5,\n    texcoord.y - 0.5,\n    texcoord.y + 1.5\n  );\n\n  vec4 s = vec4(\n    xcubic.x + xcubic.y,\n    xcubic.z + xcubic.w,\n    ycubic.x + ycubic.y,\n    ycubic.z + ycubic.w\n  );\n\n  vec4 offset = c + vec4(\n    xcubic.y,\n    xcubic.w,\n    ycubic.y,\n    ycubic.w\n  ) / s;\n\n  vec4 sample0 = texture2D(tex,\n    vec2(offset.x, offset.z) / textureResolution);\n\n  vec4 sample1 = texture2D(tex,\n    vec2(offset.y, offset.z) / textureResolution);\n\n  vec4 sample2 = texture2D(tex,\n    vec2(offset.x, offset.w) / textureResolution);\n\n  vec4 sample3 = texture2D(tex,\n    vec2(offset.y, offset.w) / textureResolution);\n\n  float sx = s.x / (s.x + s.y);\n  float sy = s.z / (s.z + s.w);\n\n  return mix(\n    mix(sample3, sample2, sx),\n    mix(sample1, sample0, sx),\n    sy\n  );\n}\n\n\n"}),require.register("shaders/functions/tonemap.glsl",function(e,n,t){t.exports="#define GLSLIFY 1\n// Based on https://github.com/vorg/pragmatic-pbr/blob/master/local_modules/glsl-tonemap-uncharted2/index.glsl\nfloat A = 0.15;\nfloat B = 0.50;\nfloat C = 0.10;\nfloat D = 0.20;\nfloat E = 0.02;\nfloat F = 0.30;\nfloat W = 11.2;\n\nvec3 Uncharted2Tonemap(vec3 x) {\n   return ((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - E / F;\n}\n\n// Based on Filmic Tonemapping Operators http://filmicgames.com/archives/75\nvec3 tonemap(vec3 color) {\n    float ExposureBias = 2.0;\n    vec3 curr = Uncharted2Tonemap(ExposureBias * color);\n\n    vec3 whiteScale = 1.0 / Uncharted2Tonemap(vec3(W));\n    return curr * whiteScale;\n}\n\n\n"}),require.register("shaders/globe.vert.glsl",function(e,n,t){t.exports="precision highp float;\n#define GLSLIFY 1\n\nfloat transpose_1_0(float m) {\n  return m;\n}\n\nmat2 transpose_1_0(mat2 m) {\n  return mat2(m[0][0], m[1][0],\n              m[0][1], m[1][1]);\n}\n\nmat3 transpose_1_0(mat3 m) {\n  return mat3(m[0][0], m[1][0], m[2][0],\n              m[0][1], m[1][1], m[2][1],\n              m[0][2], m[1][2], m[2][2]);\n}\n\nmat4 transpose_1_0(mat4 m) {\n  return mat4(m[0][0], m[1][0], m[2][0], m[3][0],\n              m[0][1], m[1][1], m[2][1], m[3][1],\n              m[0][2], m[1][2], m[2][2], m[3][2],\n              m[0][3], m[1][3], m[2][3], m[3][3]);\n}\n\n\nfloat inverse_2_1(float m) {\n  return 1.0 / m;\n}\n\nmat2 inverse_2_1(mat2 m) {\n  return mat2(m[1][1],-m[0][1],\n             -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\n\nmat3 inverse_2_1(mat3 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nmat4 inverse_2_1(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\n\n\nattribute vec3 position;\nattribute vec2 texcoord;\nattribute float elevation;\n\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 projection;\n\nuniform float oceanElevationScale;\nuniform float landElevationScale;\n\nvarying vec2 vUv;\nvarying vec3 vPosition;\nvarying vec3 vNormal;\n\nvoid main(void) {\n  mat4 modelView = view * model;\n\n  float PI = 3.14159265;\n\n  vUv = texcoord;\n\n  float scale = 1.0;\n  if (elevation > 0.0) {\n    scale += elevation * landElevationScale;\n  }\n  else {\n    scale += elevation * oceanElevationScale;\n  }\n\n  vec3 spherePosition = scale * position;\n\n  gl_Position = projection * modelView * vec4(spherePosition, 1.0);\n  vPosition = vec3(model * vec4(spherePosition, 1.0));\n\n  mat3 normalMatrix = transpose_1_0(inverse_2_1(mat3(model)));\n  vNormal = normalize(normalMatrix * spherePosition);\n}\n"}),require.register("shaders/night.frag.glsl",function(e,n,t){t.exports="#extension GL_OES_standard_derivatives : enable\nprecision highp float;\n#define GLSLIFY 1\n\nconst float gamma_5_0 = 2.2;\n\nfloat toLinear_5_1(float v) {\n  return pow(v, gamma_5_0);\n}\n\nvec2 toLinear_5_1(vec2 v) {\n  return pow(v, vec2(gamma_5_0));\n}\n\nvec3 toLinear_5_1(vec3 v) {\n  return pow(v, vec3(gamma_5_0));\n}\n\nvec4 toLinear_5_1(vec4 v) {\n  return vec4(toLinear_5_1(v.rgb), v.a);\n}\n\n\n\nconst float gamma_6_2 = 2.2;\n\nfloat toGamma_6_3(float v) {\n  return pow(v, 1.0 / gamma_6_2);\n}\n\nvec2 toGamma_6_3(vec2 v) {\n  return pow(v, vec2(1.0 / gamma_6_2));\n}\n\nvec3 toGamma_6_3(vec3 v) {\n  return pow(v, vec3(1.0 / gamma_6_2));\n}\n\nvec4 toGamma_6_3(vec4 v) {\n  return vec4(toGamma_6_3(v.rgb), v.a);\n}\n\n\n\n// Based on https://github.com/vorg/pragmatic-pbr/blob/master/local_modules/glsl-tonemap-uncharted2/index.glsl\nfloat A_1_4 = 0.15;\nfloat B_1_5 = 0.50;\nfloat C_1_6 = 0.10;\nfloat D_1_7 = 0.20;\nfloat E_1_8 = 0.02;\nfloat F_1_9 = 0.30;\nfloat W_1_10 = 11.2;\n\nvec3 Uncharted2Tonemap_1_11(vec3 x) {\n   return ((x * (A_1_4 * x + C_1_6 * B_1_5) + D_1_7 * E_1_8) / (x * (A_1_4 * x + B_1_5) + D_1_7 * F_1_9)) - E_1_8 / F_1_9;\n}\n\n// Based on Filmic Tonemapping Operators http://filmicgames.com/archives/75\nvec3 tonemap_1_12(vec3 color) {\n    float ExposureBias = 2.0;\n    vec3 curr = Uncharted2Tonemap_1_11(ExposureBias * color);\n\n    vec3 whiteScale = 1.0 / Uncharted2Tonemap_1_11(vec3(W_1_10));\n    return curr * whiteScale;\n}\n\n\n\n// Set camera exposure based on angle between sun and eye\n\nfloat exposure_2_13(vec3 eye, vec3 L) {\n  return mix(\n    1.5,\n    300.0,\n    pow((1.0 - dot(normalize(eye), L)) / 2.0, 10.0)\n  );\n}\n\n\n\nvec3 nightAmbient_3_14(\n  float NdotL,\n  vec3 diffuseColor,\n  float nightLightAmount,\n  vec2 vUv\n) {\n  return 0.01 * (\n    nightLightAmount * vec3(1.0, 1.0, 0.8) +\n    0.1 * vec3(0.1, 0.1, 1.0) * diffuseColor\n  ) * clamp((-NdotL + 0.01) * 2.0, 0.0, 1.0);\n}\n\n\n\n// Based on:\n// http://stackoverflow.com/questions/13501081/efficient-bicubic-filtering-code-in-glsl\n\nvec4 cubic_4_15(float v) {\n  vec4 n = vec4(1.0, 2.0, 3.0, 4.0) - v;\n  vec4 s = n * n * n;\n  float x = s.x;\n  float y = s.y - 4.0 * s.x;\n  float z = s.z - 4.0 * s.y + 6.0 * s.x;\n  float w = 6.0 - x - y - z;\n  return vec4(x, y, z, w);\n}\n\nvec4 texture2DCubic_4_16(\n  sampler2D tex,\n  vec2 uv,\n  vec2 textureResolution\n) {\n  vec2 texcoord = uv * textureResolution;\n  texcoord -= vec2(0.5);\n  float fx = fract(texcoord.x);\n  float fy = fract(texcoord.y);\n  texcoord.x -= fx;\n  texcoord.y -= fy;\n\n  vec4 xcubic = cubic_4_15(fx);\n  vec4 ycubic = cubic_4_15(fy);\n\n  vec4 c = vec4(\n    texcoord.x - 0.5,\n    texcoord.x + 1.5,\n    texcoord.y - 0.5,\n    texcoord.y + 1.5\n  );\n\n  vec4 s = vec4(\n    xcubic.x + xcubic.y,\n    xcubic.z + xcubic.w,\n    ycubic.x + ycubic.y,\n    ycubic.z + ycubic.w\n  );\n\n  vec4 offset = c + vec4(\n    xcubic.y,\n    xcubic.w,\n    ycubic.y,\n    ycubic.w\n  ) / s;\n\n  vec4 sample0 = texture2D(tex,\n    vec2(offset.x, offset.z) / textureResolution);\n\n  vec4 sample1 = texture2D(tex,\n    vec2(offset.y, offset.z) / textureResolution);\n\n  vec4 sample2 = texture2D(tex,\n    vec2(offset.x, offset.w) / textureResolution);\n\n  vec4 sample3 = texture2D(tex,\n    vec2(offset.y, offset.w) / textureResolution);\n\n  float sx = s.x / (s.x + s.y);\n  float sy = s.z / (s.z + s.w);\n\n  return mix(\n    mix(sample3, sample2, sx),\n    mix(sample1, sample0, sx),\n    sy\n  );\n}\n\n\n\n\nuniform sampler2D topographyMap;\nuniform sampler2D diffuseMap;\nuniform sampler2D landmaskMap;\nuniform sampler2D bordersMap;\nuniform vec2 bordersMapSize;\nuniform sampler2D lightsMap;\nuniform vec3 eye;\n\nvarying vec2 vUv;\nvarying vec3 vPosition;\nvarying vec3 vNormal;\n\nvoid main() {\n  float landness = texture2D(landmaskMap, vUv, -0.25).r;\n  float countryBorder = texture2DCubic_4_16(\n    bordersMap,\n    vUv,\n    bordersMapSize\n  ).r;\n\n  float oceanDepth = (0.5 - texture2D(topographyMap, vUv).r) * 2.0;\n\n  vec3 oceanColor = mix(\n    vec3(0.0, 0.0, 0.3),\n    vec3(0.0, 0.0, 0.35),\n    oceanDepth\n  );\n\n  vec3 diffuseColor = mix(\n    oceanColor,\n    toLinear_5_1(texture2D(diffuseMap, vUv).rgb),\n    landness\n  );\n\n  vec3 color = nightAmbient_3_14(\n    -1.0,\n    diffuseColor,\n    texture2D(lightsMap, vUv).x,\n    vUv\n  );\n\n  vec3 shaded = toGamma_6_3(tonemap_1_12(color * 200.0));\n  vec3 final = shaded + countryBorder;\n  gl_FragColor = vec4(final, 1.0);\n}\n"}),require.alias("buffer/index.js","buffer"),require.alias("process/browser.js","process"),e=require("process"),require.register("___globals___",function(e,n,t){})}(),require("___globals___");